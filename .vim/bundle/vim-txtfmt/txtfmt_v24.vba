" Vimball Archiver by Charles E. Campbell, Jr., Ph.D.
UseVimball
finish
plugin/txtfmt.vim	[[[1
3104
" Txtfmt: Set of Vim plugins (syntax, ftplugin, plugin) for creating and
" displaying formatted text with Vim.
" File: This is the global plugin file, which contains configuration code
" needed by both the ftplugin and the syntax files.
" Creation:	2004 Nov 06
" Last Change: 2010 Sep 18
" Maintainer:	Brett Pershing Stahlman <brettstahlman@comcast.net>
" License:	This file is placed in the public domain.

" Note: The following line is required by a packaging script
let g:Txtfmt_Version = "2.4"

" Autocommands needed by refresh mechanism <<<
au FileType * call s:Txtfmt_save_filetype()
au Syntax * call s:Txtfmt_save_syntax()
fu! s:Txtfmt_save_filetype()
	let l:filetype = expand("<amatch>")
	if l:filetype =~ '\%(^\|\.\)txtfmt\%(\.\|$\)'
		let b:txtfmt_filetype = l:filetype
	endif
endfu
fu! s:Txtfmt_save_syntax()
	let l:syntax = expand("<amatch>")
	if l:syntax =~ '\%(^\|\.\)txtfmt\%(\.\|$\)'
		let b:txtfmt_syntax = l:syntax
	endif
endfu
" >>>
" Constants needed regardless of whether common config is being performed <<<
" The following is passed to s:New_window() to construct the test page
let s:TESTPAGE_WINHEIGHT = 20
" >>>
" Functions needed regardless of whether common config is being performed <<<
" Function: s:Is_txtfmt_modeline() <<<
" Purpose: Return nonzero if and only if the line whose text is input "looks
" like" a txtfmt modeline.
" Note: Option names and values are NOT validated. That function is performed
" by s:Process_txtfmt_modeline.
" Inputs:
" linestr  -A line of text that may or may not represent a txtfmt modeline.
" Note: Format of the modeline is as follows:
" (Based upon 1st Vim modeline format)
"	[text]{white}txtfmt:[white]{options}
"	{options} can be the following:
"	{tokrange|rng}=<hex>|<dec>[sSlL]
"	{escape|esc}={self|bslash|none}
"	{sync}={<hex>|<dec>|fromstart|none}
"	{bgcolor|bg}=<color>
"	{nested|nst}
"	{concealcursor|cocu}=[n][v][i][c]
" Must be no whitespace surrounding the '='
" Also: Since Vim will not choke on a trailing ':' (though it's not
" technically part of the 1st modeline format), neither will I.
" Define regexes used to process modeline
" Also: ' txtfmt:' with no options is not an error, but will not be recognized
" as a modeline. Rationale: If user doesn't define any options in a modeline,
" assume it's just text that looks like the start of a modeline.
let s:re_ml_start = '\%(.\{-}\%(\s\+txtfmt:\s*\)\)'
let s:re_ml_name  = '\%(\I\i*\)'
let s:re_ml_val   = '\%(\%(\\.\|[^:[:space:]]\)*\)'
let s:re_ml_el    = '\%('.s:re_ml_name.'\%(='.s:re_ml_val.'\)\?\)'
let s:re_ml_elsep = '\%(\s\+\|\s*:\s*\)'
let s:re_ml_end   = '\%(\s*:\?\s*$\)'
" Construct pattern matching entire line, which will capture all leading text
" in \1, all options in \2, and all trailing text in \3
let s:re_modeline = '\('.s:re_ml_start.'\)\('
			\.s:re_ml_el.'\%('.s:re_ml_elsep.s:re_ml_el.'\)*\)'
			\.'\('.s:re_ml_end.'\)'
fu! s:Is_txtfmt_modeline(linestr)
	return a:linestr =~ s:re_modeline
endfu
" >>>
" Function: s:New_window <<<
" Description: Attempt to create display window of at least the
" specified size for things like test page and tutorial. If possible,
" don't change the height of existing windows (other than the current
" one). Note that this is easy to accomplish, even when 'ea' is set,
" because the `:N new' form effectively overrides 'ea'. If the current
" window is small, we may not be able to avoid shrinking the height of
" existing windows; fortunately, when the `:N new' form is used, Vim
" shrinks as few windows as possible, starting with the current one.
" Note On Size Calculation: Making a *precise" determination as to
" whether we could make the new window higher than requested height by
" halfing the current window would require special logic involving the
" 'laststatus' option. Fortunately, it is not necessary to make a
" precise determination. We can simply assume worst-case: i.e., the
" original winheight() will be reduced by 2 statuslines when the new
" window is created. This corresponds to the case in which 'laststatus'
" == 1, and there's only 1 window before the new one is created.
" Rationale: Using this simplification may result in our sometimes
" creating a window with exactly the requested height, when we might
" have made it a line or so higher, but this is not a problem, and the
" extra logic required to 'fix' it is not justified.
" Important Note: We need to check for error generated by the :new
" command. In particular, E36 will be generated if there's not enough
" space to create the new window. Note that the rules Vim uses to
" determine whether space is sufficient depend upon current setting of
" 'ea').
" Return: Nonzero on success, zero on failure
" Error: Set s:err_str and return zero
fu! s:New_window(height)
	let avail_height = winheight(0) - 2
	" Determine size of window to create
	if avail_height > 2 * a:height
		" Make test page half current window height (which should be >=
		" requested height)
		let create_height = avail_height / 2
	else
		" Make test page exactly the requested height
		let create_height = a:height
	endif
	" Create the window
	let v:errmsg = ''
	exe 'silent! ' . create_height . 'new'
	" Check for E36
	if v:errmsg != ''
		" Make error string available to caller and return false
		let s:err_str = v:errmsg
		return 0
	else
		" return true for Success
		return 1
	endif
endfu
" >>>
" >>>
" IMPORTANT NOTE: The common configuration code in this file is intended to be
" executed only upon request by either the txtfmt ftplugin or syntax file.
" Since this file resides in the Vim plugin directory, it will be sourced by
" Vim automatically whenever Vim is started; the common configuration code,
" however, will not be executed at Vim startup because the special txtfmt
" variable b:txtfmt_do_common_config will not be set at that time. When either
" the ftplugin or syntax file wishes to execute the code in this script, it
" sets b:txtfmt_do_common_config and uses :runtime to source this file. When
" the common configuration code within this file executes, it makes its output
" available to both ftplugin and syntax files via buffer-local variables.

if exists('b:txtfmt_do_common_config')
" Needed for both ftplugin and syntax
" Command: Refresh <<<
com! -buffer Refresh call s:Txtfmt_refresh()
" >>>
" Autocommands <<<
" Ensure that common configuration will be redone whenever the txtfmt buffer
" is re-read (e.g. after a txtfmt-modeline has been changed).
" Note: This autocmd allows user simply to do ":e" at the Vim command line to
" resource everything, including the option processing in common config.
augroup TxtfmtCommonConfig
	au BufReadPre <buffer> :unlet! b:txtfmt_did_common_config
augroup END
" >>>
" Common constant definitions <<<

" Define first Vim version that supported undercurl
let b:txtfmt_const_vimver_undercurl = 700
" Define several sets of constants needed by the functions used to process
" 'tokrange' option.
" Define tokrange defaults (decomposed into 'starttok' and 'formats' values)
" as a function of encoding class.
" Note: starttok encoded as string to preserve dec or hex display preference
let b:txtfmt_const_starttok_def_{'1'}    = '180'
let b:txtfmt_const_formats_def_{'1'}     = 'X'
let b:txtfmt_const_starttok_def_{'2'}    = '180'
let b:txtfmt_const_formats_def_{'2'}     = 'X'
let b:txtfmt_const_starttok_def_{'u'}    = '0xE000'
let b:txtfmt_const_formats_def_{'u'}     = 'X'
" Define the number of tokens in the txtfmt token range as a function of
" the format variant flags (which determine num_attributes in the equations
" below):
" --no background colors--
" N = 2 ^ {num_attributes} + 9
" --background colors--
" N = 2 ^ {num_attributes} + 9 + 9
" Important Note: The numbers are not dependent upon the number of active fg
" and bg colors, since we always reserve 8 colors.

" The 3 parameters in the following constants represent the following 3 format
" variant flags:
" txtfmt_cfg_bgcolor
" txtfmt_cfg_longformats
" txtfmt_cfg_undercurl
" Note: Value supplied for longformats and undercurl indices must take 'pack'
" option into account.
" TODO: Fix the final 3 elements or get rid of this array altogether. Note
" that it doesn't take 'pack' option into account
let b:txtfmt_const_tokrange_size_{0}{0}{0} = 17 
let b:txtfmt_const_tokrange_size_{0}{1}{0} = 41 
let b:txtfmt_const_tokrange_size_{0}{1}{1} = 73 
let b:txtfmt_const_tokrange_size_{1}{0}{0} = 26 
let b:txtfmt_const_tokrange_size_{1}{1}{0} = 82 
let b:txtfmt_const_tokrange_size_{1}{1}{1} = 82 

" Make sure we can easily deduce the suffix from the format variant flags
let b:txtfmt_const_tokrange_suffix_{0}{0}{0} = 'S'
let b:txtfmt_const_tokrange_suffix_{0}{1}{0} = 'L'
let b:txtfmt_const_tokrange_suffix_{0}{1}{1} = 'L'
let b:txtfmt_const_tokrange_suffix_{1}{0}{0} = 'X'
let b:txtfmt_const_tokrange_suffix_{1}{1}{0} = 'XL'
let b:txtfmt_const_tokrange_suffix_{1}{1}{1} = 'XL'

" Define the maximum character code that may be used as a txtfmt token as a
" function of encoding class. (Encoding class is specified as '1' for single
" byte, '2' for 16-bit and 'u' for unicode.)
" Note: Vim doesn't support unicode chars larger than 16-bit.
let b:txtfmt_const_tokrange_limit_{'1'} = 0xFF
let b:txtfmt_const_tokrange_limit_{'2'} = 0xFFFF
let b:txtfmt_const_tokrange_limit_{'u'} = 0xFFFF
" The following regex describes a {number} that may be used to set a numeric
" option. The txtfmt help specifies that only decimal or hexadecimal formats
" are permitted.
let b:txtfmt_re_number_atom = '\([1-9]\d*\|0x\x\+\)'

" >>>
" General utility functions <<<
" Function: s:Repeat() <<<
" Purpose: Generate a string consisting of the input string repeated the
" requested number of times.
" Note: Vim7 added a repeat() function, but I'm intentionally not using
" anything added post-Vim6.
" Input:
" str       - string to repeat
" cnt       - number of times to repeat it
" Return: The generated string
fu! s:Repeat(str, cnt)
	let ret_str = ''
	let i = 0
	while i < a:cnt
		let ret_str = ret_str . a:str
		let i = i + 1
	endwhile
	return ret_str
endfu
" >>>
" >>>
" Parse_<...> functions <<<
" Function: s:Parse_init()
" Purpose:
" Input:
" text		- string to be parsed
" re_tok	- regex matching a token
" Return: ID that must be passed to the other parse functions (-1 indicates
" error)
" Simulated struct:
" text
" len
" re
" pos
fu! s:Parse_init(text, re_tok)
	let i = 0
	let MAX_PARSE_INSTANCES = 1000
	while i < MAX_PARSE_INSTANCES
		if !exists('s:parsedata_'.i.'_text')
			" Found a free one
			let s:parsedata_{i}_text = a:text
			let s:parsedata_{i}_len = strlen(a:text)	" for speed
			let s:parsedata_{i}_re = a:re_tok
			let s:parsedata_{i}_pos = 0
			return i
		endif
		let i = i + 1
	endwhile
	if i >= MAX_PARSE_INSTANCES
		echoerr "Internal Parse_init error - contact developer"
		return -1
	endif
endfu
" Function: s:Parse_nexttok()
" Purpose:
" Input:
" Return: The next token as a string (or empty string if no more tokens)
" Error: Not possible when used correctly, and since this is an internally
" used function, we will not check for error.
fu! s:Parse_nexttok(parse_id)
	" Note: Structures used and generated internally in controlled manner, so
	" assume parse_id points to valid struct
	let text = s:parsedata_{a:parse_id}_text
	let re = s:parsedata_{a:parse_id}_re
	let pos = s:parsedata_{a:parse_id}_pos
	let len = s:parsedata_{a:parse_id}_len
	let parse_complete = 0	" set if text exhausted
	" Did last call exhaust text?
	if pos >= len
		let parse_complete = 1
		let ret_str = ''
	else
		" text not exhausted yet - get past any whitespace
		" ^\s* will return pos if no whitespace at pos (cannot return -1)
		let pos = matchend(text, '^\s*', pos)
		" Did we move past trailing whitespace?
		if pos >= len
			let parse_complete = 1
			let ret_str = ''
		else
			" We're sitting on first char to be returned.
			" re determines how many more will be part of return str
			" Note: Force re to match at current pos if at all
			let pos2 = matchend(text, '^'.re, pos)
			if pos2 < 0
				" curr char is not part of a token, so just return it by itself
				let ret_str = text[pos]
				let pos = pos + 1
			else
				" Return the token whose end was located
				let ret_str = strpart(text, pos, pos2-pos)
				let pos = pos2
			endif
		endif
	endif
	" Only way out of this function
	if parse_complete
		call s:Parse_free(a:parse_id)
	else
		" Update pos in structure for next call...
		let s:parsedata_{a:parse_id}_pos = pos
	endif
	return ret_str
endfu
" Function: s:Parse_free()
" Purpose: Free the data structures for a particular parse instance (denoted
" by input id)
" Input: parse_id - parse instance whose data is to be freed
" Return: none
" Error: not possible
fu! s:Parse_free(parse_id)
	" Using unlet! ensures that error not possible
	unlet! s:parsedata_{a:parse_id}_text
	unlet! s:parsedata_{a:parse_id}_re
	unlet! s:parsedata_{a:parse_id}_pos
	unlet! s:parsedata_{a:parse_id}_len

endfu
" >>>
" Configuration utility functions (common) <<<
" >>>
" encoding utility functions (common) <<<
let s:re_encs_1 = '^\%('
			\.'latin1\|iso-8859-n\|koi8-r\|koi8-u'
			\.'\|macroman\|cp437\|cp737\|cp775'
			\.'\|cp850\|cp852\|cp855\|cp857'
			\.'\|cp860\|cp861\|cp862\|cp863'
			\.'\|cp865\|cp866\|cp869\|cp874'
			\.'\|cp1250\|cp1251\|cp1253\|cp1254'
			\.'\|cp1255\|cp1256\|cp1257\|cp1258'
			\.'\)$'
let s:re_encs_2 = '^\%('
			\.'cp932\|euc-jp\|sjis\|cp949'
			\.'\|euc-kr\|cp936\|euc-cn\|cp950'
			\.'\|big5\|euc-tw'
			\.'\)'
let s:re_encs_u = '^\%('
			\.'utf-8\|ucs-2\|ucs-2le\|utf-16\|utf-16le\|ucs-4\|ucs-4le'
			\.'\)'
" Function: TxtfmtCommon_Encoding_get_class() <<<
" Purpose: Return single character indicating whether the input encoding name
" represents a 1-byte encoding ('1'), a 2-byte encoding ('2'), or a unicode
" encoding ('u'). If input encoding name is unrecognized, return empty string.
fu! TxtfmtCommon_Encoding_get_class(enc)
	if a:enc  =~ s:re_encs_1
		return '1'
	elseif a:enc =~ s:re_encs_2
		return '2'
	elseif a:enc =~ s:re_encs_u
		return 'u'
	else
		return ''
	endif
endfu
" >>>
" >>>
" 'tokrange' utility functions <<<
" Construct pattern that will capture char code in \1 and optional size
" specification (sSlLxX) in \2.
if exists('g:txtfmtAllowxl') && g:txtfmtAllowxl
	" Note: By default, XL suffix is illegal, but user has overridden the
	" default
	let s:re_tokrange_spec = '^\([1-9]\d*\|0x\x\+\)\(\%([sSlL]\|[xX][lL]\?\)\?\)$'
else
	let s:re_tokrange_spec = '^\([1-9]\d*\|0x\x\+\)\([sSlLxX]\?\)$'
endif

" Function: s:Tokrange_is_valid() <<<
" Purpose: Indicate whether input string is a valid tokrange spec.
fu! s:Tokrange_is_valid(spec)
	return a:spec =~ s:re_tokrange_spec
endfu
" >>>
" Function: s:Tokrange_get_formats() <<<
" Purpose: Return 'formats' component of the input tokrange spec.
" Note: If optional 'formats' component is omitted, empty string will be
" returned.
" Note: formats spec will be returned in canonical form (uppercase).
" Assumption: Input string has already been validated by s:Tokrange_is_valid.
fu! s:Tokrange_get_formats(spec)
	return substitute(a:spec, s:re_tokrange_spec, '\U\2', '')
endfu
" >>>
" Function: s:Tokrange_translate_tokrange() <<<
" Description: Decompose the input tokrange into its constituent parts,
" setting all applicable option variables:
" b:txtfmt_cfg_starttok
" b:txtfmt_cfg_bgcolor
" b:txtfmt_cfg_longformats
" b:txtfmt_cfg_undercurl
" b:txtfmt_cfg_starttok_display
" b:txtfmt_cfg_formats_display
fu! s:Tokrange_translate_tokrange(tokrange)
	" Extract starttok and formats from input tokrange
	let starttok_str = substitute(a:tokrange, s:re_tokrange_spec, '\1', '') 
	let formats_str = substitute(a:tokrange, s:re_tokrange_spec, '\2', '') 

	" Decompose starttok into a numeric and a display portion
	let b:txtfmt_cfg_starttok = 0 + starttok_str
	let b:txtfmt_cfg_starttok_display = starttok_str

	" Decompose formats into constituent flags and a display portion
	" Note: Formats is a bit special. For one thing, it can be omitted from a
	" tokrange spec, in which case we'll choose a default. Also, long formats
	" ('L') can mean either 'all' or 'all_but_undercurl', depending upon Vim
	" version and b:txtfmt_cfg_undercurlpref. (Undercurl was not supported
	" until Vim version 7.0, and we allow user to disable it with the
	" 'undercurl' option even when it is supported.)
	" Note: b:txtfmt_cfg_undercurl is always set explicitly to 0 when it
	" doesn't apply, so that it can be used in parameterized variable names.
	if strlen(formats_str) == 0
		" Format suffix was omitted. Default to 'extended' formats (background
		" colors with short formats)
		let b:txtfmt_cfg_bgcolor = 1
		let b:txtfmt_cfg_longformats = 0
		let b:txtfmt_cfg_undercurl = 0
		let b:txtfmt_cfg_formats_display = 'X'
	elseif formats_str ==? 'L'
		" Long formats with no background colors
		let b:txtfmt_cfg_bgcolor = 0
		let b:txtfmt_cfg_longformats = 1
		if v:version >= b:txtfmt_const_vimver_undercurl && b:txtfmt_cfg_undercurlpref
			let b:txtfmt_cfg_undercurl = 1
		else
			let b:txtfmt_cfg_undercurl = 0
		endif
		let b:txtfmt_cfg_formats_display = 'L'
	elseif formats_str ==? 'X'
		" Background colors with short formats
		let b:txtfmt_cfg_bgcolor = 1
		let b:txtfmt_cfg_longformats = 0
		let b:txtfmt_cfg_undercurl = 0
		let b:txtfmt_cfg_formats_display = 'X'
	elseif formats_str ==? 'XL'
		" Background colors with long formats
		let b:txtfmt_cfg_bgcolor = 1
		let b:txtfmt_cfg_longformats = 1
		if v:version >= b:txtfmt_const_vimver_undercurl && b:txtfmt_cfg_undercurlpref
			let b:txtfmt_cfg_undercurl = 1
		else
			let b:txtfmt_cfg_undercurl = 0
		endif
		" Note: This is no longer legal!!!!
		let b:txtfmt_cfg_formats_display = 'XL'
	else
		" Short formats
		let b:txtfmt_cfg_bgcolor = 0
		let b:txtfmt_cfg_longformats = 0
		let b:txtfmt_cfg_undercurl = 0
		let b:txtfmt_cfg_formats_display = 'S'
	endif
endfu
" >>>
" Function: s:Tokrange_size() <<<
" Note: Now that I'm reserving 8 colors even when numfgcolors and numbgcolors
" are less than 8, this function can probably be removed, or at least renamed
" (e.g., Tokrange_used_size).
fu! s:Tokrange_size(formats)
	return b:txtfmt_const_tokrange_size_{a:formats}
endfu
" >>>
" >>>
" 'sync' utility functions <<<
" Construct pattern that will validate the option value.
let s:re_sync_number_spec = '^\([1-9]\d*\|0x\x\+\)$'
let s:re_sync_name_spec = '^fromstart\|none$'

" Function: s:Sync_is_valid() <<<
" Purpose: Indicate whether input string is a valid sync option value
fu! s:Sync_is_valid(spec)
	return a:spec =~ s:re_sync_number_spec || a:spec =~ s:re_sync_name_spec
endfu
" >>>
" Function: s:Sync_get_method() <<<
" Purpose: Determine the syncmethod represented by the input sync value and
" return its name. Possible values: 'minlines', 'fromstart', 'none'
" Assumption: Input string has already been validated by s:Sync_is_valid.
fu! s:Sync_get_method(spec)
	if a:spec =~ s:re_sync_name_spec
		return a:spec
	else
		return 'minlines'
	endif
endfu
" >>>
" >>>
" 'escape' utility functions <<<
" Construct pattern that will validate the option value.
let s:re_escape_optval = '^\%(none\|bslash\|self\)$'
" Function: s:Escape_is_valid() <<<
" Purpose: Indicate whether input string is a valid escape option value
fu! s:Escape_is_valid(optval)
	return a:optval =~ s:re_escape_optval
endfu
" >>>
" >>>
" 'concealcursor' utility functions <<<
" Construct pattern that will validate the option value.
let s:re_concealcursor_optval = '^[nvic]*$'
" Function: s:Concealcursor_is_valid() <<<
" Purpose: Indicate whether input string is a valid concealcursor option value
fu! s:Concealcursor_is_valid(optval)
	return a:optval =~ s:re_concealcursor_optval
endfu
" >>>
" >>>
" Number validation utility functions <<<
" Function: s:Number_is_valid(s)
" Purpose: Indicate whether the input string represents a valid number
fu! s:Number_is_valid(s)
	return a:s =~ '^\s*'.b:txtfmt_re_number_atom.'\s*$'
endfu
" >>>
" Num fg/bg colors validation utility function <<<
let s:re_num_clrs = '^\%(0x\)\?[0-8]$'
fu! s:Numclrs_is_valid(s)
	return a:s =~ s:re_num_clrs
endfu
" >>>
" fg/bg color mask validation utility function <<<
let s:re_clr_mask = '^[01]\{8}$'
fu! s:Clrmask_is_valid(s)
	return a:s =~ s:re_clr_mask
endfu
" >>>
" Function: s:Set_tokrange() <<<
" Purpose: Set b:txtfmt_cfg_starttok, b:txtfmt_cfg_bgcolor,
" b:txtfmt_cfg_longformats and b:txtfmt_cfg_undercurl options, taking into
" account any user-setting of 'tokrange' option, and if necessary, the txtfmt
" defaults, which may take 'encoding' into consideration.
" Note: If set via modeline, tokrange option value must be a literal tokrange
" specification; however, buf-local and global option variables may be set to
" either a valid tokrange spec, or a Vim expression that evaluates to one.
" Permitting arbitrary Vim expressions facilitates the use of complex tokrange
" selection logic, implemented by a user-defined expression or function.
"  Examples:
"      'g:My_tokrange_calculator()'
"      '&enc == "utf-8" ? "1400l" : "130s"' 
fu! s:Set_tokrange()
	" Undef variables that are outputs of this function. Note that these
	" variables are the decomposition of b:txtfmt_cfg_tokrange, which may or
	" may not be set at this point.
	unlet! b:txtfmt_cfg_starttok
		\ b:txtfmt_cfg_bgcolor b:txtfmt_cfg_longformats b:txtfmt_cfg_undercurl
		\ b:txtfmt_cfg_starttok_display b:txtfmt_cfg_formats_display
	" Cache the 'encoding' in effect
	let enc = &encoding
	" Determine the corresponding encoding class
	let enc_class = TxtfmtCommon_Encoding_get_class(enc)
	if !exists('b:txtfmt_cfg_tokrange') || strlen(b:txtfmt_cfg_tokrange) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value.
		if exists('b:txtfmt_cfg_tokrange') && strlen(b:txtfmt_cfg_tokrange) == 0
			" Bad modeline set
			let l:warnmsg =
				\"Warning: Ignoring invalid modeline value for txtfmt `tokrange' option"
		elseif exists('b:txtfmtTokrange')
			" User overrode buf-local option. Save the option for validation
			" below...
			let b:txtfmt_cfg_tokrange = b:txtfmtTokrange
			let l:set_by = 'b'
		elseif exists('g:txtfmtTokrange')
			" User overrode global option. Save the option for validation
			" below...
			let b:txtfmt_cfg_tokrange = g:txtfmtTokrange
			let l:set_by = 'g'
		endif
	endif
	if exists('l:set_by') && (l:set_by == 'b' || l:set_by == 'g')
		" Perform special validation for buf-local/global settings, which
		" permits either a tokrange spec or a Vim expression that evaluates to
		" one.
		if !s:Tokrange_is_valid(b:txtfmt_cfg_tokrange)
			" Not a valid tokrange literal. Let's see whether it evaluates to
			" one.
			let v:errmsg = ''
			" Evaluate expression, using silent! to prevent problems in the
			" event that rhs is invalid.
			silent! exe 'let l:tokrange = '.b:txtfmt_cfg_tokrange
			if v:errmsg != ''
				" Bad expression
				let l:warnmsg =
					\"Warning: Ignoring invalid ".(l:set_by == 'b' ? 'buf-local' : 'global')
					\." value for txtfmt 'tokrange' option: ".b:txtfmt_cfg_tokrange
				" Discard the invalid setting
				let b:txtfmt_cfg_tokrange = ''
			else
				" It was a valid Vim expression. Did it produce a valid
				" tokrange spec?
				if !s:Tokrange_is_valid(l:tokrange)
					let l:warnmsg =
						\"Ignoring ".(l:set_by == 'b' ? 'buf-local' : 'global')
						\." set of txtfmt `tokrange' option: `".b:txtfmt_cfg_tokrange
						\."' produced invalid option value: ".l:tokrange
					" Discard the invalid setting
					let b:txtfmt_cfg_tokrange = ''
				else
					" Save the valid setting
					let b:txtfmt_cfg_tokrange = l:tokrange
				endif
			endif
		endif
	endif
	" Warn user if invalid user-setting is about to be overridden
	if exists('l:warnmsg')
		echoerr l:warnmsg
	endif
	" Decompose any valid user setting stored in b:txtfmt_cfg_tokrange.

	" Note: The output from the preceding stage is b:txtfmt_cfg_tokrange,
	" which we must now decompose into b:txtfmt_cfg_starttok,
	" b:txtfmt_cfg_bgcolor, b:txtfmt_cfg_longformats, b:txtfmt_cfg_undercurl,
	" b:txtfmt_cfg_starttok_display and b:txtfmt_cfg_formats_display. If
	" b:txtfmt_cfg_tokrange is nonexistent or null, there is no valid user
	" setting, in which case, we'll supply default.
	if exists('b:txtfmt_cfg_tokrange') && strlen(b:txtfmt_cfg_tokrange)
		" Decompose valid tokrange setting via s:Tokrange_translate_tokrange,
		" which sets all constituent variables.
		call s:Tokrange_translate_tokrange(b:txtfmt_cfg_tokrange)
		" Perform upper-bound validation
		if b:txtfmt_cfg_starttok +
			\ b:txtfmt_const_tokrange_size_{b:txtfmt_cfg_bgcolor}{b:txtfmt_cfg_longformats}{b:txtfmt_cfg_undercurl}
			\ - 1
			\ > b:txtfmt_const_tokrange_limit_{enc_class}
			" Warn user and use default
			echoerr
				\ "Warning: Tokrange value '".b:txtfmt_cfg_tokrange."' causes upper"
				\." bound to be exceeded for encoding ".&enc
			" Make sure we set to default below
			" Note: It suffices to unlet b:txtfmt_cfg_starttok, since its
			" nonexistence will ensure that all constituent vars are set below
			unlet! b:txtfmt_cfg_starttok
		endif
	endif
	" If b:txtfmt_cfg_starttok is still undefined, see whether there's an
	" encoding-specific default.
	" Note: b:txtfmt_cfg_starttok was unlet at the top of this function, so it
	" will be undefined unless it's been set successfully.
	if !exists('b:txtfmt_cfg_starttok')
		" TODO - Put any logic that depends upon specific encoding here...
		" .
		" .

	endif
	" If b:txtfmt_cfg_starttok is still undefined, see whether there's an
	" encoding-class-specific default.
	if !exists('b:txtfmt_cfg_starttok')
		" If encoding class is unrecognized, default to '1'
		if enc_class == ''
			let use_enc_class = '1'
		else
			let use_enc_class = enc_class
		endif
		" Pass default tokrange to function that will decompose it and set all
		" constituent variables.
		call s:Tokrange_translate_tokrange(
			\ b:txtfmt_const_starttok_def_{use_enc_class}
			\ . b:txtfmt_const_formats_def_{use_enc_class}
		\)
	endif
	" Note: If b:txtfmt_cfg_tokrange exists, we are done with it now that it
	" has been completely decomposed
	unlet! b:txtfmt_cfg_tokrange
	" Save the encoding class for later use (will be needed by Define_syntax
	" logic used to determine whether syn match offsets are byte or
	" char-based)
	let b:txtfmt_cfg_enc_class = enc_class
	" Also save encoding itself. If we're using a cached copy of encoding
	" class, we should be able to verify that the encoding upon which it is
	" based is the currently active one.
	let b:txtfmt_cfg_enc = enc
endfu
" >>>
" Function: s:Set_syncing() <<<
" Purpose: Set b:txtfmt_cfg_syncmethod and (if applicable) b:txtfmt_cfg_synclines
" options, according to the following logic:
" 1) If user set sync option via modeline, buffer-local option, or global
" option, attempt to use the setting with the highest priority.
" 2) If step 1 fails to set the option, either because of error or because the
" user made no attempt to set, default to minlines=250
" Note: From a user perspective, there is only the 'sync' option. For
" convenience within the plugin, we break this single option into two options:
" 'syncmethod' and 'synclines'. Currently, 'synclines' is used only when
" syncmethod=minlines.
fu! s:Set_syncing()
	if !exists('b:txtfmt_cfg_sync') || strlen(b:txtfmt_cfg_sync) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value.
		if exists('b:txtfmt_cfg_sync') && strlen(b:txtfmt_cfg_sync) == 0
			" Bad modeline set
			let l:bad_set_by = 'm'
		elseif exists('b:txtfmtSync')
			" User overrode buf-local option
			if s:Sync_is_valid(b:txtfmtSync)
				let b:txtfmt_cfg_sync = b:txtfmtSync
			else
				let l:bad_set_by = 'b'
			endif
		elseif exists('g:txtfmtSync')
			" User overrode global option
			if s:Sync_is_valid(g:txtfmtSync)
				let b:txtfmt_cfg_sync = g:txtfmtSync
			else
				let l:bad_set_by = 'g'
			endif
		endif
	endif
	" Warn user if invalid user-setting is about to be overridden
	if exists('l:bad_set_by')
		" Note: Display the offending option value for buf-local or global
		" option, but not for modeline, since modeline processing has already
		" reported the error.
		echoerr "Warning: Ignoring invalid ".(
			\ l:bad_set_by == 'm' ? "modeline" :
			\ l:bad_set_by == 'b' ? "buf-local" :
			\ "global") . " value for txtfmt `sync' option" . (
			\ l:bad_set_by == 'm' ? '' :
			\ l:bad_set_by == 'b' ? (': ' . b:txtfmtSync) :
			\ (': ' . g:txtfmtSync))
	endif
	if !exists('b:txtfmt_cfg_sync') || strlen(b:txtfmt_cfg_sync) == 0
		" Set to default
		let b:txtfmt_cfg_syncmethod = 'minlines'
		let b:txtfmt_cfg_synclines = 250
	else
		" Decompose validated 'sync' option into 'syncmethod' and (if
		" applicable) 'synclines'
		let b:txtfmt_cfg_syncmethod = s:Sync_get_method(b:txtfmt_cfg_sync)
		if b:txtfmt_cfg_syncmethod == 'minlines'
			" Save the number of lines
			let b:txtfmt_cfg_synclines = (0 + b:txtfmt_cfg_sync)
		endif
	endif
	" We're done with b:txtfmt_cfg_sync now that it has been completely
	" decomposed.
	unlet! b:txtfmt_cfg_sync
endfu
" >>>
" Function: s:Translate_color_optstr() <<<
" Purpose: Process the string representing a single element from the array
" txtfmtColor{1..8}, and return the extracted information.
" Return: A comma-separated string containing the extracted information as
" follows:
" <namepat>,<ctermfg_rhs>,<guifg_rhs>
" Note that ctermfg_rhs and/or guifg_rhs may be blank, in the event that user
" specified term patterns and none of them matched. (If no term patterns are
" specified, there is an implied match with current &term value.)
" Note that return string will have commas and backslashes escaped.
" Note that the last color def that matches for each of guifg and ctermfg is
" the one that is returned to caller.
" Error: Set s:err_str and return empty string
" Details:
" Here is the format of a single string in the txtfmtColor{} array:
" <namepat>,<clrdef1>[,<clrdef2>,...,<clrdefN>]
" <clrdef> :=
" 	<c|g>[<termpatlist>]:<clrstr>
" 	<termpatlist> :=
" 		:<termpat1>:<termpat2>:...:<termpatN>
" *** Parse table ***
" st	next_st		can_end?	tok
" 0		1			n			<namepat>
" 1		2			n			,
" 2		3			n			<c|g>
" 3		4			n			:
" 4		5			n			str
" 5		4			y			:
" 5		2			y			,
" Example color optstr:
" red,c:xterm:dosterm:DarkRed,g:builtin_gui:other_gui:#FF0000
"
" Here are the meanings of the fields:
" <namepat>	-regex used to recognize the token used to specify a
" 	certain color; e.g., when prompted by one of the insert token maps. May
" 	not contain spaces or commas.
" 	Example: k\|b\%[lack]
" <c|g>				-specifies whether clrstr will be the rhs of a
" 	"ctermfg=" ('c'), or "guifg=" ('g')
" <termpat>	-pattern used to match against &term option. It is a regex pattern
" 	which will be applied as ^<termpat>$
" <clrstr>	-rhs of a "ctermfg=" or "guifg=" assignment.
" 	:help gui-colors | help cterm-colors
" Additional Note:
" Commas, colons, and backslashes appearing in fields must be
" backslash-escaped.
" Note: Due to the extra backslash escaping, it is recommended to use a
" string-literal, rather than double-quoted string.
fu! s:Translate_color_optstr(optstr)
	" optstr is the string to be parsed
	" Initialize the state machine
	let pst = 0
	" Initialize the parse engine to consider tokens to be broken only at
	" unescaped commas and colons.
	let pid = s:Parse_init(a:optstr, '\%(\\.\|[^,:]\)\+')
	if pid < 0
		let s:err_str = 'Internal error within s:Translate_color_optstr(). Contact developer.'
		echomsg 'Internal error'
		return ''
	endif
	" Extract and handle tokens in a loop
	let parse_complete = 0
	" The following 2 will be set in loop (hopefully at least 1 anyways)
	let ctermfg_rhs = ''
	let guifg_rhs = ''
	while !parse_complete
		let tok = s:Parse_nexttok(pid)
		" Note: Could handle end of string here for states in which end of
		" string is illegal - but that would make it more difficult to
		" formulate meaningful error messages.
		"if tok == '' && pst != 5
		"endif
		" Switch on the current state
		if pst == 0	" Extract non empty namepat
			let namepat = substitute(tok, '\\\(.\)', '\1', 'g')
			if namepat =~ '^[[:space:]]*$'
				let s:err_str = "Color def string must contain at least 1 non-whitespace char"
				return ''
			endif
			let pst = 1
		elseif pst == 1
			if tok == ','
				let pst = 2
			elseif tok == ''
				let s:err_str = "Expected comma, encountered end of color def string"
				return ''
			else
				let s:err_str = "Expected comma, got '".tok."'"
				return ''
			endif
		elseif pst == 2
			if tok == 'c' || tok == 'g'
				let pst = 3
				let c_or_g = tok
				" Do some initializations for this cterm/gui
				let tp_or_cs_cnt = 0
				let got_term_match = 0
			elseif tok == ''
				let s:err_str = "Expected 'c' or 'g', encountered end of color def string"
				return ''
			else
				let s:err_str = "Expected 'c' or 'g', got '".tok."'"
				return ''
			endif
		elseif pst == 3
			if tok == ':'
				let pst = 4
			elseif
				let s:err_str = "Expected ':', encountered end of color def string"
				return ''
			else
				let s:err_str = "Expected ':', got '".tok."'"
				return ''
			endif
		elseif pst == 4
			let pst = 5
			" Do some processing with this and possibly previous termpat or
			" clrstr token. Note that if previous one exists, it is termpat;
			" we can't yet know what current one is.
			let termpat_or_clrstr = substitute(tok, '\\\(.\)', '\1', 'g')
			if termpat_or_clrstr =~ '^[[:space:]]*$'
				let s:err_str = "Term patterns and color strings must contain at least one non-whitespace char"
				return ''
			endif
			" If here, update the count. Note that we won't know whether this
			" is termpat or clrstr until next time here.
			let tp_or_cs_cnt = tp_or_cs_cnt + 1
			if !got_term_match && tp_or_cs_cnt > 1
				" Process saved string as termpat
				" Pattern has implied ^ and $. Also, termpat may contain \c
				if &term =~ '^'.tp_or_cs_str.'$'
					" Found a match!
					let got_term_match = 1
				endif
			endif
			" Save current token for processing next time
			let tp_or_cs_str = termpat_or_clrstr
		elseif pst == 5
			if tok == ':'		" another termpat or clrstr
				let pst = 4
			elseif tok == ',' 	" another cterm/gui
				let pst = 2
			elseif tok == ''	" end of string - legal in state 5
				let parse_complete = 1
			else				" illegal token
				let s:err_str = "Unexpected input in color def string: ".tok
				return ''
			endif
			if tok == ',' || tok == ''
				" Need to process saved data from pst 4, which we now know to
				" be a clrstr.
				if tp_or_cs_cnt == 1 || got_term_match
					" Either no termpats were specified (implied match with
					" &term) or one of the termpats matched.
					" Note that prior ctermfg/guifg rhs strings may be
					" overwritten here, if more than one cterm/gui def exists
					" and has a match.
					if c_or_g == 'c'
						let ctermfg_rhs = tp_or_cs_str
					else
						let guifg_rhs = tp_or_cs_str
					endif
				endif
			endif
		endif
	endwhile
	" Construct the return string:
	" <namepat>,<ctermfg_rhs>,<guifg_rhs>
	let ret_str = escape(namepat, ',\').','
		\.escape(ctermfg_rhs, ',\').','.escape(guifg_rhs, ',\')
	return ret_str
endfu
" >>>
" Function: s:Get_color_uniq_idx() <<<
" Purpose: Convert the rhs of b:txtfmt_clr and b:txtfmt_bgc (if applicable) to
" a single string. Look the string up in global array
" g:txtfmt_color_configs{}. If the color config already exists, return its
" index; otherwise, append the color config to a new element at the end of
" g:txtfmt_color_configs{}, and return the corresponding index.
" Note: The index returned will be used to ensure that the highlight groups
" used for this buffer are specific to the color configuration.
" Input: none
" Return: Uniqueness index corresponding to the color configuration stored in
" b:txtfmt_clr and b:txtfmt_bgc (if applicable). In the unlikely event that no
" colors are active in the current configuration (i.e., numfgcolors and
" numbgcolors both equal 0), we return an empty string.
fu! s:Get_color_uniq_idx()
	" Build the string to be looked up
	let s = ''
	let fgbg_idx = 0
	let clr_or_bgc{0} = 'clr'
	let clr_or_bgc{1} = 'bgc'
	let fg_or_bg{0} = 'fg'
	let fg_or_bg{1} = 'bg'
	while fgbg_idx < (b:txtfmt_cfg_bgcolor ? 2 : 1)
		" Loop over all used colors
		" TODO_BG: Does it make sense to include unused ones? It shouldn't be
		" necessary...
		" Note: Index 1 corresponds to first non-default color
		let i = 1
		while i <= b:txtfmt_cfg_num{fg_or_bg{fgbg_idx}}colors
			let s = s.b:txtfmt_{clr_or_bgc{fgbg_idx}}{i}."\<NL>"
			let i = i + 1
		endwhile
		let fgbg_idx = fgbg_idx + 1
	endwhile
	" In the unlikely event that string is still empty, config is such that no
	" colors are in use, in which case, we return an empty string, since no
	" uniqueness index applies.
	if strlen(s) == 0
		return ''
	endif
	" Look up the newly-generated string in g:txtfmt_color_configs
	if !exists('g:txtfmt_color_configs_len')
		let g:txtfmt_color_configs_len = 0
	endif
	let i = 0
	while i < g:txtfmt_color_configs_len
		if g:txtfmt_color_configs{i} == s
			" Color config exists already - return its index
			return i
		endif
		let i = i + 1
	endwhile
	" If here, color config doesn't exist yet, so append it
	let g:txtfmt_color_configs{i} = s
	let g:txtfmt_color_configs_len = g:txtfmt_color_configs_len + 1
	" Return index of appended element
	return i
endfu
" >>>
" Function: s:Process_color_options() <<<
" Purpose: Process the special color definition arrays to determine the color
" arrays in effect for the current buffer. There are global and buffer-local
" versions of both txtfmtColor and txtfmtBgcolor, as well as a default in
" s:txtfmt_clr. From these, we construct the 8 element buf-local arrays,
" described under 'Return:' below.
" Algorithm: Each color index is considered independently of all others, with
" a buf-local definition taking precedence over a global one. A txtfmtBgcolor
" element is always preferred for background color, but txtfmtColor will be
" used for a background color when no background-color-specific element
" exists. If no other element can be found, defaults from s:txtfmt_clr will be
" used.
" Cterm and gui may be overridden separately, and color definition strings may
" even take into account the value of &term. Note that for each possible
" element in the array, there is a default element (in s:txtfmt_clr{1..8}),
" which will be used if user has not overriden.
" Return: indirect only
" Builds the following buffer-scope arrays: (indexed by 1-based color index)
" b:txtfmt_clr_namepat{}, b:txtfmt_clr{}
" b:txtfmt_bgc_namepat{}, b:txtfmt_bgc{}
" Note: bgc arrays will not be built if background colors are disabled.
" Details: The format of the color array is as follows:
" The array has 8 elements (1..8), each of which represents a color region
" begun with one of the 8 successive color tokens in the token range. Each
" element is a string whose format is described in header of
" s:Translate_color_optstr()
" Rules: In outer loop over fg and bg cases, and inner loop over all color
" indices in range i = 1..8, check all applicable variants of the txtfmtColor
" array (as defined in arrname{}) for an element corresponding to the current
" color index. Set b:txtfmt_clr{} and move to next color index as soon as a
" suitable definition is found. Suitability is determined by checking
" has('gui_running') against the 'g:' or 'c:' in the color definition string,
" and if necessary, by matching the current value of 'term' against a 'term'
" pattern in the color definition string.
" Note: This function was rewritten on 10May2008, and then again on 31Jan2009.
" A corresponding partial rewrite of s:Translate_color_optstr is probably in
" order, but is not necessary, so I've left the latter function completely
" intact for now. (We don't really need both ctermfg and guifg values any
" more, but s:Translate_color_optstr still returns both...)
fu! s:Process_color_options()
	let arrname{0} = 'b:txtfmtBgcolor'
	let arrname{1} = 'g:txtfmtBgcolor'
	let arrname{2} = 'b:txtfmtColor'
	let arrname{3} = 'g:txtfmtColor'
	let arrname{4} = 's:txtfmt_clr'
	" TODO_BG: Decide whether s:txtfmt_bgc should be removed - if so, may get
	" rid of arr_end{}
	" Define strings used to build appropriate var names for both fg and bg
	let clr_or_bgc{0} = 'clr'
	let clr_or_bgc{1} = 'bgc'
	" Frame the array for fg and bg
	" Note: Could use a common value for end.
	let arr_beg{0} = 2
	let arr_end{0} = 4
	let arr_beg{1} = 0
	let arr_end{1} = 4
	" Determine arrays that don't apply to fg color
	let skip{0}_{0} = 1
	let skip{0}_{1} = 1
	let skip{0}_{2} = 0
	let skip{0}_{3} = 0
	let skip{0}_{4} = 0
	if b:txtfmt_cfg_bgcolor
		" Determine arrays that don't apply to bg color
		let skip{1}_{0} = 0
		let skip{1}_{1} = 0
		let skip{1}_{2} = 0
		let skip{1}_{3} = 0
		let skip{1}_{4} = 0
	endif
	" Loop over fg and bg color (if applicable)
	let fgbg_idx = 0
	while fgbg_idx < (b:txtfmt_cfg_bgcolor ? 2 : 1)
		let i = 1
		" Loop over all colors (1st non-default color at index 1)
		while i < b:txtfmt_num_colors
			" Init strings to value signifying not specified or error
			let namepat = '' | let clr_rhs = ''
			" Loop over the possible color arrays
			let j = arr_beg{fgbg_idx}
			while j <= arr_end{fgbg_idx}
				" Skip inapplicable arrays
				if skip{fgbg_idx}_{j}
					let j = j + 1
					continue
				endif
				" Skip nonexistent color definitions
				if exists(arrname{j}.'{'.i.'}')
					exe 'let l:el = '.arrname{j}.'{'.i.'}'
					" If here, color definition exists. Let's see whether it contains
					" a match...
					let s = s:Translate_color_optstr(el)
					if s != ''
						" Extract fields from the escaped return string (which is
						" internally generated, and hence, does not require
						" validation)
						" TODO - Perhaps standardize this in one spot (function or
						" static return variables)
						let re_fld = '\%(\%(\\.\|[^,]\)*\)'
						let re_sfld = '\(\%(\\.\|[^,]\)*\)'
						let namepat = substitute(s, re_sfld.'.*', '\1', '')
						if has('gui_running')
							let clr_rhs = substitute(s, re_fld.','.re_fld.','.re_sfld, '\1', '')
						else
							let clr_rhs = substitute(s, re_fld.','.re_sfld.'.*', '\1', '')
						endif
						" Note: clr_rhs may be null at this point; if so, there
						" was no applicable color definition, though the color def
						" element was valid
						if strlen(clr_rhs)
							" Remove extra level of backslashes
							let namepat = substitute(namepat, '\\\(.\)', '\1', 'g')
							let clr_rhs = substitute(clr_rhs, '\\\(.\)', '\1', 'g')
						endif
					elseif arrname{j}[0] == 'b' || arrname{j}[0] == 'g'
						echomsg "Ignoring invalid user-specified color def ".arrname{j}.i." due to error: "
							\.s:err_str
					else
						" Shouldn't get here! Problem with defaults...
						echomsg "Internal error within Process_color_options - bad default for txtfmtColors"
							\.i." - contact developer."
					endif
					" Are we done yet?
					if strlen(clr_rhs)
						break
					endif
				endif
				let j = j + 1
			endwhile
			" Assumption: Lack of color rhs at this point implies internal error.
			" Build the buffer-specific array used in syntax file...
			" Note: In the following 2 arrays, an index of 1 corresponds to the
			" first non-default color.
			let b:txtfmt_{clr_or_bgc{fgbg_idx}}_namepat{i} = namepat
			let b:txtfmt_{clr_or_bgc{fgbg_idx}}{i} = clr_rhs
			" Advance to next color
			let i = i + 1
		endwhile
		let fgbg_idx = fgbg_idx + 1
	endwhile
	" Now that the color configuration is completely determined (and loaded
	" into b:txtfmt_clr{} (and b:txtfmt_bgc{} if applicable)), determine the
	" 'uniqueness index' for this color configuration. The uniqueness index is
	" used to ensure that each color configuration has its own set of syntax
	" groups.
	" TODO_BG: Is the _cfg_ infix appropriate for such variables? For now, I'm
	" using it only for option vars (with one exception that needs looking at)
	let b:txtfmt_color_uniq_idx = s:Get_color_uniq_idx()
endfu
" >>>
" Function: s:Process_txtfmt_modeline() <<<
" Purpose: Determine whether input line is a valid txtfmt modeline. Process
" options if so. If required by s:txtfmt_ml_new_<...> variables, change
" options in the modeline itself. (Example: change 'tokrange' as requested by
" preceding call to :MoveStartTok command.)
" Note: Input line may be either a valid line number or a string representing
" a valid modeline (which is constructed by the caller)
" Return:
" 0		- no txtfmt modeline found
" -1	- txtfmt modeline containing error (bad option)
" 1		- valid txtfmt modeline found and processed
" Note: Modeline format is described under function s:Is_txtfmt_modeline.
fu! s:Process_txtfmt_modeline(line)
	if a:line =~ '^[1-9][0-9]*$'
		" Obtain the line to be processed
		let l:line = a:line
		let linestr = getline(a:line)
	else
		" The line to be processed is not in the buffer
		let l:line = 0
		let linestr = a:line
	endif
	" Is the line a modeline?
	if !s:Is_txtfmt_modeline(linestr)
		" Note: This is not considered error - the line is simply not a
		" modeline
		return 0
	endif
	" If here, overall format is correct. Are all options valid?
	" Assume valid modeline until we find out otherwise...
	let ret_val = 1
	" Save the leading text, in case we need to create a version of the line
	" with changed options (e.g., starttok change)
	let leading = substitute(linestr, s:re_modeline, '\1', '')
	" The middle (options) part will be built up as we go
	let middle = ''
	" Save the trailing stuff
	let trailing = substitute(linestr, s:re_modeline, '\3', '')
	" Extract the {options} portion (leading/trailing stuff removed) for
	" processing
	let optstr = substitute(linestr, s:re_modeline, '\2', '')
	" Extract pieces from head of optstr as long as unprocessed options exist
	" Note: The following pattern may be used to extract element separators
	" into \1, opt name into \2, equal sign (if it exists) into \3, opt value
	" (if it exists) into \4, and to strip all three from the head of the
	" string. (The remainder of the modeline will be in \5.)
	" Note: Element separator is optional in the following re, since it won't
	" exist for first option, and we've already verified that it exists
	" between all other options.
	let re_opt = '\('.s:re_ml_elsep.'\)\?\('
				\.s:re_ml_name.'\)\%(\(=\)\('.s:re_ml_val.'\)\)\?\(.*\)'
	" If this is a real buffer line, do some special processing required only
	" when modeline options are being changed or added
	if l:line > 0
		" Set this flag if we make a requested change to an option, which needs to
		" be reflected in the actual modeline text in the buffer (e.g., starttok
		" change)
		unlet! line_changed
		" If we haven't done so already, save location at which new options can be
		" added.
		if !exists('s:txtfmt_ml_addline')
			let s:txtfmt_ml_addline = l:line
			" Note: The +1 changes 0-based byte index to 1-based col index
			" Note: Saved value represents the col number of the first char to be
			" added
			let s:txtfmt_ml_addcol = matchend(linestr, s:re_ml_start) + 1
		endif
	endif
	" Loop over all options, exiting loop early if error occurs
	while strlen(optstr) > 0 && ret_val != -1
		" Accumulate the option separator text
		let middle = middle.substitute(optstr, re_opt, '\1', '')
		" Extract option name and value
		let optn = substitute(optstr, re_opt, '\2', '')
		let has_eq = '=' == substitute(optstr, re_opt, '\3', '')
		let optv = substitute(optstr, re_opt, '\4', '')
		" Remove the option about to be processed from head of opt str
		let optstr = substitute(optstr, re_opt, '\5', '')
		" IMPORTANT TODO: The following if/else needs major refactoring to
		" avoid duplication. There are ways of doing this that require far
		" less brute-force. I'm saving it for a subsequent release to mitigate
		" testing.
		" Validate the option(s)
		if optn == 'tokrange' || optn == 'rng'
			"format: tokrange=<char_code>[sSlLxX]
			"Examples: '130s' '1500l' '130' '0x2000L'
			if !has_eq
				let s:err_str = "Value required for non-boolean txtfmt option 'tokrange'"
				let b:txtfmt_cfg_tokrange = ''
				let ret_val = -1
			elseif !s:Tokrange_is_valid(optv)
				" 2 cases when option is invalid:
				" 1) We can fix the invalid tokrange by changing to the value
				"    specified by user in call to :MoveStartTok
				" 2) We must display error and use default
				if exists('s:txtfmt_ml_new_starttok')
					" Design Decision: Since option value is not valid, don't
					" attempt to preserve any existing 'formats' specifier
					" Assumption: b:txtfmt_cfg_bgcolor,
					" b:txtfmt_cfg_longformats, and b:txtfmt_cfg_undercurl are
					" unlet *only* at the top of Set_tokrange; thus, we can
					" assume they will be valid here.
					let optv = s:txtfmt_ml_new_starttok
						\.b:txtfmt_const_tokrange_suffix_{b:txtfmt_cfg_bgcolor}{b:txtfmt_cfg_longformats}{b:txtfmt_cfg_undercurl}
					" Record fact that change was made
					unlet s:txtfmt_ml_new_starttok
					let line_changed = 1
				else
					let s:err_str = "Invalid 'tokrange' value - must be hex or dec"
								\." char code value optionally followed by one of [sSlLxX]"
					" Note: 'XL' suffix is currently illegal, but give a special
					" warning if user attempts to use it.
					if optv =~? 'xl$'
						let s:err_str = s:err_str
							\." (The XL suffix is currently illegal, due to a memory resource limitation"
							\." affecting current versions of Vim; this suffix may, however, be supported in"
							\." a future release.)"
					endif
					" Record the attempt to set b:txtfmt_cfg_tokrange from modeline
					let b:txtfmt_cfg_tokrange = ''
					let ret_val = -1
				endif
			else
				if exists('s:txtfmt_ml_new_starttok')
					" Change the starttok value, preserving both the starttok
					" number format (note that s:txtfmt_ml_new_starttok is
					" actually a string) and any existing 'formats'
					" specification
					" Note: Since modeline setting trumps all others, an
					" existing setting should agree with current setting
					" anyway.
					let optv = substitute(optv, b:txtfmt_re_number_atom, s:txtfmt_ml_new_starttok, '')
					" Record fact that change was made
					unlet s:txtfmt_ml_new_starttok
					let line_changed = 1
				endif
				" Save the option value, deferring processing till later...
				let b:txtfmt_cfg_tokrange = optv
			endif
		elseif optn == 'fgcolormask' || optn == 'fcm'
			if !has_eq
				let s:err_str = "Value required for non-boolean txtfmt option 'fgcolormask'"
				let b:txtfmt_cfg_fgcolormask = ''
				let ret_val = -1
			elseif !s:Clrmask_is_valid(optv)
				" Invalid number of colors
				let s:err_str = "Invalid foreground color mask - must be string of 8 ones and zeroes"
				let b:txtfmt_cfg_fgcolormask = ''
				let ret_val = -1
			else
				let b:txtfmt_cfg_fgcolormask = optv
			endif
		elseif optn == 'bgcolormask' || optn == 'bcm'
			if !has_eq
				let s:err_str = "Value required for non-boolean txtfmt option 'bgcolormask'"
				let b:txtfmt_cfg_bgcolormask = ''
				let ret_val = -1
			elseif !s:Clrmask_is_valid(optv)
				" Invalid number of colors
				let s:err_str = "Invalid background color mask - must be string of 8 ones and zeroes"
				let b:txtfmt_cfg_bgcolormask = ''
				let ret_val = -1
			else
				let b:txtfmt_cfg_bgcolormask = optv
			endif
		elseif optn == 'sync'
			"format: sync={<hex>|<dec>|fromstart|none}
			"Examples: 'sync=300' 'sync=0x1000' 'sync=fromstart' 'sync=none'
			if !has_eq
				let s:err_str = "Value required for non-boolean txtfmt option 'sync'"
				let b:txtfmt_cfg_sync = ''
				let ret_val = -1
			elseif !s:Sync_is_valid(optv)
				let s:err_str = "Invalid 'sync' value - must be one of the"
							\." following: <numeric literal>, 'fromstart'"
							\.", 'none'"
				" Record the attempt to set b:txtfmt_cfg_sync from modeline
				let b:txtfmt_cfg_sync = ''
				let ret_val = -1
			else
				" Defer processing of sync till later
				let b:txtfmt_cfg_sync = optv
			endif
		elseif optn =~ '^\(no\)\?\(pack\|pck\)$'
			" Make sure no option value was supplied to binary option
			if has_eq
				let s:err_str = "Cannot assign value to boolean txtfmt option 'pack'"
				let b:txtfmt_cfg_pack = ''
				let ret_val = -1
			else
				" Option has been explicitly turned on or off
				let b:txtfmt_cfg_pack = optn =~ '^no' ? 0 : 1
			endif
		elseif optn =~ '^\(no\)\?\(undercurl\|uc\)$'
			" Make sure no option value was supplied to binary option
			if has_eq
				let s:err_str = "Cannot assign value to boolean txtfmt option 'undercurl'"
				let b:txtfmt_cfg_undercurlpref = ''
				let ret_val = -1
			else
				" Option has been explicitly turned on or off
				let b:txtfmt_cfg_undercurlpref = optn =~ '^no' ? 0 : 1
			endif
		elseif optn =~ '^\(no\)\?\(nested\|nst\)$'
			" Make sure no option value was supplied to binary option
			if has_eq
				let s:err_str = "Cannot assign value to boolean txtfmt option 'nested'"
				let b:txtfmt_cfg_nested = ''
				let ret_val = -1
			else
				" Option has been explicitly turned on or off
				let b:txtfmt_cfg_nested = optn =~ '^no' ? 0 : 1
			endif
		elseif optn =~ '^\(no\)\?\(conceal\|cncl\)$'
			" Make sure no option value was supplied to binary option
			if has_eq
				let s:err_str = "Cannot assign value to boolean txtfmt option 'conceal'"
				let b:txtfmt_cfg_conceal = ''
				let ret_val = -1
			else
				" Option has been explicitly turned on or off
				let b:txtfmt_cfg_conceal = optn =~ '^no' || !has('conceal') ? 0 : 1
			endif
		elseif optn == 'concealcursor' || optn == 'cocu'
			" format: cocu=[n][v][i][c]
			if !has_eq
				let s:err_str = "Value required for non-boolean txtfmt option 'concealcursor'"
				let b:txtfmt_cfg_concealcursor_invalid = 1
				let ret_val = -1
			elseif !s:Concealcursor_is_valid(optv)
				let s:err_str = "Invalid 'concealcursor' option: `" . optv
					\ . "' - only the following flags are permitted: nvic"
				" Note: This one is different from the others: empty string is
				" valid option value, so we can't use null string to indicate
				" error
				let b:txtfmt_cfg_concealcursor_invalid = 1
				let ret_val = -1
			else
				" Option has been explicitly set
				" Vim Issue: With 'concealcursor', duplicate flags aren't
				" removed as they are for other such options (and as
				" documentation indicates they should be).
				" Note: Intentially skipping check for duplicates since
				" they're harmless.
				let b:txtfmt_cfg_concealcursor = optv
			endif
		elseif optn == 'escape' || optn == 'esc'
			"format: escape=[bslash|self|none]
			"TODO: Perhaps use s:Escape_is_valid() for validation
			if !has_eq
				let s:err_str = "Value required for non-boolean txtfmt option 'escape'"
				let b:txtfmt_cfg_escape = ''
				let ret_val = -1
			elseif optv == 'bslash'
				let b:txtfmt_cfg_escape = 'bslash'
			elseif optv == 'self'
				let b:txtfmt_cfg_escape = 'self'
			elseif optv == 'none'
				let b:txtfmt_cfg_escape = 'none'
			else
				let s:err_str = "Invalid 'escape' value - must be 'bslash', 'self', or 'none'"
				let b:txtfmt_cfg_escape = ''
				let ret_val = -1
			endif
		else
		   let s:err_str = "Unknown txtfmt modeline option: ".optn
		   let ret_val = -1
		endif
		" Append optn[=optv] to middle
		let middle = middle . optn . (has_eq ? '=' . optv : '')
	endwhile
	" Processed txtfmt modeline without error
	if l:line > 0 && exists('line_changed')
		" Alter the line to reflect any option changes
		" Note: If error occurred above, optstr may be non-empty, in which
		" case, we need to append it to the already processed options in
		" middle.
		call setline(l:line, leading.middle.optstr.trailing)
	endif
	return ret_val
endfu
" >>>
" Function: s:Do_txtfmt_modeline() <<<
" Purpose: Look for txtfmt "modelines" of the following form:
" .\{-}<whitespace>txtfmt:<definitions>:
" which appear within the first or last 'modelines' lines in the buffer.
" Note: Function will search a number of lines (at start and end of buffer),
" as determined from 'modelines', provided that this value is nonzero. If
" 'modelines' is 0, default of 5 lines at beginning and end will be searched.
" Return:
" 0     - no txtfmt modeline found
" N     - N valid txtfmt modelines found and processed
" -N    - txtfmt modeline processing error occurred on the Nth modeline
"         processed
" Error_handling: If error is encountered in a modeline, the remainder of
" the offending modeline is discarded, and modeline processing is aborted;
" i.e., no more lines are searched. This is consistent with the way Vim's
" modeline processing works.
" Modeline_modifications: The following buf-local variables are considered to
" be inputs that request changes to existing modelines:
" b:txtfmt_ml_new_starttok
" ...
" If the requested change can't be made, we will attempt to add the requested
" setting to an existing modeline. If there are no existing modelines, we will
" add a new one (warning user if he has modeline processing turned off). If
" modifications are made to the buffer, we will use b:txtfmt_ml_save_modified
" to determine whether the buffer was in a modified state prior to our
" changes, and will save our changes if and only if doing so doesn't commit
" any unsaved user changes.
" Assumption: Another Txtfmt function sets b:txtfmt_ml_save_modified
" appropriately before the Txtfmt-initiated changes begin.
fu! s:Do_txtfmt_modeline()
	" Check for request to change starttok
	if exists('b:txtfmt_ml_new_starttok')
		" Communicate the request to modeline processing function.
		let s:txtfmt_ml_new_starttok = b:txtfmt_ml_new_starttok
		" Unlet the original to ensure that if we abort with error, we don't
		" do this next time
		unlet! b:txtfmt_ml_new_starttok
	else
		" Clean up after any previous failed attempts
		unlet! s:txtfmt_ml_new_starttok
	endif
	" Did someone anticipate that we might be modifying the buffer?
	if exists('b:txtfmt_ml_save_modified')
		let l:save_modified = b:txtfmt_ml_save_modified
		unlet b:txtfmt_ml_save_modified
	endif
	" The following apply to any option change request. They're set within
	" Process_txtfmt_modeline the first time a suitable add location is found
	unlet! s:txtfmt_ml_addline
	unlet! s:txtfmt_ml_addcol

	" Keep up with # of modelines actually encountered
	let l:ml_seen = 0
	" How many lines should we search?
	" Priority is given to txtfmtModelines user option if it exists
	if exists('b:txtfmtModelines') || exists('g:txtfmtModelines')
		" User can disable by setting to 0
		let mls_use = exists('b:txtfmtModelines') ? b:txtfmtModelines : g:txtfmtModelines
	else
		" Use 'modelines' option+1 unless it's not a valid nonzero value, in
		" which case, we use default of 5
		" NOTE: 1 is added to 'modelines' option so that if modeline is at
		" highest or lowest possible line, putting a txtfmt modeline above or
		" below it, respectively, will work.
		let mls_use = &modelines > 0 ? &modelines+1 : 5
	endif
	let nlines = line('$')
	" Check first modelines lines
	" TODO - Combine the 2 loops into one, which can alter the loop counter in
	" a stepwise manner.
	let i = 1
	while i <= mls_use && i <= nlines
		let status = s:Process_txtfmt_modeline(i)
		if status == 1
			 " Successfully extracted options
			 let l:ml_seen = l:ml_seen + 1
		elseif status == -1
			 " Error processing the modeline
			 echoerr "Ignoring txtfmt modeline on line ".i.": ".s:err_str
			 return -(l:ml_seen + 1)
		endif
		" Keep looking...
		let i = i + 1
	endwhile
	" Check last modelines lines
	let i = nlines - mls_use + 1
	" Adjust if necessary to keep from checking already checked lines
	if i <= mls_use
		let i = mls_use + 1
	endif
	while i <= nlines
		let status = s:Process_txtfmt_modeline(i)
		if status == 1
			 " Successfully extracted options
			 let l:ml_seen = l:ml_seen + 1
		elseif status == -1
			 " Error processing the modeline
			 echoerr "Ignoring txtfmt modeline on line ".i.": ".s:err_str
			 return -(l:ml_seen + 1)
		endif
		" Keep looking...
		let i = i + 1
	endwhile
	" Deal with any unprocessed requests for modeline option changes
	" Note: Process_txtfmt_modeline unlets s:txtfmt_ml_new_<...> vars that
	" have been completely handled.
	let l:ml_new_opts = ''
	if exists('s:txtfmt_ml_new_starttok')
		" TODO: Decide whether it matters that this strategy will put a
		" useless space at end of modeline in the unlikely event that the
		" original modeline contained no options
		" Assumption: b:txtfmt_cfg_bgcolor, b:txtfmt_cfg_longformats, and
		" b:txtfmt_cfg_undercurl are unlet *only* at the top of Set_tokrange;
		" thus, we can assume they will be valid here.
		let l:ml_new_opts = l:ml_new_opts
			\.'tokrange='
			\.s:txtfmt_ml_new_starttok
			\.b:txtfmt_const_tokrange_suffix_{b:txtfmt_cfg_bgcolor}{b:txtfmt_cfg_longformats}{b:txtfmt_cfg_undercurl}
			\.' '
	endif
	" Any additional requests would go here
	" ...
	" Do we have any options to add?
	if strlen(l:ml_new_opts)
		" Create the modeline that will be passed to Process_txtfmt_modeline
		let l:ml_process = "\<Tab>txtfmt:".l:ml_new_opts
		" Add what needs to be added to the buffer
		if exists('s:txtfmt_ml_addline')
			" Add new options to existing modeline
			let linestr = getline(s:txtfmt_ml_addline)
			" Recreate the line
			call setline(s:txtfmt_ml_addline,
				\ strpart(linestr, 0, s:txtfmt_ml_addcol - 1)
				\ . l:ml_new_opts
				\ . strpart(linestr, s:txtfmt_ml_addcol - 1))
		else
			" Create a new txtfmt modeline on first line. Note that it's the
			" same as what will be passed to Process_txtfmt_modeline for
			" processing.
			call append(0, l:ml_process)
			if mls_use == 0
				" Warn user that he should change his modelines setting
				" TODO_BG: Figure out how to prevent the warning from
				" disappearing after a second or two.
				echomsg "Warning: Txtfmt has added option settings to a modeline at the beginning"
					\." of the buffer, but your modeline setting is such that this modeline"
					\." will be ignored next time the buffer is opened."
					\." (:help txtfmtModelines)"
			endif
			" Record fact that we've processed another modeline
			let l:ml_seen = l:ml_seen + 1
		endif
		" Process only the options just added
		let status = s:Process_txtfmt_modeline(l:ml_process)
		" Note: Error should be impossible here, but just in case...
		if status < 0
			echoerr "Internal error: Unexpected error while processing txtfmt-generated modeline: ".s:err_str.". Contact the developer"
			return -(l:ml_seen)
		elseif status == 0
			echoerr "Internal error: Failed to extract option(s) while processing txtfmt-generated modeline. Contact the developer"
			return -(l:ml_seen)
		endif
	endif
	" If modeline processing made an unmodified buffer modified, save our
	" changes now. (Rationale: Leave the buffer in the state it was in prior
	" to modeline processing. This avoids making user's unsaved changes
	" permanent.)
	if exists('l:save_modified') && !l:save_modified && &modified
		write
	endif
	" If here, we encountered no error. Return the number of modelines
	" processed (could be zero)
	return l:ml_seen
endfu
" >>>
" Function: s:Process_clr_masks() <<<
" Inputs:
" b:txtfmt_cfg_fgcolormask
" b:txtfmt_cfg_bgcolormask
" Description: Each mask is a string of 8 chars, each of which must be either
" '0' or '1'
" Outputs:
" b:txtfmt_cfg_fgcolor{} b:txtfmt_cfg_numfgcolors
" b:txtfmt_cfg_bgcolor{} b:txtfmt_cfg_numbgcolors
" Description: The <fg|bg>color arrays are 1-based indirection arrays, which
" contain a single element for each of the active colors. The elements of
" these arrays are the 1-based indices of the corresponding color in the
" actual color definition array (which always contains 8 elements).
" Note: num<fg|bg>colors will be 0 and corresponding array will be empty if
" there are no 1's in the <fg|bg>colormask
" Note: If 'tokrange' setting precludes background colors, the bg colormask
" option will be all 0's at this point, regardless of how user has configured
" the option.
fu! s:Process_clr_masks()
	" Loop over fg and bg
	let fgbg_idx = 0
	let fg_or_bg{0} = 'fg'
	let fg_or_bg{1} = 'bg'
	while fgbg_idx < 2
		" Cache the mask to be processed
		let mask = b:txtfmt_cfg_{fg_or_bg{fgbg_idx}}colormask
		" Note: To be on the safe side, I'm going to zero the bg color mask
		" whenever bg colors are disabled, just in case caller forgot.
		if fg_or_bg{fgbg_idx} == 'bg' && !b:txtfmt_cfg_bgcolor && mask =~ '1'
			let mask = '00000000'
		endif
		" Loop over all 8 'bits' in the mask
		" Assumption: The mask length has already been validated
		" Note: All color arrays processed are 1-based (since index 0, if it
		" exists, corresponds to 'no color'), but mask bit 'array' is
		" inherently 0-based (because it's a string)
		let i = 0
		let iadd = 0
		while i < 8
			if mask[i] == '1'
				" Append this color's (1-based) index to active color array
				" (which is also 1-based)
				let iadd = iadd + 1
				let b:txtfmt_cfg_{fg_or_bg{fgbg_idx}}color{iadd} = i + 1
			endif
			let i = i + 1
		endwhile
		" Store number of active colors
		let b:txtfmt_cfg_num{fg_or_bg{fgbg_idx}}colors = iadd
		" Prepare for next iteration
		let fgbg_idx = fgbg_idx + 1
	endwhile
endfu
" >>>
" Function: s:Define_fmtclr_vars() <<<
fu! s:Define_fmtclr_vars()
	" Format definition array <<<
	" NOTE: This array is used for rhs of syntax definitions, but also for display
	" by ShowTokenMap.
	let b:txtfmt_fmt{0}  = 'NONE'
	let b:txtfmt_fmt{1}  = 'underline'
	let b:txtfmt_fmt{2}  = 'bold'
	let b:txtfmt_fmt{3}  = 'underline,bold'
	let b:txtfmt_fmt{4}  = 'italic'
	let b:txtfmt_fmt{5}  = 'underline,italic'
	let b:txtfmt_fmt{6}  = 'bold,italic'
	let b:txtfmt_fmt{7}  = 'underline,bold,italic'
	if !b:txtfmt_cfg_longformats
		" short formats
		let b:txtfmt_num_formats = 8
	else
		" long formats
		let b:txtfmt_fmt{8}  = 'standout'
		let b:txtfmt_fmt{9}  = 'underline,standout'
		let b:txtfmt_fmt{10} = 'bold,standout'
		let b:txtfmt_fmt{11} = 'underline,bold,standout'
		let b:txtfmt_fmt{12} = 'italic,standout'
		let b:txtfmt_fmt{13} = 'underline,italic,standout'
		let b:txtfmt_fmt{14} = 'bold,italic,standout'
		let b:txtfmt_fmt{15} = 'underline,bold,italic,standout'
		let b:txtfmt_fmt{16} = 'reverse'
		let b:txtfmt_fmt{17} = 'underline,reverse'
		let b:txtfmt_fmt{18} = 'bold,reverse'
		let b:txtfmt_fmt{19} = 'underline,bold,reverse'
		let b:txtfmt_fmt{20} = 'italic,reverse'
		let b:txtfmt_fmt{21} = 'underline,italic,reverse'
		let b:txtfmt_fmt{22} = 'bold,italic,reverse'
		let b:txtfmt_fmt{23} = 'underline,bold,italic,reverse'
		let b:txtfmt_fmt{24} = 'standout,reverse'
		let b:txtfmt_fmt{25} = 'underline,standout,reverse'
		let b:txtfmt_fmt{26} = 'bold,standout,reverse'
		let b:txtfmt_fmt{27} = 'underline,bold,standout,reverse'
		let b:txtfmt_fmt{28} = 'italic,standout,reverse'
		let b:txtfmt_fmt{29} = 'underline,italic,standout,reverse'
		let b:txtfmt_fmt{30} = 'bold,italic,standout,reverse'
		let b:txtfmt_fmt{31} = 'underline,bold,italic,standout,reverse'
		" If using undercurl (introduced in Vim 7.0), there will be twice as
		" many formats.
		if !b:txtfmt_cfg_undercurl
			let b:txtfmt_num_formats = 32
		else
			let b:txtfmt_fmt{32} = 'undercurl'
			let b:txtfmt_fmt{33} = 'underline,undercurl'
			let b:txtfmt_fmt{34} = 'bold,undercurl'
			let b:txtfmt_fmt{35} = 'underline,bold,undercurl'
			let b:txtfmt_fmt{36} = 'italic,undercurl'
			let b:txtfmt_fmt{37} = 'underline,italic,undercurl'
			let b:txtfmt_fmt{38} = 'bold,italic,undercurl'
			let b:txtfmt_fmt{39} = 'underline,bold,italic,undercurl'
			let b:txtfmt_fmt{40} = 'standout,undercurl'
			let b:txtfmt_fmt{41} = 'underline,standout,undercurl'
			let b:txtfmt_fmt{42} = 'bold,standout,undercurl'
			let b:txtfmt_fmt{43} = 'underline,bold,standout,undercurl'
			let b:txtfmt_fmt{44} = 'italic,standout,undercurl'
			let b:txtfmt_fmt{45} = 'underline,italic,standout,undercurl'
			let b:txtfmt_fmt{46} = 'bold,italic,standout,undercurl'
			let b:txtfmt_fmt{47} = 'underline,bold,italic,standout,undercurl'
			let b:txtfmt_fmt{48} = 'reverse,undercurl'
			let b:txtfmt_fmt{49} = 'underline,reverse,undercurl'
			let b:txtfmt_fmt{50} = 'bold,reverse,undercurl'
			let b:txtfmt_fmt{51} = 'underline,bold,reverse,undercurl'
			let b:txtfmt_fmt{52} = 'italic,reverse,undercurl'
			let b:txtfmt_fmt{53} = 'underline,italic,reverse,undercurl'
			let b:txtfmt_fmt{54} = 'bold,italic,reverse,undercurl'
			let b:txtfmt_fmt{55} = 'underline,bold,italic,reverse,undercurl'
			let b:txtfmt_fmt{56} = 'standout,reverse,undercurl'
			let b:txtfmt_fmt{57} = 'underline,standout,reverse,undercurl'
			let b:txtfmt_fmt{58} = 'bold,standout,reverse,undercurl'
			let b:txtfmt_fmt{59} = 'underline,bold,standout,reverse,undercurl'
			let b:txtfmt_fmt{60} = 'italic,standout,reverse,undercurl'
			let b:txtfmt_fmt{61} = 'underline,italic,standout,reverse,undercurl'
			let b:txtfmt_fmt{62} = 'bold,italic,standout,reverse,undercurl'
			let b:txtfmt_fmt{63} = 'underline,bold,italic,standout,reverse,undercurl'
			let b:txtfmt_num_formats = 64
		endif
	endif
	" >>>
	" <<< Default color definition array
	" These are the original defaults
	let s:txtfmt_clr{1} = '^\\%(k\\|bla\\%[ck]\\)$,c:Black,g:#000000'
	let s:txtfmt_clr{2} = '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
	let s:txtfmt_clr{3} = '^g\\%[reen]$,c:DarkGreen,g:#00FF00'
	let s:txtfmt_clr{4} = '^t\\%[urquoise]$,c:DarkCyan,g:#00FFFF'
	let s:txtfmt_clr{5} = '^r\\%[ed]$,c:DarkRed,g:#FF0000'
	let s:txtfmt_clr{6} = '^v\\%[iolet]$,c:DarkMagenta,g:#FF00FF'
	let s:txtfmt_clr{7} = '^y\\%[ellow]$,c:DarkYellow,g:#FFFF00'
	let s:txtfmt_clr{8} = '^w\\%[hite]$,c:White,g:#FFFFFF'
	" Note: The following variable indicates the total number of colors
	" possible, including 'no color', which is not in the txtfmt_clr array.
	" TODO: See how this is used to see how to use numfgcolors and numbgcolors...
	let b:txtfmt_num_colors = 9
	" >>>
	" Set fmt/clr specific values for convenience
	" txtfmt_<rgn>_first_tok:      1st (default) token
	" txtfmt_<rgn>_last_tok:       last (reserved) token
	" txtfmt_last_tok:             last token that could be used (if
	"                              txtfmt_cfg_numbgcolors is applicable,
	"                              assumes it to be 8)
	" TODO NOTE - If desired, could allow the fmt/clr ranges to be split, in
	" which case, the following 2 would be user-configurable. For now, just
	" base them on txtfmtStarttok.
	" TODO: Decide whether to keep this here or move outside this function
	call s:Process_clr_masks()
	" Save some useful char codes
	let b:txtfmt_clr_first_tok = b:txtfmt_cfg_starttok
	let b:txtfmt_clr_last_tok = b:txtfmt_cfg_starttok + b:txtfmt_num_colors - 1
	let b:txtfmt_fmt_first_tok = b:txtfmt_clr_last_tok + 1
	let b:txtfmt_fmt_last_tok = b:txtfmt_fmt_first_tok + b:txtfmt_num_formats - 1
	if b:txtfmt_cfg_bgcolor
		" Location of bg color range depends upon 'pack' setting as well
		" as well as type of formats in effect
		" Note: Intentionally hardcoding bgcolor index to 0 and undercurl
		" index to 1 (when formats are long) to get desired length
		" TODO: Replace ternaries with normal if block
		let b:txtfmt_bgc_first_tok = b:txtfmt_cfg_starttok +
			\ b:txtfmt_const_tokrange_size_{0}{
				\(b:txtfmt_cfg_longformats || !b:txtfmt_cfg_pack ? 1 : 0)}{
				\(b:txtfmt_cfg_longformats || !b:txtfmt_cfg_pack ? 1 : 0)}
		let b:txtfmt_bgc_last_tok = b:txtfmt_bgc_first_tok + b:txtfmt_num_colors - 1
		let b:txtfmt_last_tok = b:txtfmt_bgc_last_tok
	else
		" nothing after the fmt range
		let b:txtfmt_bgc_first_tok = -1
		let b:txtfmt_bgc_last_tok = -1
		let b:txtfmt_last_tok = b:txtfmt_fmt_last_tok
	endif
endfu
" >>>
" Function: s:Define_fmtclr_regexes() <<<
" Purpose: Define regexes involving the special fmt/clr tokens.
" Assumption: The following variable(s) has been defined for the buffer:
" b:txtfmt_cfg_starttok
" Note: The start tok is user-configurable. Thus, this function should be
" called only after processing options.
fu! s:Define_fmtclr_regexes()
	" Cache bgc enabled flag for subsequent tests
	let bgc = b:txtfmt_cfg_bgcolor && b:txtfmt_cfg_numbgcolors > 0
	let clr = b:txtfmt_cfg_numfgcolors > 0
	" 0 1 3 4 5 7 8
	"   1 3 4 5 7 8
	let fgbg_idx = 0
	let clr_or_bgc{0} = 'clr' | let fg_or_bg{0} = 'fg'
	let clr_or_bgc{1} = 'bgc' | let fg_or_bg{1} = 'bg'
	while fgbg_idx < 2
		if b:txtfmt_cfg_num{fg_or_bg{fgbg_idx}}colors
			" Note: Handle first active color here, outside the loop. To handle it
			" inside the loop, I would need to initialize tok_cnt to 0 and tok_i
			" to -1 and handle tok_i == -1 specially within the loop. (tok_i == -1
			" indicates that we don't have the potential beginning of a range)
			let tok_i = b:txtfmt_cfg_{fg_or_bg{fgbg_idx}}color{1}
			let tok_cnt = 1
			let i = 2 " first active color already accounted for
			" Initialize regex string to be built within loop
			let b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_stok_atom = ''
			" Loop over active colors (and one fictitious element past end of
			" array). Note that first active color was handled in initializations.
			while i <= b:txtfmt_cfg_num{fg_or_bg{fgbg_idx}}colors + 1
				" We know something is ending (atom or range) if any of the
				" following conditions is true:
				" -We're on the non-existent element one past end of active color
				"  array
				" -The current active color index is not 1 greater than the last
				" TODO_BG: Can't compare with tok_i + 1 since tok_i isn't
				" updated through range.
				if i >= b:txtfmt_cfg_num{fg_or_bg{fgbg_idx}}colors + 1 || (b:txtfmt_cfg_{fg_or_bg{fgbg_idx}}color{i} != tok_i + tok_cnt)
					" Something is ending
					if tok_cnt > 1
						" Append range if more than 2 chars; otherwise, make
						" it a double atom.
						let b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_stok_atom = b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_stok_atom
							\.nr2char(b:txtfmt_{clr_or_bgc{fgbg_idx}}_first_tok + tok_i)
							\.(tok_cnt > 2 ? '-' : '')
							\.nr2char(b:txtfmt_{clr_or_bgc{fgbg_idx}}_first_tok + tok_i + tok_cnt - 1)
					else
						" Append atom
						let b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_stok_atom = b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_stok_atom
							\.nr2char(b:txtfmt_{clr_or_bgc{fgbg_idx}}_first_tok + tok_i)
					endif
					" Start something new unless at end
					if i <= b:txtfmt_cfg_num{fg_or_bg{fgbg_idx}}colors
						let tok_cnt = 1
						let tok_i = b:txtfmt_cfg_{fg_or_bg{fgbg_idx}}color{i}
					endif
				else
					" Nothing is ending - record continuation
					let tok_cnt = tok_cnt + 1
				endif
				let i = i + 1
			endwhile
			" Create the _tok_ version from the _stok_ version by prepending
			" default (end) token
			" Decision Needed: Do I want to create tok this way, or would it be
			" better to gain a slight bit of highlighting efficiency in some cases
			" by putting the default tok into a range if possible.
			" Note: I'm leaning against this optimization. Consider that it would
			" be possible only for color configurations in which the first color
			" is active; hence, if there were any speed difference in the
			" highlighting (and a significant one is doubtful in my opinion), it
			" would depend upon the specific color masks, which seems inconsistent
			" and therefore inappropriate.
			let b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_tok_atom =
				\ nr2char(b:txtfmt_{clr_or_bgc{fgbg_idx}}_first_tok)
				\ . b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_stok_atom
			let b:txtfmt_re_{clr_or_bgc{fgbg_idx}}_etok_atom =
				\ nr2char(b:txtfmt_{clr_or_bgc{fgbg_idx}}_first_tok)
		endif
		let fgbg_idx = fgbg_idx + 1
	endwhile
	" Format region tokens
	let b:txtfmt_re_fmt_tok_atom = nr2char(b:txtfmt_fmt_first_tok).'-'.nr2char(b:txtfmt_fmt_last_tok)
	let b:txtfmt_re_fmt_stok_atom = nr2char(b:txtfmt_fmt_first_tok + 1).'-'.nr2char(b:txtfmt_fmt_last_tok)
	let b:txtfmt_re_fmt_etok_atom = nr2char(b:txtfmt_fmt_first_tok)
	" Color regions that include inactive colors
	if clr
		let b:txtfmt_re_CLR_tok_atom = nr2char(b:txtfmt_clr_first_tok).'-'.nr2char(b:txtfmt_clr_last_tok)
		let b:txtfmt_re_CLR_stok_atom = nr2char(b:txtfmt_clr_first_tok + 1).'-'.nr2char(b:txtfmt_clr_last_tok)
		let b:txtfmt_re_CLR_etok_atom = nr2char(b:txtfmt_clr_first_tok)
	endif
	if bgc
		let b:txtfmt_re_BGC_tok_atom = nr2char(b:txtfmt_bgc_first_tok).'-'.nr2char(b:txtfmt_bgc_last_tok)
		let b:txtfmt_re_BGC_stok_atom = nr2char(b:txtfmt_bgc_first_tok + 1).'-'.nr2char(b:txtfmt_bgc_last_tok)
		let b:txtfmt_re_BGC_etok_atom = nr2char(b:txtfmt_bgc_first_tok)
	endif
	" Combined regions
	let b:txtfmt_re_any_tok_atom =
				\(clr ? b:txtfmt_re_clr_tok_atom : '')
				\.nr2char(b:txtfmt_fmt_first_tok).'-'.nr2char(b:txtfmt_fmt_last_tok)
				\.(bgc ? b:txtfmt_re_bgc_tok_atom : '')
	" TODO: Perhaps get rid of dependence upon b:txtfmt_clr_last_tok?
	" TODO: Refactor to use newly-created CLR and BGC atoms
	let b:txtfmt_re_ANY_tok_atom =
				\(clr ? nr2char(b:txtfmt_clr_first_tok).'-'.nr2char(b:txtfmt_clr_last_tok) : '')
				\.nr2char(b:txtfmt_fmt_first_tok).'-'.nr2char(b:txtfmt_fmt_last_tok)
				\.(bgc ? nr2char(b:txtfmt_bgc_first_tok).'-'.nr2char(b:txtfmt_bgc_last_tok) : '')
	let b:txtfmt_re_any_stok_atom =
				\(clr ? b:txtfmt_re_clr_stok_atom : '')
				\.nr2char(b:txtfmt_fmt_first_tok + 1).'-'.nr2char(b:txtfmt_fmt_last_tok)
				\.(bgc ? b:txtfmt_re_bgc_stok_atom : '')
	let b:txtfmt_re_any_etok_atom =
				\(clr ? b:txtfmt_re_clr_etok_atom : '')
				\.b:txtfmt_re_fmt_etok_atom
				\.(bgc ? b:txtfmt_re_bgc_etok_atom : '')

	if b:txtfmt_cfg_escape == 'bslash'
		" The following pattern is a zero-width look-behind assertion, which
		" matches only at a non-backslash-escaped position.
		let noesc = '\%(\%(^\|[^\\]\)\%(\\\\\)*\\\)\@<!'
		" Make this persistent, as it's used elsewhere...
		let b:re_no_bslash_esc = noesc
		" clr
		if clr
			" Active clr only
			let b:txtfmt_re_clr_tok = noesc.'['.b:txtfmt_re_clr_tok_atom.']'
			let b:txtfmt_re_clr_stok = noesc.'['.b:txtfmt_re_clr_stok_atom.']'
			let b:txtfmt_re_clr_etok = noesc.b:txtfmt_re_clr_etok_atom
			let b:txtfmt_re_clr_ntok = '\%('.b:txtfmt_re_clr_tok.'\)\@!.'
			" Active and inactive clr
			let b:txtfmt_re_CLR_tok = noesc.'['.b:txtfmt_re_CLR_tok_atom.']'
			let b:txtfmt_re_CLR_stok = noesc.'['.b:txtfmt_re_CLR_stok_atom.']'
			let b:txtfmt_re_CLR_etok = noesc.b:txtfmt_re_CLR_etok_atom
			let b:txtfmt_re_CLR_ntok = '\%('.b:txtfmt_re_CLR_tok.'\)\@!.'
		endif
		" bgc
		if bgc
			" Active bgc only
			let b:txtfmt_re_bgc_tok = noesc.'['.b:txtfmt_re_bgc_tok_atom.']'
			let b:txtfmt_re_bgc_stok = noesc.'['.b:txtfmt_re_bgc_stok_atom.']'
			let b:txtfmt_re_bgc_etok = noesc.b:txtfmt_re_bgc_etok_atom
			let b:txtfmt_re_bgc_ntok = '\%('.b:txtfmt_re_bgc_tok.'\)\@!.'
			" Active and inactive bgc
			let b:txtfmt_re_BGC_tok = noesc.'['.b:txtfmt_re_BGC_tok_atom.']'
			let b:txtfmt_re_BGC_stok = noesc.'['.b:txtfmt_re_BGC_stok_atom.']'
			let b:txtfmt_re_BGC_etok = noesc.b:txtfmt_re_BGC_etok_atom
			let b:txtfmt_re_BGC_ntok = '\%('.b:txtfmt_re_BGC_tok.'\)\@!.'
		endif
		" fmt
		let b:txtfmt_re_fmt_tok = noesc.'['.b:txtfmt_re_fmt_tok_atom.']'
		let b:txtfmt_re_fmt_stok = noesc.'['.b:txtfmt_re_fmt_stok_atom.']'
		let b:txtfmt_re_fmt_etok = noesc.b:txtfmt_re_fmt_etok_atom
		let b:txtfmt_re_fmt_ntok = '\%('.b:txtfmt_re_fmt_tok.'\)\@!.'
		" clr/bgc/fmt combined
		let b:txtfmt_re_any_tok = noesc.'['.b:txtfmt_re_any_tok_atom.']'
		let b:txtfmt_re_ANY_tok = noesc.'['.b:txtfmt_re_ANY_tok_atom.']'
		let b:txtfmt_re_any_stok = noesc.'['.b:txtfmt_re_any_stok_atom.']'
		let b:txtfmt_re_any_etok =
					\ noesc.'['
						\ . (clr ? b:txtfmt_re_clr_etok_atom : '')
						\ . (bgc ? b:txtfmt_re_bgc_etok_atom : '')
						\ . b:txtfmt_re_fmt_etok_atom
					\ . ']'
		let b:txtfmt_re_any_ntok = '\%('.b:txtfmt_re_any_tok.'\)\@!.'
	elseif b:txtfmt_cfg_escape == 'self'
		" The following pattern serves as the template for finding tokens that
		" are neither escaping nor escaped.
		let tmpl = '\%(\(placeholder\)\%(\1\)\@!\)\@=\%(\%(^\|\%(\1\)\@!.\)\%(\1\1\)*\1\)\@<!.'
		" Make this persistent, as it's used elsewhere...
		let b:re_no_self_esc = tmpl
		" clr
		if clr
			" Active clr only
			let b:txtfmt_re_clr_tok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_clr_tok_atom.']', '')
			let b:txtfmt_re_clr_stok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_clr_stok_atom.']', '')
			let b:txtfmt_re_clr_etok = substitute(tmpl, 'placeholder', b:txtfmt_re_clr_etok_atom, '')
			let b:txtfmt_re_clr_ntok = '\%('.b:txtfmt_re_clr_tok.'\)\@!.'
			" Active and inactive clr
			let b:txtfmt_re_CLR_tok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_CLR_tok_atom.']', '')
			let b:txtfmt_re_CLR_stok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_CLR_stok_atom.']', '')
			let b:txtfmt_re_CLR_etok = substitute(tmpl, 'placeholder', b:txtfmt_re_CLR_etok_atom, '')
			let b:txtfmt_re_CLR_ntok = '\%('.b:txtfmt_re_CLR_tok.'\)\@!.'
		endif
		" bgc
		if bgc
			" Active bgc only
			let b:txtfmt_re_bgc_tok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_bgc_tok_atom.']', '')
			let b:txtfmt_re_bgc_stok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_bgc_stok_atom.']', '')
			let b:txtfmt_re_bgc_etok = substitute(tmpl, 'placeholder', b:txtfmt_re_bgc_etok_atom, '')
			let b:txtfmt_re_bgc_ntok = '\%('.b:txtfmt_re_bgc_tok.'\)\@!.'
			" Active and inactive bgc
			let b:txtfmt_re_BGC_tok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_BGC_tok_atom.']', '')
			let b:txtfmt_re_BGC_stok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_BGC_stok_atom.']', '')
			let b:txtfmt_re_BGC_etok = substitute(tmpl, 'placeholder', b:txtfmt_re_BGC_etok_atom, '')
			let b:txtfmt_re_BGC_ntok = '\%('.b:txtfmt_re_BGC_tok.'\)\@!.'
		endif
		" fmt
		let b:txtfmt_re_fmt_tok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_fmt_tok_atom.']', '')
		let b:txtfmt_re_fmt_stok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_fmt_stok_atom.']', '')
		let b:txtfmt_re_fmt_etok = substitute(tmpl, 'placeholder', b:txtfmt_re_fmt_etok_atom, '')
		let b:txtfmt_re_fmt_ntok = '\%('.b:txtfmt_re_fmt_tok.'\)\@!.'
		" clr/bgc/fmt combined
		let b:txtfmt_re_any_tok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_any_tok_atom.']', '')
		let b:txtfmt_re_ANY_tok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_ANY_tok_atom.']', '')
		let b:txtfmt_re_any_stok = substitute(tmpl, 'placeholder', '['.b:txtfmt_re_any_stok_atom.']', '')
		let b:txtfmt_re_any_etok = substitute(tmpl, 'placeholder',
					\'['
					\.(clr ? nr2char(b:txtfmt_clr_first_tok) : '')
					\.(bgc ? nr2char(b:txtfmt_bgc_first_tok) : '')
					\.nr2char(b:txtfmt_fmt_first_tok)
					\.']', '')
		let b:txtfmt_re_any_ntok = '\%('.b:txtfmt_re_any_tok.'\)\@!.'
	else
		" No escaping of tokens
		" clr
		if clr
			" Active clr only
			let b:txtfmt_re_clr_tok = '['.b:txtfmt_re_clr_tok_atom.']'
			let b:txtfmt_re_clr_stok = '['.b:txtfmt_re_clr_stok_atom.']'
			let b:txtfmt_re_clr_etok = b:txtfmt_re_clr_etok_atom
			let b:txtfmt_re_clr_ntok = '[^'.b:txtfmt_re_clr_tok_atom.']'
			" Active and inactive clr
			let b:txtfmt_re_CLR_tok = '['.b:txtfmt_re_CLR_tok_atom.']'
			let b:txtfmt_re_CLR_stok = '['.b:txtfmt_re_CLR_stok_atom.']'
			let b:txtfmt_re_CLR_etok = b:txtfmt_re_CLR_etok_atom
			let b:txtfmt_re_CLR_ntok = '[^'.b:txtfmt_re_CLR_tok_atom.']'
		endif
		" bgc
		if bgc
			" Active bgc only
			let b:txtfmt_re_bgc_tok = '['.b:txtfmt_re_bgc_tok_atom.']'
			let b:txtfmt_re_bgc_stok = '['.b:txtfmt_re_bgc_stok_atom.']'
			let b:txtfmt_re_bgc_etok = b:txtfmt_re_bgc_etok_atom
			let b:txtfmt_re_bgc_ntok = '[^'.b:txtfmt_re_bgc_tok_atom.']'
			" Active and inactive bgc
			let b:txtfmt_re_BGC_tok = '['.b:txtfmt_re_BGC_tok_atom.']'
			let b:txtfmt_re_BGC_stok = '['.b:txtfmt_re_BGC_stok_atom.']'
			let b:txtfmt_re_BGC_etok = b:txtfmt_re_BGC_etok_atom
			let b:txtfmt_re_BGC_ntok = '[^'.b:txtfmt_re_BGC_tok_atom.']'
		endif
		" fmt
		let b:txtfmt_re_fmt_tok = '['.b:txtfmt_re_fmt_tok_atom.']'
		let b:txtfmt_re_fmt_stok = '['.b:txtfmt_re_fmt_stok_atom.']'
		let b:txtfmt_re_fmt_etok = b:txtfmt_re_fmt_etok_atom
		let b:txtfmt_re_fmt_ntok = '[^'.b:txtfmt_re_fmt_tok_atom.']'
		" clr/bgc/fmt combined
		let b:txtfmt_re_any_tok = '['.b:txtfmt_re_any_tok_atom.']'
		let b:txtfmt_re_ANY_tok = '['.b:txtfmt_re_ANY_tok_atom.']'
		let b:txtfmt_re_any_stok = '['.b:txtfmt_re_any_stok_atom.']'
		let b:txtfmt_re_any_etok =
					\'['
					\.(clr ? b:txtfmt_re_clr_etok_atom : '')
					\.(bgc ? b:txtfmt_re_bgc_etok_atom : '')
					\.b:txtfmt_re_fmt_etok_atom
					\.']'
		let b:txtfmt_re_any_ntok =
					\'[^'
					\.(clr ? b:txtfmt_re_clr_tok_atom : '')
					\.(bgc ? b:txtfmt_re_bgc_tok_atom : '')
					\.b:txtfmt_re_fmt_tok_atom
					\.']'
	endif
endfu
" >>>
" Function: s:Do_config_common() <<<
" Purpose: Set script local variables, taking into account whether user has
" overriden via txtfmt globals.
fu! s:Do_config_common()
	" unlet any buffer-specific options that may be set by txtfmt modeline <<<
	unlet! b:txtfmt_cfg_tokrange
				\ b:txtfmt_cfg_sync b:txtfmt_cfg_escape
				\ b:txtfmt_cfg_pack b:txtfmt_cfg_nested
				\ b:txtfmt_cfg_numfgcolors b:txtfmt_cfg_numbgcolors
				\ b:txtfmt_cfg_fgcolormask b:txtfmt_cfg_bgcolormask
				\ b:txtfmt_cfg_undercurlpref b:txtfmt_cfg_conceal
				\ b:txtfmt_cfg_concealcursor b:txtfmt_cfg_concealcursor_invalid
	" >>>
	" Attempt to process modeline <<<
	let ml_status = s:Do_txtfmt_modeline()
	" >>>
	" 'escape' option <<<
	if !exists('b:txtfmt_cfg_escape') || strlen(b:txtfmt_cfg_escape) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value
		unlet! l:bad_set_by
		if exists('b:txtfmt_cfg_escape') && strlen(b:txtfmt_cfg_escape) == 0
			" Bad modeline set
			let l:bad_set_by = 'm'
		elseif exists('b:txtfmtEscape')
			" User overrode buf-local option
			if s:Escape_is_valid(b:txtfmtEscape)
				let b:txtfmt_cfg_escape = b:txtfmtEscape
			else
				let l:bad_set_by = 'b'
			endif
		elseif exists('g:txtfmtEscape')
			" User overrode global option
			if s:Escape_is_valid(g:txtfmtEscape)
				let b:txtfmt_cfg_escape = g:txtfmtEscape
			else
				let l:bad_set_by = 'g'
			endif
		endif
		" Warn user if invalid user-setting is about to be overridden
		if exists('l:bad_set_by')
			" Note: Display the offending option value for buf-local or global
			" option, but not for modeline, since modeline processing has
			" already reported the error.
			echoerr "Warning: Ignoring invalid ".(
				\ l:bad_set_by == 'm' ? "modeline" :
				\ l:bad_set_by == 'b' ? "buf-local" :
				\ "global") . " value for txtfmt `escape' option" . (
				\ l:bad_set_by == 'm' ? '' :
				\ l:bad_set_by == 'b' ? (': ' . b:txtfmtEscape) :
				\ (': ' . g:txtfmtEscape))
		endif
		if !exists('b:txtfmt_cfg_escape') || strlen(b:txtfmt_cfg_escape) == 0
			" Set to default
			let b:txtfmt_cfg_escape = 'none'
		endif
	endif
	" >>>
	" 'pack' option <<<
	if !exists('b:txtfmt_cfg_pack') || strlen(b:txtfmt_cfg_pack) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value
		if exists('b:txtfmt_cfg_pack') && strlen(b:txtfmt_cfg_pack) == 0
			" Bad modeline set. Warn user that we're about to override. Note
			" that modeline processing has already reported the specific
			" error.
			echoerr "Warning: Ignoring invalid modeline value for txtfmt `pack' option"
		elseif exists('b:txtfmtPack')
			" User overrode buf-local option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_pack = b:txtfmtPack
		elseif exists('g:txtfmtPack')
			" User overrode global option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_pack = g:txtfmtPack
		endif
		if !exists('b:txtfmt_cfg_pack') || strlen(b:txtfmt_cfg_pack) == 0
			" Set to default (on)
			let b:txtfmt_cfg_pack = 1
		endif
	endif
	" >>>
	" 'undercurl' option <<<
	if !exists('b:txtfmt_cfg_undercurlpref') || strlen(b:txtfmt_cfg_undercurlpref) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value
		if exists('b:txtfmt_cfg_undercurlpref') && strlen(b:txtfmt_cfg_undercurlpref) == 0
			" Bad modeline set. Warn user that we're about to override. Note
			" that modeline processing has already reported the specific
			" error.
			echoerr "Warning: Ignoring invalid modeline value for txtfmt `undercurl' option"
		elseif exists('b:txtfmtUndercurl')
			" User overrode buf-local option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_undercurlpref = b:txtfmtUndercurl
		elseif exists('g:txtfmtUndercurl')
			" User overrode global option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_undercurlpref = g:txtfmtUndercurl
		endif
		if !exists('b:txtfmt_cfg_undercurlpref') || strlen(b:txtfmt_cfg_undercurlpref) == 0
			" Set to default (on)
			" Note: This is 'preference' only; if Vim version doesn't support
			" undercurl, we won't attempt to enable.
			let b:txtfmt_cfg_undercurlpref = 1
		endif
	endif
	" >>>
	" 'nested' option <<<
	if !exists('b:txtfmt_cfg_nested') || strlen(b:txtfmt_cfg_nested) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value
		if exists('b:txtfmt_cfg_nested') && strlen(b:txtfmt_cfg_nested) == 0
			" Bad modeline set. Warn user that we're about to override. Note
			" that modeline processing has already reported the specific
			" error.
			echoerr "Warning: Ignoring invalid modeline value for txtfmt `nested' option"
		elseif exists('b:txtfmtNested')
			" User overrode buf-local option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_nested = b:txtfmtNested
		elseif exists('g:txtfmtNested')
			" User overrode global option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_nested = g:txtfmtNested
		endif
		if !exists('b:txtfmt_cfg_nested') || strlen(b:txtfmt_cfg_nested) == 0
			" Set to default (on)
			let b:txtfmt_cfg_nested = 1
		endif
	endif
	" >>>
	" 'conceal' option <<<
	if !exists('b:txtfmt_cfg_conceal') || strlen(b:txtfmt_cfg_conceal) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value
		if exists('b:txtfmt_cfg_conceal')
			if strlen(b:txtfmt_cfg_conceal) == 0
				" Bad modeline set. Warn user that we're about to override. Note
				" that modeline processing has already reported the specific
				" error.
				echoerr "Warning: Ignoring invalid modeline value for txtfmt `conceal' option"
			elseif b:txtfmt_cfg_conceal && !has('conceal')
				" Modeline enables 'conceal' but the feature isn't supported
				" by Vim. Silently override the request.
				let b:txtfmt_cfg_conceal = 0
			endif
		elseif exists('b:txtfmtConceal')
			" User overrode buf-local option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_conceal = has('conceal') && b:txtfmtConceal
		elseif exists('g:txtfmtConceal')
			" User overrode global option
			" Note: Invalid setting impossible for boolean
			let b:txtfmt_cfg_conceal = has('conceal') && g:txtfmtConceal
		endif
		if !exists('b:txtfmt_cfg_conceal') || strlen(b:txtfmt_cfg_conceal) == 0
			" Enable if support for 'conceal' feature is compiled into Vim.
			" Note: This is a slightly non-backwards-compatible change with
			" respect to Txtfmt version 2.3. See help for explanation.
			let b:txtfmt_cfg_conceal = has('conceal')
		endif
	endif
	" >>>
	" 'concealcursor' option (dependent upon 'conceal') <<<
	" Note: The value of this option will be ignored if 'conceal' is off (in
	" which case, it might be safest to unset it).
	if b:txtfmt_cfg_conceal
		if !exists('b:txtfmt_cfg_concealcursor') || exists('b:txtfmt_cfg_concealcursor_invalid')
			" Either option wasn't set within modeline, or it was set to invalid
			" value
			unlet! l:bad_set_by
			if exists('b:txtfmt_cfg_concealcursor_invalid')
				" Bad modeline set
				let l:bad_set_by = 'm'
			elseif exists('b:txtfmtConcealcursor')
				" User overrode buf-local option
				if s:Concealcursor_is_valid(b:txtfmtConcealcursor)
					let b:txtfmt_cfg_concealcursor = b:txtfmtConcealcursor
				else
					let l:bad_set_by = 'b'
				endif
			elseif exists('g:txtfmtConcealcursor')
				" User overrode global option
				if s:Concealcursor_is_valid(g:txtfmtConcealcursor)
					let b:txtfmt_cfg_concealcursor = g:txtfmtConcealcursor
				else
					let l:bad_set_by = 'g'
				endif
			endif
			" Warn user if invalid user-setting is about to be overridden
			if exists('l:bad_set_by')
				" Note: Display the offending option value for buf-local or global
				" option, but not for modeline, since modeline processing has
				" already reported the error.
				echoerr "Warning: Ignoring invalid ".(
					\ l:bad_set_by == 'm' ? "modeline" :
					\ l:bad_set_by == 'b' ? "buf-local" :
					\ "global") . " value for txtfmt `concealcursor' option" . (
					\ l:bad_set_by == 'm' ? '' :
					\ l:bad_set_by == 'b' ? (': ' . b:txtfmtConcealcursor) :
					\ (': ' . g:txtfmtConcealcursor))
			endif
			if !exists('b:txtfmt_cfg_concealcursor') || exists('b:txtfmt_cfg_concealcursor_invalid')
				" By default, conceal tokens always, even in cursor line
				let b:txtfmt_cfg_concealcursor = 'nvic'
			endif
			" At this point, b:txtfmt_cfg_concealcursor_invalid has served its
			" purpose, and although it's unlet at the head of this function,
			" I'd rather not leave an 'invalid' var in existence.
			unlet! b:txtfmt_cfg_concealcursor_invalid
		endif
	else
		" This option is N/A when 'conceal' is off
		unlet! b:txtfmt_cfg_concealcursor
	endif
	" >>>
	" 'tokrange' option <<<
	" Note: 'starttok' and 'formats' are distinct options internally, but may
	" be set only as a unit by the plugin user. Even if tokrange was set
	" within modeline, there is work yet to be done.
	call s:Set_tokrange()
	" >>>
	" 'fgcolormask' option <<<
	if !exists('b:txtfmt_cfg_fgcolormask') || strlen(b:txtfmt_cfg_fgcolormask) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value
		unlet! l:bad_set_by
		if exists('b:txtfmt_cfg_fgcolormask') && strlen(b:txtfmt_cfg_fgcolormask) == 0
			" Bad modeline set
			let l:bad_set_by = 'm'
		elseif exists('b:txtfmtFgcolormask')
			" User overrode buf-local option
			if s:Clrmask_is_valid(b:txtfmtFgcolormask)
				let b:txtfmt_cfg_fgcolormask = b:txtfmtFgcolormask
			else
				let l:bad_set_by = 'b'
			endif
		elseif exists('g:txtfmtFgcolormask')
			" User overrode global option
			if s:Clrmask_is_valid(g:txtfmtFgcolormask)
				let b:txtfmt_cfg_fgcolormask = g:txtfmtFgcolormask
			else
				let l:bad_set_by = 'g'
			endif
		endif
		" Warn user if invalid user-setting is about to be overridden
		if exists('l:bad_set_by')
			" Note: Display the offending option value for buf-local or global
			" option, but not for modeline, since modeline processing has
			" already reported the error.
			echoerr "Warning: Ignoring invalid ".(
				\ l:bad_set_by == 'm' ? "modeline" :
				\ l:bad_set_by == 'b' ? "buf-local" :
				\ "global") . " value for txtfmt `fgcolormask' option" . (
				\ l:bad_set_by == 'm' ? '' :
				\ l:bad_set_by == 'b' ? (': ' . b:txtfmtFgcolormask) :
				\ (': ' . g:txtfmtFgcolormask))
		endif
		if !exists('b:txtfmt_cfg_fgcolormask') || strlen(b:txtfmt_cfg_fgcolormask) == 0
			" Set to default - all foreground colors active (for backward
			" compatibility)
			" TODO: Don't hardcode
			let b:txtfmt_cfg_fgcolormask = '11111111'
		endif
	endif
	" >>>
	" 'bgcolormask' option <<<
	if !exists('b:txtfmt_cfg_bgcolormask') || strlen(b:txtfmt_cfg_bgcolormask) == 0
		" Either option wasn't set within modeline, or it was set to invalid
		" value
		unlet! l:bad_set_by
		if exists('b:txtfmt_cfg_bgcolormask') && strlen(b:txtfmt_cfg_bgcolormask) == 0
			" Bad modeline set
			let l:bad_set_by = 'm'
		elseif exists('b:txtfmtBgcolormask')
			" User overrode buf-local option
			if s:Clrmask_is_valid(b:txtfmtBgcolormask)
				let b:txtfmt_cfg_bgcolormask = b:txtfmtBgcolormask
			else
				let l:bad_set_by = 'b'
			endif
		elseif exists('g:txtfmtBgcolormask')
			" User overrode global option
			if s:Clrmask_is_valid(g:txtfmtBgcolormask)
				let b:txtfmt_cfg_bgcolormask = g:txtfmtBgcolormask
			else
				let l:bad_set_by = 'g'
			endif
		endif
		" Warn user if invalid user-setting is about to be overridden
		if exists('l:bad_set_by')
			" Note: Display the offending option value for buf-local or global
			" option, but not for modeline, since modeline processing has
			" already reported the error.
			echoerr "Warning: Ignoring invalid ".(
				\ l:bad_set_by == 'm' ? "modeline" :
				\ l:bad_set_by == 'b' ? "buf-local" :
				\ "global") . " value for txtfmt `bgcolormask' option" . (
				\ l:bad_set_by == 'm' ? '' :
				\ l:bad_set_by == 'b' ? (': ' . b:txtfmtBgcolormask) :
				\ (': ' . g:txtfmtBgcolormask))
		endif
		if !exists('b:txtfmt_cfg_bgcolormask') || strlen(b:txtfmt_cfg_bgcolormask) == 0
			" Set to default of red, green and blue if background colors are
			" active; otherwise, disable all colors.
			" TODO_BG: Decide whether it makes sense to unlet the variable
			" completely.
			" TODO_BG: b:txtfmt_cfg_bgcolor is probably not set yet!!!! This
			" needs to be moved till after Set_tokrange
			if b:txtfmt_cfg_bgcolor
				" TODO: Don't hardcode
				let b:txtfmt_cfg_bgcolormask = '01101000'
			else
				" No background color supported
				let b:txtfmt_cfg_bgcolormask = '00000000'
			endif
		endif
	endif
	" Force mask to all zeroes if background colors are disabled.
	" Assumption: Set_tokrange has already run; thus, b:txtfmt_cfg_bgcolor has
	" been set.
	if !b:txtfmt_cfg_bgcolor
		let b:txtfmt_cfg_bgcolormask = '00000000'
	endif
	" >>>
	" 'sync' option <<<
	" Note: 'syncmethod' and 'synclines' are distinct options internally, but
	" may be set only as a unit by the plugin user. Even if sync was set
	" within modeline, there is work yet to be done.
	call s:Set_syncing()
	" >>>
	" Define various buffer-specific variables now that fmt/clr ranges are fixed.
	" TODO: Perhaps combine the following 2 functions in some way...
	call s:Define_fmtclr_vars()
	" Define fmt/clr regexes - used in both syntax and ftplugin <<<
	call s:Define_fmtclr_regexes()
	" >>>
	" Process color options <<<
	call s:Process_color_options()
	" >>>
endfu
" >>>
call s:Do_config_common()
" Define buffer-local constants <<<
" For convenience, associate format indices with their respective
" '[u][b][i][s][r][c]' string, in fiducial form. Note that fiducial form may
" be used for display, but is also a valid (but not the only) fmt spec.
let b:ubisrc_fmt0  = '-'
let b:ubisrc_fmt1  = 'u'
let b:ubisrc_fmt2  = 'b'
let b:ubisrc_fmt3  = 'bu'
let b:ubisrc_fmt4  = 'i'
let b:ubisrc_fmt5  = 'iu'
let b:ubisrc_fmt6  = 'ib'
let b:ubisrc_fmt7  = 'ibu'
let b:ubisrc_fmt8  = 's'
let b:ubisrc_fmt9  = 'su'
let b:ubisrc_fmt10 = 'sb'
let b:ubisrc_fmt11 = 'sbu'
let b:ubisrc_fmt12 = 'si'
let b:ubisrc_fmt13 = 'siu'
let b:ubisrc_fmt14 = 'sib'
let b:ubisrc_fmt15 = 'sibu'
let b:ubisrc_fmt16 = 'r'
let b:ubisrc_fmt17 = 'ru'
let b:ubisrc_fmt18 = 'rb'
let b:ubisrc_fmt19 = 'rbu'
let b:ubisrc_fmt20 = 'ri'
let b:ubisrc_fmt21 = 'riu'
let b:ubisrc_fmt22 = 'rib'
let b:ubisrc_fmt23 = 'ribu'
let b:ubisrc_fmt24 = 'rs'
let b:ubisrc_fmt25 = 'rsu'
let b:ubisrc_fmt26 = 'rsb'
let b:ubisrc_fmt27 = 'rsbu'
let b:ubisrc_fmt28 = 'rsi'
let b:ubisrc_fmt29 = 'rsiu'
let b:ubisrc_fmt30 = 'rsib'
let b:ubisrc_fmt31 = 'rsibu'
let b:ubisrc_fmt32 = 'c'
let b:ubisrc_fmt33 = 'cu'
let b:ubisrc_fmt34 = 'cb'
let b:ubisrc_fmt35 = 'cbu'
let b:ubisrc_fmt36 = 'ci'
let b:ubisrc_fmt37 = 'ciu'
let b:ubisrc_fmt38 = 'cib'
let b:ubisrc_fmt39 = 'cibu'
let b:ubisrc_fmt40 = 'cs'
let b:ubisrc_fmt41 = 'csu'
let b:ubisrc_fmt42 = 'csb'
let b:ubisrc_fmt43 = 'csbu'
let b:ubisrc_fmt44 = 'csi'
let b:ubisrc_fmt45 = 'csiu'
let b:ubisrc_fmt46 = 'csib'
let b:ubisrc_fmt47 = 'csibu'
let b:ubisrc_fmt48 = 'cr'
let b:ubisrc_fmt49 = 'cru'
let b:ubisrc_fmt50 = 'crb'
let b:ubisrc_fmt51 = 'crbu'
let b:ubisrc_fmt52 = 'cri'
let b:ubisrc_fmt53 = 'criu'
let b:ubisrc_fmt54 = 'crib'
let b:ubisrc_fmt55 = 'cribu'
let b:ubisrc_fmt56 = 'crs'
let b:ubisrc_fmt57 = 'crsu'
let b:ubisrc_fmt58 = 'crsb'
let b:ubisrc_fmt59 = 'crsbu'
let b:ubisrc_fmt60 = 'crsi'
let b:ubisrc_fmt61 = 'crsiu'
let b:ubisrc_fmt62 = 'crsib'
let b:ubisrc_fmt63 = 'crsibu'
" >>>
else " if exists('b:txtfmt_do_common_config')
" Function: s:Txtfmt_refresh() <<<
" Purpose: Invoked by buffer-local command Refresh when user wishes to
" reload txtfmt plugins safely for the current buffer; e.g., after changing
" option settings.
" Important Note: This function must be within the else of an if
" exists('b:txtfmt_do_common_config'); otherwise, we will get an error when this
" function causes the plugins to be re-sourced, since the re-sourcing of this
" file will result in an attempt to redefine the function while it is running!
fu! s:Txtfmt_refresh()
	" Ensure that common configuration code will not be skipped next time
	unlet! b:txtfmt_did_common_config
	" Determine whether txtfmt ftplugin is loaded
	if exists('b:loaded_txtfmt')
		" b:loaded_txtfmt is set only within ftplugin/txtfmt.vim and unlet by
		" b:undo_ftplugin; hence, its existence indicates that txtfmt ftplugin
		" is currently loaded. Cache the filetype that was cached at load
		" time.
		let l:current_filetype = b:txtfmt_filetype
	endif
	" Determine whether txtfmt syntax plugin is loaded
	let v:errmsg = ''
	silent! syn sync match Tf_existence_test grouphere Tf_fmt_1 /\%^/
	if v:errmsg == ''
		" No error means txtfmt syntax plugin is loaded. Cache the syntax name
		" that was cached at load time.
		let l:current_syntax = b:txtfmt_syntax
	endif
	" Is there anything to refresh?
	if !exists('l:current_filetype') && !exists('l:current_syntax')
		echomsg "Warning: Useless call to Refresh: "
			\."no txtfmt plugins appear to be loaded."
		return
	endif
	" If here, there was a reason for the Txtfmt_refresh call. Cause ftplugin
	" and/or syntax plugin to be reloaded via FileType and Syntax sets, as
	" appropriate.
	if exists('l:current_syntax')
		" We're going to attempt to reload syntax plugin. Unload it now
		" (causing b:current_syntax to be unlet). If we set filetype below,
		" and b:current_syntax exists afterwards, we'll know syntax was loaded
		" via syntaxset autocmd linked to FileType event. Alternatively,
		" could simply unlet b:current_syntax here...
		set syntax=OFF
	endif
	if exists('l:current_filetype')
		" Set filetype to whatever it was before
		exe 'set filetype=' . l:current_filetype
	endif
	if exists('l:current_syntax')
		" Syntax may have been loaded already, but if not, we'll need to do it
		" manually...
		if exists('b:current_syntax')
			" Syntax was loaded as a result of the filetype set. Make sure it
			" appears to be the correct one.
			if b:current_syntax != l:current_syntax
				echomsg "Warning: Txtfmt attempted to restore syntax to `"
				\.l:current_syntax."'. Result was `".b:current_syntax."'"
				echomsg "I'm guessing you have loaded the txtfmt plugins "
				\."in a non-standard manner. See txtfmt help for more information."
			endif
		else
			" Syntax wasn't linked to filetype. Load the desired syntax manually.
			exe 'set syntax=' . l:current_syntax
		endif
	endif	
endfu
" >>>
endif " if exists('b:txtfmt_do_common_config')
" General-purpose utilities <<<
" Note: These utilities are defined globally in the plugin file so that they
" might be used by any of the Txtfmt script files.
" Naming Convention: All of these utilities should begin with 'TxtfmtUtil_'
" and should separate internal 'words' with underscore. Internal words should
" not be capitalized.
" Function: TxtfmtUtil_num_to_hex_str <<<
" Description: Take the input value and convert it to a hex string of the form
" 0xXXXX.
" Format Note: Output string will have '0x' prepended, but will omit leading
" zeroes.
fu! TxtfmtUtil_num_to_hex_str(num)
	" Get writable copy
	let num = a:num
	" Loop until the value has been completely processed
	let str = ''
	let abcdef = "ABCDEF"
	while num > 0
		let dig = num % 16
		" Convert the digit value to a hex digit and prepend to hex str
		if dig <= 9
			let str = dig . str
		else
			let str = strpart(abcdef, dig - 10, 1) . str
		endif
		let num = num / 16
	endwhile
	" Prepend '0x' to hex string built in loop
	" Note: If string is empty, it should be '0'
	return '0x' . (strlen(str) == 0 ? '0' : str)
endfu
" >>>
" >>>
" Function: s:MakeTestPage() <<<
" Purpose: Build a "test-page" in a scratch buffer, to show user how color
" and format regions will look with current definitions and on current
" terminal. (Useful to prevent user from having to insert all the color and
" format regions manually with text such as "Here's a little test...")
" How: Create a scratch buffer whose filetype is set to txtfmt. Add some
" explanation lines at the top, followed by one line for each active color, as
" follows:
" color<num> none i b bi u ui ub ubi ...
" Repeat for each active background color...
" Note: The function is script-local, as it is designed to be invoked from a
" command.
" IMPORTANT NOTE: Special care must be taken when defining this function, as
" it creates a buffer with 'ft' set to txtfmt, which causes the script to be
" re-sourced. This leads to E127 'Cannot redefine function' when fu[!] is
" encountered, since the function is in the process of executing.
if !exists('*s:MakeTestPage')
fu! s:MakeTestPage(...)
	if a:0 == 1
		" User provided optional modeline arguments. Before opening scratch
		" buffer, make sure the modeline constructed from the arguments has at
		" least the overall appearance of being valid. (Option name/value
		" validation is performed only after opening the test page buffer.)
		if !s:Is_txtfmt_modeline("\<Tab>txtfmt:".a:1)
			" Warn of invalid modeline and return without creating the test
			" buffer
			echoerr "Invalid arguments passed to :MakeTestPage command: `".a:1."'"
			return
		endif
	endif
	" Attempt to open the buffer (success not guaranteed)
	if !s:New_window(s:TESTPAGE_WINHEIGHT)
		" If E36, give helpful message about increasing size of current
		" window; otherwise, given generic message followed by raw Vim
		" error message.
		if s:err_str =~ '^E36:'
			echoerr "MakeTestPage(): Can't open test page. Increase size of current window and try again."
		else
			echoerr "MakeTestPage(): Error opening test page: " . s:err_str
		endif
		" Abort test page
		return
	endif
	set buftype=nofile
	set bufhidden=hide
	set noswapfile
	" The following setlocal is necessary to prevent E21 in the event that
	" 'nomodifiable' is set globally.
	setlocal modifiable
	" If user provided modeline, add it to top of file before setting filetype
	" to txtfmt...
	if a:0 == 1
		let modeline = a:1
		if modeline =~ '\S'
			call setline(1, "\<Tab>txtfmt:".modeline)
		endif
	elseif a:0 > 1
		" This should never happen, since this function is called from a
		" mapping.
		echoerr "Too many arguments passed to MakeTestPage."
			\." (Note that this function should not be called directly.)"
	endif
	set filetype=txtfmt
	" Set page formatting options
	" TODO - Decide whether the following are necessary anymore. (I'm
	" formatting things explicitly now...)
	set noai ts=4 sw=4 tw=78
	set nowrap
	" Cache some special tokens that will be used on this page
	let tok_fb = Txtfmt_GetTokStr('fb')
	let tok_fui = Txtfmt_GetTokStr('fui')
	let tok_fu = Txtfmt_GetTokStr('fu')
	let tok_fmt_end = nr2char(b:txtfmt_fmt_first_tok)
	let tok_clr_end = nr2char(b:txtfmt_clr_first_tok)
	" Important Note: Most of the following logic assumes that each token that
	" is hidden by a txtfmt concealment group will appear as a single
	" whitespace. If the 'conceal' patch is in effect, however, such tokens
	" will not appear at all. The problem is that the token width is sometimes
	" used to achieve the desired alignment. To facilitate keeping the
	" alignment constant, I declare a variable that resolves to a single
	" whitespace if and only if the conceal patch is in effect. This variable
	" will be appended to tokens that would affect alignment in the absence of
	" the conceal patch.
	" Note: The space could go before or after the token, but after is best in
	" the case of bg colors.
	let cncl_ws = b:txtfmt_cfg_conceal ? ' ' : ''
	call append(line('$'), tok_fb)
	call append(line('$'),
		\"************************")
	$center
	call append(line('$'),
		\"*** TXTFMT TEST PAGE ***")
	$center
	call append(line('$'),
		\"************************")
	$center
	call append(line('$'),
		\"=============================================================================")
	call append(line('$'),
		\"*** Overview ***")
	$center
	call append(line('$'), tok_fmt_end)
	call append(line('$'), "")
	call append(line('$'),
		\"The purpose of this page is to present an overview of the txtfmt highlighting")
	call append(line('$'),
		\"that results from the global txtfmt options and any txtfmt modeline settings")
	call append(line('$'),
		\"passed to the MakeTestPage command.")
	call append(line('$'), "")
	call append(line('$'),
		\"	:help txtfmt-MakeTestPage")
	call append(line('$'), "")
	call append(line('$'),
		\"The text on the page has been chosen to display all possible combinations of")
	call append(line('$'),
		\"color and format regions, and if applicable, to illustrate the escaping of")
	call append(line('$'),
		\"tokens and the nesting of txtfmt regions.")
	call append(line('$'), tok_fb)
	call append(line('$'),
		\"=============================================================================")
	call append(line('$'),
		\"*** Colors and Formats ***")
	$center
	call append(line('$'), tok_fui)
	" Possible TODO: Use b:txtfmt_cfg_tokrange so that number format specified
	" by user is respected.
	call append(line('$'),
		\'Configuration:'.tok_fb.cncl_ws
		\."tokrange =".tok_fmt_end.cncl_ws
		\.b:txtfmt_cfg_starttok_display.b:txtfmt_cfg_formats_display
		\)
	call append(line('$'), "")
	call append(line('$'),
		\"\<Tab>start token: ".b:txtfmt_cfg_starttok_display)
	call append(line('$'),
		\"\<Tab>background colors: ".(b:txtfmt_cfg_bgcolor
			\? "enabled (".b:txtfmt_cfg_numbgcolors." active)"
			\: "disabled"))
	call append(line('$'),
		\"\<Tab>".(b:txtfmt_cfg_longformats ? "'long'" : "'short'")." formats "
		\.(b:txtfmt_cfg_longformats
		\    ?
		\        (b:txtfmt_cfg_undercurl
		\        ? "with"
		\        : "without")
		\        ." undercurl"
		\    :
		\        ""
		\ ))
	call append(line('$'), '')
	" TODO_BG: Decide whether to attempt to be more discriminating: e.g., what
	" if bgcolor is enabled, but none are active? Same question for fgcolor?
	" Decision: I'm thinking there's no reason to do it. Typically, user won't
	" de-activate all colors, but if he does, perhaps we want him to scratch
	" his head a bit.
	if b:txtfmt_cfg_bgcolor
		call append(line('$'),
			\"Each line in the table below corresponds to a single permutation of foreground")
		call append(line('$'),
			\"and background colors. You may use the special global arrays g:txtfmtColor{}")
		call append(line('$'),
			\"and g:txtfmtBgcolor{} to change these colors.")
	else
		call append(line('$'),
			\"Each line in the table below corresponds to a single foreground color. You may")
		call append(line('$'),
			\"use the special global array g:txtfmtColor{} to change these colors.")
	endif
	call append(line('$'), '')
	call append(line('$'),
		\'    :help txtfmt-defining-colors')
	call append(line('$'), '')
	call append(line('$'),
		\"The ".b:txtfmt_num_formats." permutations of the format attributes ")
	call append(line('$'),
		\'(u=underline, b=bold, i=italic'
		\.(b:txtfmt_cfg_longformats
		\     ? ', s=standout, r=reverse'
		\       .b:txtfmt_cfg_undercurl
		\           ? ', c=undercurl'
		\           : ''
		\     : ''
		\ ).')')
	call append(line('$'), "are shown on each color line for completeness.")
	call append(line('$'), tok_fb)
	call append(line('$'),
		\"IMPORTANT NOTE:".tok_fmt_end."Txtfmt chooses a default range for clr/fmt tokens, which works")
	call append(line('$'),
		\"well on most terminals; however, this range may not be suitable for all")
	call append(line('$'),
		\"terminals. In particular, Vim cannot highlight those characters displayed by")
	call append(line('$'),
		\"the terminal as special 2-character sequences (e.g., ^M, ^B, etc...). Although")
	call append(line('$'),
		\"coloring and formatting of text will work when these characters are used as")
	call append(line('$'),
		\"tokens, their use is discouraged, because txtfmt is unable to conceal them. If")
	call append(line('$'),
		\"any such control sequences are visible in the sample text below, you may wish")
	call append(line('$'),
		\"to try a different range, either by setting global txtfmt option")
	call append(line('$'),
		\"g:txtfmtTokrange to a different value, or by including a different definition")
	call append(line('$'),
		\"in a txtfmt modeline string passed to the MakeTestPage command. Either way, you")
	call append(line('$'),
		\"will need to invoke MakeTestPage again to see whether the changed settings are")
	call append(line('$'),
		\"better.")
	call append(line('$'), "")
	call append(line('$'),
		\"    :help txtfmt-choosing-token-range")
	call append(line('$'), '')
	call append(line('$'), tok_fb)
	call append(line('$'),
		\'--color/format table--')
	call append(line('$'), tok_fmt_end)

	" Determine line on which to start the fmt/clr table
	let iLine = line('.')
	" Before looping over bgc, fgc and fmt, determine the length of the list
	" of format specs (i.e., the number of characters, including start fmt
	" specs, from the hyphen to the end of the line).
	" Assumption: Each format token will take up a single character width. (If
	" conceal patch is in effect, it will be a literal space.)
	" Note: We don't include either the 'no format' token at the end of the
	" line or the following space (used for table framing) in the count, as
	" these characters are beyond the edge of the table proper, and we want
	" them to extend beyond the end of the underscores.
	let post_hyphen_width = 1 " hyphen representing 'no fmt'
	let iFmt = 1 " start just after 'no format' token
	while iFmt < b:txtfmt_num_formats
		" Accumulate width of space and fmt spec
		let post_hyphen_width = post_hyphen_width + 1 + strlen(b:ubisrc_fmt{iFmt})
		let iFmt = iFmt + 1
	endwhile
	" Define width of lines up to the hyphen, *NOT* including potentially
	" multibyte token chars that appear at the beginning of the line. A fixed
	" number of columns will be reserved for such tokens.
	" Note: This width is chosen with the string 'no bg color' in mind
	let pre_hyphen_width = 16
	" Generate a string of underscores that spans the table (but not the
	" framing whitespace/tokens at left and right edges)
	let underscores = s:Repeat('_', pre_hyphen_width + post_hyphen_width)
	" Put the text into the buffer
	" Outer loop is over background colors
	" Note: piBgc in the loop below is a 1-based index into
	" b:txtfmt_cfg_bgcolor{}, the array of active color indices. This array
	" stores the actual color index corresponding to the piBgc'th active
	" color; i.e., it stores the indices that are used for the b:txtfmt_bgc{}
	" array. Both arrays are 1-based. Index 0 represents the default (no)
	" color token in b:txtfmt_bgc{}.
	" Note: Even if bgc is disabled, we'll iterate once for default background
	let piBgc = 0
	while piBgc <= (b:txtfmt_cfg_bgcolor ? b:txtfmt_cfg_numbgcolors : 0)
		" Get the actual color index via one level of indirection
		let iBgc = piBgc == 0 ? 0 : b:txtfmt_cfg_bgcolor{piBgc}
		" Don't output the bg color title if bgcolor is disabled
		if b:txtfmt_cfg_bgcolor
			" Put a line consisting entirely of underscores before the bg
			" color title line
			" Note: If this is not the default bg color, a bg token and
			" possibly a default fg token will need to be prepended.
			if iBgc == 0
				" Default bg color
				let s = '  '
			else
				" Non-default bg color
				let s = nr2char(b:txtfmt_bgc_first_tok + iBgc).cncl_ws
				if b:txtfmt_cfg_numfgcolors
					" We're currently inside a fg clr region, but bg color
					" title line should be default fg color, so end the fg
					" color
					let s = s.nr2char(b:txtfmt_clr_first_tok).cncl_ws
				else
					" No fg clr region to end, but need space for alignment
					let s = s.' '
				endif
			endif
			" Now append the underscores and a 2-space end of line pad
			let s = s . underscores . '  '
			call append(line('$'), s)
			" Insert a description of the current bg color
			if iBgc == 0
				let s = "  no bg color"
			else
				let s = "  Bg color ".iBgc
			endif
			" Append spaces such that background coloration is as wide as it is on
			" subsequent lines.
			" Note: The hardcoded 4 is for the beginning and end of line framing spaces
			" Note: s cannot contain multibyte chars at this point, so the
			" strlen() is safe.
			let s = s . s:Repeat(' ', pre_hyphen_width + post_hyphen_width + 4 - strlen(s))
			call append(line('$'), s)
			" Put a line consisting entirely of underscores after the bg color
			" title line
			call append(line('$'), '  ' . underscores . '  ')
		endif
		" Note: See notes on piBgc and iBgc above for description of piClr and
		" iClr.
		let piClr = 0
		while piClr <= b:txtfmt_cfg_numfgcolors
			" Get the actual color index via one level of indirection
			let iClr = piClr == 0 ? 0 : b:txtfmt_cfg_fgcolor{piClr}
			" Build the string for this line, taking care to ensure there is a
			" margin of 2 space widths
			" Note: Need to keep beginning of line spaces/tokens separate
			" until after the strlen(), since strlen counts characters rather
			" than bytes.
			if iClr == 0
				let ldr = '  '
				let s = "no fg color"
			else
				" Insert the non-default fg clr token, preceded by a space in
				" the column dedicated to bg clr tokens
				let ldr = ' '.nr2char(b:txtfmt_clr_first_tok + iClr).cncl_ws
				let s = 'Fg color '.iClr
			endif
			" Pad with spaces till hyphen
			let s = ldr . s . s:Repeat(' ', pre_hyphen_width - strlen(s))
			" Loop over format attributes
			let iFmt = 0
			while iFmt < b:txtfmt_num_formats
				if iFmt == 0
					let s = s.'-'
				else
					" Conceal patch entails special handling to prevent the
					" space between the specifiers from being underlined or
					" undercurled.
					" Case 1: 'conceal'
					" <SPC> <fmt-tok> <fmt-spec> <no-fmt-tok>
					" Case 2: 'noconceal'
					" <fmt-tok> <fmt-spec>
					" Note: For the 'noconceal' case *only*, a single
					" <no-fmt-tok> goes outside loop.
					let s = s . cncl_ws
						\. nr2char(b:txtfmt_fmt_first_tok + iFmt)
						\. b:ubisrc_fmt{iFmt}
						\. (b:txtfmt_cfg_conceal ? nr2char(b:txtfmt_fmt_first_tok) : '')
				endif
				let iFmt = iFmt + 1
			endwhile
			" If necessary, add default fmt token to prevent formatting from
			" spilling onto next line, and add space(s) for margin
			" Case 1: 'conceal'
			" <SPC> <SPC>
			" Case 2: 'noconceal'
			" <no-fmt-tok> <SPC>
			let s = s . (b:txtfmt_cfg_conceal ? ' ' : nr2char(b:txtfmt_fmt_first_tok)) . ' '
			call append(line('$'), s)
			let piClr = piClr + 1
		endwhile
		let piBgc = piBgc + 1
	endwhile
	" Return to default background and foreground colors (as applicable)
	" TODO: If 'conceal', then this has been done already.
	call append(line('$'),
		\(b:txtfmt_cfg_bgcolor && b:txtfmt_cfg_numbgcolors > 0 ? nr2char(b:txtfmt_bgc_first_tok) : '')
		\.(b:txtfmt_cfg_numfgcolors > 0 ? nr2char(b:txtfmt_clr_first_tok) : ''))

	call append(line('$'), tok_fb)
	call append(line('$'),
		\"=============================================================================")
	call append(line('$'),
		\"*** Escaping txtfmt tokens ***")
	$center
	call append(line('$'), tok_fui)
	call append(line('$'),
		\'Configuration:'.tok_fb.cncl_ws."escape".tok_fmt_end.cncl_ws."= ".b:txtfmt_cfg_escape)
	call append(line('$'), "")
	call append(line('$'),
		\"    :help txtfmt-escape")
	" Now display text specific to the option setting
	if b:txtfmt_cfg_escape != 'none'
		call append(line('$'), tok_fb)
		call append(line('$'),
			\'--Escaping tokens outside a region--'.tok_fmt_end)
		call append(line('$'),
			\"The following shows that all tokens (other than the \"no fmt\" / \"no clr\" tokens)")
		call append(line('$'),
			\"may be escaped to prevent them from beginning a region:")
		" Escaped fg color tokens
		call append(line('$'), '')
		call append(line('$'), tok_fb.cncl_ws
			\.'*'.(b:txtfmt_cfg_bgcolor ? 'fg ' : '').'color tokens*'.tok_fmt_end)
		" Loop over all clr tokens, inserting an escaped version of each.
		let s = ''
		let piClr = 1
		while piClr <= b:txtfmt_cfg_numfgcolors
			let iClr = b:txtfmt_cfg_fgcolor{piClr}
			let tok = nr2char(b:txtfmt_clr_first_tok + iClr)
			let s = s.cncl_ws.(b:txtfmt_cfg_escape == 'self' ? tok : '\').tok
			let piClr = piClr + 1
		endwhile
		if s == ''
			" Indicate that no fg colors are active
			let s = ' --N/A--'
		endif
		call append(line('$'), s)
		" Escaped bg color tokens
		if b:txtfmt_cfg_bgcolor
			call append(line('$'), tok_fb.cncl_ws
				\.'*bg color tokens*'.tok_fmt_end)
			" Loop over all bgc tokens, inserting an escaped version of each.
			let s = ''
			let piBgc = 1
			while piBgc <= b:txtfmt_cfg_numbgcolors
				let iBgc = b:txtfmt_cfg_bgcolor{piBgc}
				let tok = nr2char(b:txtfmt_bgc_first_tok + iBgc)
				let s = s.cncl_ws.(b:txtfmt_cfg_escape == 'self' ? tok : '\').tok
				let piBgc = piBgc + 1
			endwhile
			if s == ''
				" Indicate that no bg colors are active
				let s = ' --N/A--'
			endif
			call append(line('$'), s)
		endif
		" Escaped format tokens
		call append(line('$'), tok_fb.cncl_ws
			\.'*format tokens*'.tok_fmt_end)
		" Loop over all fmt tokens, inserting an escaped version of each.
		let s = ''
		let iFmt = 1
		while iFmt < b:txtfmt_num_formats
			let tok = nr2char(b:txtfmt_fmt_first_tok + iFmt)
			let s = s.cncl_ws.(b:txtfmt_cfg_escape == 'self' ? tok : '\').tok
			let iFmt = iFmt + 1
		endwhile
		call append(line('$'), s)
		call append(line('$'), tok_fb)
		call append(line('$'),
			\'--Escaping tokens inside a region--'.tok_fui)
		call append(line('$'), '')
		call append(line('$'),
			\"Here's a little swatch of \"underline, italic\" text. On the line below are some")
		call append(line('$'),
			\"escaped tokens, which, in their unescaped form, would alter the region's")
		call append(line('$'),
			\"formatting:")
		call append(line('$'),
			\(b:txtfmt_cfg_escape == 'self' ? tok_fb : '\').tok_fb
			\.' (escaped bold token), '
			\.(b:txtfmt_cfg_escape == 'self' ? tok_fmt_end : '\').tok_fmt_end
			\.' (escaped "no fmt" token)')
		call append(line('$'),
			\"As you can see, the escaping characters are concealed, and the formatting is")
		call append(line('$'),
			\"unaffected by the escaped tokens.")
		call append(line('$'),
			\"Note: After you have viewed the rest of this page, you may wish to experiment")
		call append(line('$'),
			\"by removing the escape tokens to see how the formatting is affected.")
	else
		" Inform user that escaping is not configured
		call append(line('$'), '')
		call append(line('$'),
			\"Escaping of txtfmt tokens is currently disabled.")
	endif

	call append(line('$'), tok_fb)
	call append(line('$'),
		\"=============================================================================")
	call append(line('$'),
		\"*** Nesting txtfmt regions ***")
	$center
	call append(line('$'), tok_fui)
	call append(line('$'),
		\'Configuration:'.tok_fb.cncl_ws.(b:txtfmt_cfg_nested ? "nested" : "nonested").tok_fmt_end)
	call append(line('$'), "")
	call append(line('$'),
		\"    :help txtfmt-nesting")
	" Now display text specific to the option setting
	if b:txtfmt_cfg_nested
		call append(line('$'), '')
		call append(line('$'),
			\"/* Here's a sample comment (italicized), intended to illustrate the nesting of")
		call append(line('$'),
			\" * txtfmt regions within non-txtfmt regions.")
		call append(line('$'),
			\" *")
		call append(line('$'),
			\" * The following txtfmt token -->".tok_fu."<-- begins a nested \"underline\" region, which")
		call append(line('$'),
			\" * ends with the following \"no fmt\" token. -->".tok_fmt_end."<--")
		call append(line('$'),
			\" * As you can see, the comment resumes automatically after the nested region")
		call append(line('$'),
			\" * ends. */")
		call append(line('$'), "")
		call append(line('$'),
			\"Non-txtfmt regions may be divided into two categories: those with the")
		call append(line('$'),
			\"'keepend' attribute, and those without it. To demonstrate the effect of the")
		call append(line('$'),
			\"'keepend' attribute on nested txtfmt regions, I have defined two additional")
		call append(line('$'),
			\"regions, enclosed by curly braces and square brackets respectively. The curly")
		call append(line('$'),
			\"brace region does not have the 'keepend' attribute; the square bracket region")
		call append(line('$'),
			\"does. Both regions are highlighted in bold.")
		call append(line('$'),
			\"{ Once again, here's a".tok_fu.cncl_ws."nested \"underline\" txtfmt region, followed by a curly")
		call append(line('$'),
			\"brace. }")
		call append(line('$'),
			\"As you can see, the nested txtfmt region was *not* terminated by the")
		call append(line('$'),
			\"closing curly brace. In fact, the curly brace region was extended by the")
		call append(line('$'),
			\"txtfmt region. Notice how the following txtfmt \"no fmt\" token -->".tok_fmt_end."<--")
		call append(line('$'),
			\"permits the resumption of the curly brace region}, which is finally ended by")
		call append(line('$'),
			\"the unobscured closing curly brace.")
		call append(line('$'),
			\"[ Notice, by contrast, how both the".tok_fu.cncl_ws."nested \"underline\" txtfmt region and the")
		call append(line('$'),
			\"square bracket region itself are terminated by the following square bracket ]")
		call append(line('$'),
			\"because the square bracket region was defined with the 'keepend' attribute.")


		" Define comment, curly brace, and square brace regions...
		syn region Tf_example_comment start=+/\*+ end=+\*/+ keepend
		hi Tf_example_comment cterm=italic gui=italic
		syn region Tf_example_curly start=+{+ end=+}+
		hi Tf_example_curly cterm=bold gui=bold
		syn region Tf_example_square start=+\[+ end=+\]+ keepend
		hi Tf_example_square cterm=bold gui=bold
	else
		" Inform user that nesting is not configured
		call append(line('$'), "")
		call append(line('$'),
			\"Nesting of txtfmt regions is currently disabled.")
	endif

endfu
endif	" if !exists('*s:MakeTestPage')
" >>>
" Public-interface commands <<<
" TODO - Add this command to undo list - Should it redefine (com!)?
com! -nargs=? MakeTestPage call s:MakeTestPage(<f-args>)
" >>>
	" vim: sw=4 ts=4 foldmethod=marker foldmarker=<<<,>>> :
ftplugin/txtfmt.vim	[[[1
2672
" Txtfmt: Set of Vim plugins (syntax, ftplugin, plugin) for creating and
" displaying formatted text with Vim.
" File: This is the txtfmt ftplugin file, which contains mappings and
" functions for working with the txtfmt color/formatting tokens.
" Creation:	2004 Nov 06
" Last Change: 2008 May 10
" Maintainer:	Brett Pershing Stahlman <brettstahlman@comcast.net>
" License:	This file is placed in the public domain.

"echoerr "Sourcing ftplugin..."

" Let the common code know whether this is syntax file or ftplugin
let s:script_name = 'ftplugin'
" Function: s:Add_undo() <<<
" Purpose: Add the input string to the b:undo_ftplugin variable. (e.g., unmap
" commands, etc...)
" Return: none
" NOTE: This cannot be in common config, since it is called even when common
" config is being skipped for this script.
fu! s:Add_undo(s)
	if !exists('b:undo_ftplugin')
		let b:undo_ftplugin = ''
		let add_sep = 0
	elseif b:undo_ftplugin !~ '^\s*$'
		let add_sep = 1
	else
		let add_sep = 0
	endif
	let b:undo_ftplugin = b:undo_ftplugin.(add_sep!=0?'|':'').a:s
endfu
" >>>
" plugin load considerations <<<
" Important Note: I intentionally skip the standard check for
" exists("b:did_ftplugin") because I want to make it easy for txtfmt user to
" load txtfmt ftplugin after another ftplugin. The standard check would
" make this more difficult.
" NOTE: Vim bug? in ftplugin.vim will cause error if you set b:undo_ftplugin
" but not b:did_ftplugin.
" Yes. It is a bug. It's been fixed, but don't count on it, since we want it
" to work for version 6.3...
let b:did_ftplugin = 1
" Don't source the ftplugin again for same buffer, as it will cause errors due
" to <unique>. Note that this is important now that I've removed the check on
" b:did_ftplugin.
if exists("b:loaded_txtfmt")
	finish
endif
let b:loaded_txtfmt = 1
" Ensure that b:loaded_txtfmt is unlet whenever an ftplugin is about to be
" loaded.
" Note: Originally, I initialized b:undo_ftplugin to the empty string. The
" problem with doing so, however, is that it clobbers undo actions defined by
" a previously sourced ftplugin. Recall that txtfmt is designed to be used in
" combination with other filetypes (e.g., by using the dot-separated filetype
" name mechanism).
" Note: Don't unlet b:did_ftplugin, as standard ftplugin.vim does this
call s:Add_undo('unlet! b:loaded_txtfmt')
" >>>
" Set compatibility options <<<
" (set to Vim defaults to avoid errors with line continuation)
let s:save_cpo = &cpo
set cpo&vim
" >>>
" Common Configuration <<<
" Note: No point in having the modeline and/or global options processed by
" both the syntax and ftplugin files.
" IMPORTANT: Everything inside the "Common Configuration" fold should be
" identical between the syntax and ftplugin files. Keep in sync as changes are
" made...
if !exists('b:txtfmt_did_common_config')
	" Note: An unlet of b:txtfmt_did_common_config is intentionally NOT added
	" to b:undo_ftplugin. If it were unlet by b:undo_ftplugin, we would
	" generally do common configuration twice, since the standard setup will
	" source b:undo_ftplugin between the loading of syntax and filetype
	" plugins. In order for the mechanism to work properly,
	" b:txtfmt_did_common_config needs to be unlet before either syntax or
	" filetype plugin is loaded. There are currently several ways to get this
	" to happen: :e[dit], :b[delete], :Refresh
	let b:txtfmt_did_common_config = 1
	" Ensure that the code within plugin/txtfmt.vim will be executed when the
	" file is sourced.
	let b:txtfmt_do_common_config = 1
	" TODO - Should we ensure that warning occurs for missing file?
	runtime plugin/txtfmt.vim 
	" Make sure the common config doesn't run again
	unlet b:txtfmt_do_common_config

endif
" >>>
" Note on writing to b:undo_ftplugin <<<
" Regardless of who did the common config, it is ESSENTIAL that only the
" ftplugin write to b:undo_ftplugin, as ftplugin.vim function LoadFTPlugin()
" can run between sourcing of syntax file and sourcing of ftplugin file, and
" when it does, if b:undo_ftplugin exists, it will attempt to unlet both it
" and did_ftplugin. Problem is two-fold. Whatever syntax file has written to
" undo_ftplugin is lost, and worse, did_ftplugin may not exist at that point.
" If it does not, the "unlet" without the ! will generate error! Note: Bram
" said he would fix this in distributed version, but everyone will still have
" the old for awhile...
" >>>
" Script-local functions <<<
" Function: s:SID() <<<
" Purpose: Returns the SID number of this script. (help <SNR>)
" Note: This function is taken directly from the Vim help.
fu! s:SID()
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
endfu
" >>>
" Function: s:Prep_for_single_quotes() <<<
" Description: Double all single-quotes in the input string to prepare it for
" insertion within single quotes in a string that will be exec'ed. (:help
" literal-string)
fu! s:Prep_for_single_quotes(s)
	return substitute(a:s, "'", "''", 'g')
endfu
" >>>
" Function: s:Move_cursor() <<<
" Purpose: Move the cursor right or left (within the current line) by the
" specified number of characters positions. Note that character positions are
" not always the same as screen columns, and are certainly not always the same
" as byte positions.
" IMPORTANT NOTE: This function was designed to effect the cursor position
" offset specified by the '.' in a fmt/clr spec. Because of the way the
" offsets are calculated in the caller (Insert_tokstr), the raw offset may
" need to be adjusted by one character due to (for example) the impossibility
" of positioning cursor before BOL. The logic for doing this should be
" multi-byte aware. Although such logic could be implemented in this
" function's caller, there is no reason to have it in both functions. The
" logic in Insert_tokstr may be simplified if this function is made simply to
" move as far as possible on the current line in the specified direction, in
" cases in which the offset as specified is too large.
" Note: As a general rule, character positions correspond to screen columns;
" in some cases, however, a single character may occupy multiple screen
" columns (e.g. a tab). Also, there may be cases in which multiple characters
" occupy a single screen column (e.g. a base character followed by combining
" characters).
" Method: Begin moving in the specified direction a single byte at a time.
" Each time a byte position change results in a screen position change of *at
" least* one column, consider that we have moved by exactly one character.
" This strategy ensures that a tab will be considered a single character
" (unless 'virtualedit' is set), as will the combination of a base character
" and its associated combining characters. (Note, however, that such special
" cases should not generally be an issue because this function was designed to
" handle offsets in sequences of txtfmt tokens, which should not include tabs
" or combining characters.)
" Inputs:
" off			- Absolute value specifies number of character positions to
" 				move. Sign specifies the direction:
" 				pos. ==> right, neg. ==> left
" Return: The difference between the number of characters positions we were
" requested to move and the number of character positions we actually moved;
" i.e., zero indicates no problem executing the requested move.
" Error: Not possible. Since this function is used only internally,
" questionable inputs are silently converted to safe ones.
fu! s:Move_cursor(off)
	" Convert the signed offset that was input to a direction and magnitude.
	if a:off < 0
		let off = -a:off
		let inc = -1
	else
		let off = a:off
		let inc = 1
	endif
	" Are we moving rightward?
	if inc == 1
		" Determine the current mode, which determines the right-most valid
		" position on the line.
		let mode = mode()
		" Determine the last byte on which cursor may be positioned.
		" (In insert mode, cursor may be positioned just after the last byte.)
		let last_col = mode =~ 'i' ? virtcol('$') : virtcol('$') - 1
		"echomsg 'mode='.mode.' last_col='.last_col
	endif
	" Determine starting byte and screen column location.
	let col = col('.')
	let vcol_prev = virtcol('.')
	" Keep track of how many character positions we've moved.
	let moved = 0
	" Loop until we reach desired location
	while moved < off
		" Determine next byte position. (Next byte may or may not belong to a
		" different character.)
		let col = col + inc
		" Make sure we're not about to move too far.
		if inc == 1
			" Moving rightward
			if col > last_col
				" Can't move any further right!
				break
			endif
		else
			" Moving leftward
			if col < 1
				" Can't move any further left!
				break
			endif
		endif
		" Adjust cursor pos to new byte position
		call cursor(0, col)
		" Determine new virtual col
		let vcol = virtcol('.')
		" Has screen position changed since last time through?
		if vcol_prev != vcol
			let moved = moved + 1
		endif
		" Save the virtual column for next time
		let vcol_prev = vcol
	endwhile
	" Return the number of character positions *not* moved (usually 0)
	return off - moved
endfu
" >>>
" Function: s:Insert_tokstr() <<<
" Called_from: 'insert' or 'normal' mode mapping
" Purpose: Insert the fmt/clr token sequence specified by tokstr at the cursor
" location. Tokstr should be one of the following:
" -a literal (already translated) token sequence with offset prepended (just
"  as it would have been returned by s:Translate_fmt_clr_spec)
" -an untranslated fmt/clr spec.
" -empty string (in which case, user will be prompted to enter a fmt/clr spec)
" After any required translations, this function ensures that the token
" sequence is inserted into the buffer (at a location determined by 'cmd'
" argument). It accomplishes the token insertion in one of two ways, depending
" upon current mode:
" 'insert': Returns the token sequence to be inserted (since the assumption is
"           that this function has been invoked from an expression register
"           (<C-R>=)).
" 'normal': Uses the specified 'cmd' in conjunction with normal!.
" Originally, this function was also responsible for moving the cursor
" to the inter-token position indicated by the (optional) dot replacing one of
" the commas in the fmt/clr spec. This could be done only because all
" insertions (including ones from 'insert' mode) were accomplished within this
" function using normal! That implementation, however, (specifically, the
" use of normal! from within an insert-mode mapping) caused problems with
" respect to an active count applied to the preceding enter-insert command
" (the one that started the insert from which mapping was invoked). Thus, the
" cursor adjustment functionality has been moved to a separate function
" (s:Adjust_cursor), invoked from the mapping after this function has
" returned. Since the offset governing cursor adjustment is determined within
" this function, we use static variables s:Adjust_cursor_inv_off and
" s:Adjust_cursor_modestr to communicate the information to s:Adjust_cursor.
" Inputs:
" tokstr		- raw (un-translated) fmt/clr spec to insert. If empty, user
"				will be prompted for fmt/clr spec list.
" cmd			- [iIaAoOs] - Vim command used (conceptually, at least) to
" 				insert the token string. Note that in some cases, the current
" 				mode will determine how the tokens are actually inserted.
" literal		- nonzero if the input tokstr comprises an offset followed by
" 				the literal fmt/clr tokens; i.e., if it needs no translation.
" 				(This might be the case if this routine is called from a
" 				user-defined mapping.)
" 				Note: When this flag is set, the input tokstr should be in the
" 				form returned by s:Translate_fmt_clr_spec.
" end_in_norm	- nonzero if it is desired that we end up in normal mode after
" 				map completion. (Most 'insert-token' commands have an
" 				alternate form that causes this flag to be set)
" v:count1		If greater than 1 and mode is normal, indicates the count to
" 				be used with the normal mode command used to insert the
" 				tokens.
" 				Note: Used only when a:1 is not supplied.
" a:1			If supplied, represents the count to be used with the normal
" 				mode command that inserts the tokens. (Needed when this
" 				function is called from a user-map)
" Return: Depends upon mode from which we are called:
" 'insert': Returns the inserted string, since we have been called from an
" expression register (<C-R>=).
" 'normal': Returns an empty string.
" Error: Use echoerr with meaningful error message, as this function is
" generally invoked directly from mapping.
" Assumptions: Cursor position and mode unchanged from when map was invoked
" Vim trivia: col('.') and col('$') return 1 for empty line
fu! s:Insert_tokstr(tokstr, cmd, literal, end_in_norm, ...)
	" Declare modifiable version of input parameter
	let tokstr = a:tokstr
	" Ensure that if we return without inserting any tokens (i.e. because user
	" canceled the operation), s:Adjust_cursor will not attempt to do
	" anything.
	unlet! s:Adjust_cursor_inv_off
	unlet! s:Adjust_cursor_modestr
	" Assumption: If a:literal is true, input tokstr has already been
	" translated and validated by s:Translate_fmt_clr_spec, and in fact, is
	" exactly the string returned by that function; hence, validation will not
	" be performed here.
	if !a:literal
		if tokstr == ''
			" Prompt user for special fmt/clr spec string
			let tokstr = s:Prompt_fmt_clr_spec()
			" Strip surrounding whitespace, which is ignored.
			" Note: Only surrounding whitespace is ignored! Whitespace not
			" permitted within fmt/clr spec list.
			let tokstr = substitute(tokstr, '^\s*\(.\{-}\)\s*$', '\1', 'g')
			" Check for Cancel request
			if tokstr == ''
				" Note that nothing about position or mode has changed at this point
				return ''
			endif
		endif
		" Translate and validate fmt/clr spec
		let tokstr = s:Translate_fmt_clr_list(tokstr)
		if tokstr == ''
			" Invalid fmt/clr sequence
			echoerr "Insert_tokstr(): Invalid fmt/clr sequence entered: ".s:err_str
			" Note that nothing about position or mode has changed at this point
			return ''
		endif
	endif
	" At this point, we have a translated fmt/clr spec comprising an offset
	" followed by the actual fmt/clr token sequence. Extract the pieces from
	" the string (internally generated - no need for validation)
	let offset = substitute(tokstr, '\(\-\?[[:digit:]]\+\),\(.*\)', '\1', '')
	let tokstr = substitute(tokstr, '\(\-\?[[:digit:]]\+\),\(.*\)', '\2', '')
	" If user didn't specify offset, default is past inserted chars
	if offset < 0
		" Get length of tokstr, noting that it may contain multi-byte
		" tokens.
		let offset = strlen(substitute(tokstr, '.', 'x', 'g'))
	endif

	" Validate the command
	" Get cmd string in standard form (strip surrounding whitespace)
	" TODO - Perhaps this isn't necessary, since cmd is generated internally.
	let cmd = substitute(a:cmd, '^\s*\(.\{-}\)\s*$', '\1', '')
	if cmd !~ '^[iIaAoOs]$'
		echoerr 'Insert_tokstr(): Invalid insert token cmd string: '.cmd
		return ''
	endif
	" Validate current mode
	let modestr = mode()
	if modestr !~ '^[niR]$'
		echoerr "Insert_tokstr(): May be called only from 'normal' and 'insert' modes."
		return ''
	endif
	" Validation Complete!
	" Build start/end mode string for convenience in testing
	let modestr = modestr.(a:end_in_norm ? 'n' : 'i')
	" Calculate offset from end of tokstr (inverse offset)
	" a b c d e f
	"0 1 2 3 4 5 6	: offset
	"6 5 4 3 2 1 0	: inv_off
	" We'll need to know number of *characters* (not bytes) in tokstr
	let tokstrlen = strlen(substitute(tokstr, '.', 'x', 'g'))
	let inv_off = tokstrlen - offset
	" Make modestr and inv_off available for s:Adjust_cursor, which should run
	" immediately after this function returns.
	let s:Adjust_cursor_inv_off = inv_off
	let s:Adjust_cursor_modestr = modestr
	" Note on cursor positioning: <<<
	" -The normal! insert commands will result in cursor being positioned 'ON'
	"  the last char inserted, regardless of which mode we start in. (For
	"  commands ending in insert mode, this means insert position just before
	"  the last char inserted.)
	"  TODO - Explain why - help on normal explains how the incomplete
	"  command (in this case enter-insert) will be terminated with <Esc>.
	" -The 'stopinsert' used when starting in insert and ending in normal mode
	"  will cause cursor to move back one, if we were in insert mode when
	"  mapping was invoked.
	" -undo undoes everything in a 'normal' command as a unit, so we put the
	"  entire command for changing text into a single normal!. Note that since
	"  cursor movement commands are not part of undo mechanism, any necessary
	"  cursor adjustments may be made after the text change.
	" -When starting in normal and ending in insert mode, there are 2 cases:
	"  1) Last char inserted is end of line, so we must use startinsert! to
	" start insert and end up with cursor after last inserted char. (Can't
	" position cursor beyond it in normal mode.)
	"  2) Last char inserted is not at end of line. Could move right one, then
	"  use 'startinsert'.
	" >>>
	if modestr[0] == 'n'
		" Insert the tokens with the appropriate enter-insert command and
		" count. Originally, I thought that doing it this way, rather than
		" using explicit cursor() and setline() calls, made the insertions
		" repeatable with repeat command (.); unfortunately, however, the
		" repeat command works only for normal mode commands entered ON
		" COMMAND LINE! While I could go back to using setline() and cursor(),
		" the logic for simulating a particular type of enter insert command
		" ([iIaAoOs]) with an optional count argument is a bit simpler this
		" way.
		" Determine the effective count (either from optional input or
		" v:count1).
		if a:0 > 0
			" Note: Counts are generated internally; hence, validation has
			" been performed already.
			let l:count = a:1
		else
			let l:count = v:count1
		endif
		" IMPORTANT NOTE: <C-R><C-R>= works differently in actual normal mode
		" from the way it works when used in a normal command. Due to what I
		" would call a bug, but one which Bram has no intention of fixing due
		" to the complexity of the various segments of code that process the
		" strings, you cannot embed character nr2char(128) in a string literal
		" used in an expression register. This character is used in the gui to
		" introduce a special sequence, which results in termcap expansion of
		" some sort. The point is, since character 128 could be used as txtfmt
		" token, need another way to insert a string that could contain it.
		" Solution: use the actual string variable, rather than a string
		" literal. This is actually more intuitive anyways - I just wasn't
		" sure what the scope requirements were for variables used in
		" expression register - it works.
		exe 'normal! '.l:count.a:cmd."\<C-R>\<C-R>=l:tokstr\<CR>"
		"IMPORTANT: Return empty string so that default return of 0 is not
		"inserted by the "<C-R>=" used to invoke this function from insert
		"mode !
		return ''
	else
		" Return the token string to be inserted via expression register
		" (<C-R>=) in insert-mode mapping.
		return l:tokstr
	endif
endfu
" >>>
" Function: s:Adjust_cursor() <<<
" Purpose:
" Method:
" Inputs: (indirect, via script-local vars)
" s:Adjust_cursor_inv_off
" s:Adjust_cursor_modestr
" Return: Empty string (to permit the function to be called from an expression
" register)
" Error: Not possible. Since this function is used only internally,
" questionable inputs are silently converted to safe ones.
" Note: There is at least one scenario under which we must return empty string
" immediately (i.e., without performing any adjustment): it is the case in
" which user has canceled a token insertion. In this case, neither of the
" script-local input vars will exist.
fu! s:Adjust_cursor()
	if !exists('s:Adjust_cursor_modestr') || !exists('s:Adjust_cursor_inv_off')
		" It appears no adjustment is required
		return ''
	endif
	if s:Adjust_cursor_modestr == 'nn'
		" Cursor is on last inserted char now. Special care must be taken
		" to ensure that we don't attempt to set cursor before beginning of
		" line (inv_off == tokstrlen and first char inserted is first char on
		" line). Note that this insert type works as though the chars had been
		" inserted, offset implemented, then insert mode exited.
		" Extreme points:
		" inv_off==0			--> Position on last char inserted
		" inv_off==tokstrlen	--> Position before first char or on first
		"                           char if beginning of line.
		" Adjust cursor in multi-byte safe manner
		" Note: I am intentionally letting Move_cursor handle the special
		" case of cursor positioned at beginning of line. Move_cursor is
		" multi-byte safe and will not attempt to position the cursor before
		" the beginning of the line, even when inv_off requests it.
		call s:Move_cursor(-s:Adjust_cursor_inv_off)
	elseif s:Adjust_cursor_modestr == 'ni'
		" Cursor is on last inserted char now, but with an inv_off of 0,
		" needs to end up 1 col position right of last inserted char after
		" entering insert mode. There are 2 cases to consider...
		" *** Case 1 ***
		" New cursor position is past the end of the line.
		" In this case, we cannot use Move_cursor to accomplish the shift
		" because we are currently in normal mode, which precludes the setting
		" of cursor position past EOL. (Note: Calling startinsert prior to
		" Move_cursor doesn't work since, according to the Vim docs, "when
		" using this command in a function or script, the insertion only
		" starts after the function or script is finished.") Fortunately, we
		" can call startinsert! to enter insert mode and position the cursor
		" past the end of the line.
		" *** Case 2 ***
		" New cursor position is *NOT* past the end of the line.
		" Accomplish the required right shift simply by adjusting the value of
		" inv_off passed to Move_cursor. There is no way for Move_cursor
		" to fail to reach requested position in this case, since even in the
		" extreme case (inv_off == tokstrlen and tokens inserted at beginning
		" of line), the offset of 1 ensures we won't request a position before
		" BOL.
		if s:Move_cursor(-s:Adjust_cursor_inv_off + 1)
			" Move_cursor was unable to move past EOL.
			startinsert!
		else
			startinsert
		endif
	elseif s:Adjust_cursor_modestr == 'in'
		" Cursor is at col number of last inserted char + 1, which is where it
		" needs to be for inv_off==0. Stopinsert will shift it 1 char left.
		" Note that if inv_off==tokstrlen, cursor will end up to left of
		" inserted chars unless this would put it prior to beginning of line.
		call s:Move_cursor(-s:Adjust_cursor_inv_off)
		exe 'stopinsert'
	elseif s:Adjust_cursor_modestr == 'ii'
		" Cursor is at col number of last inserted char + 1, which is where it
		" needs to be for inv_off==0.
		" one beyond it (for inv_off==0). Note that since we're staying in
		" insert mode, positions before and after inserted chars are legal,
		" even when inserted char(s) are at beginning or end of line.
		call s:Move_cursor(-s:Adjust_cursor_inv_off)
	endif
	return ''
endfu
" >>>
" Function: s:Prompt_fmt_clr_spec() <<<
" Purpose: Prompt user for type of formatting region desired, and return
" the string entered
" How: The user will be prompted to enter a fmt/clr[/bgc] list, consisting of
" fmt/clr[/bgc] atoms separated by commas and/or dots. The format of a
" fmt/clr[/bgc] atom is described in header of Translate_fmt_clr_spec().,
" Return: The entered string
fu! s:Prompt_fmt_clr_spec()
	" Prompt the user for fmt/clr spec string
	" TODO: Decide whether prompt needs to distinguish between bgc and clr
	call inputsave()
	let str = input('Enter a fmt / clr string. (Enter to cancel): ')
	call inputrestore()
	return str
endfu
" >>>
" Function: s:Lookup_clr_namepat() <<<
" Purpose: Convert the input color name pattern to a color index in range
" 1..8, using the buffer-specific color definition array
" b:txtfmt_{clr|bgc}_namepat.
" Use b:txtfmt_cfg_{fg|bg}color{} arrays to determine whether the specified
" color is active.
" Return:
"     Requested color valid and active: Color index between 1 and 8
"     Requested color invalid: 0
"     Requested color valid but inactive: -1 * {color_index}
fu! s:Lookup_clr_namepat(typ, namepat)
	if a:typ == 'c'
		let fg_or_bg = 'fg'
		let clr_or_bgc = 'clr'
	elseif a:typ == 'k'
		let fg_or_bg = 'bg'
		let clr_or_bgc = 'bgc'
	else
		echoerr "Internal error - Unknown color type `".a:typ."' passed to Lookup_clr_namepat()"
		return 0
	endif
	" Loop over all color definitions (active and inactive), looking for one
	" whose regex matches input color name
	let i = 1
	while i < b:txtfmt_num_colors
		if a:namepat =~ b:txtfmt_{clr_or_bgc}_namepat{i}
			" We found a match!
			if b:txtfmt_cfg_{fg_or_bg}colormask[i - 1] != '1'
				" Inactive color
				return -1 * i
			else
				" Active color
				return i
			endif
		endif
		let i = i + 1
	endwhile
	" Didn't find it!
	return 0
endfu
" >>>
" Function: s:Translate_fmt_clr_spec() <<<
" Purpose: Convert the input fmt/clr spec string to the corresponding fmt/clr
" token.
" How: The input fmt/clr spec string will be in one of the following formats:
" "f-"
" "c-"
" "k-"                      if background colors are active
" "f[u][b][i][[s][r][[c]]]" Note that s, r and c values must be disallowed for
"                           certain permutations of b:txtfmt_cfg_longformats
"                           and b:txtfmt_cfg_undercurl
" "c<clr_patt>"
" "k<clr_patt>"             if background colors are active
" Note: <clr_patt> must match one of the color definitions specified by user
" (or default if user hasn't overriden).
" Note: Specification of an inactive color is considered to be an error.
" Return: One of the following:
" 1) A single fmt token
" 2) A single clr token
" 3) A single bgc token
" 4) '' - empty string if erroneous user entry
" Error: If error, function will set the script-local s:err_str
" Note: The function logic takes advantage of the fact that both strpart() and
" string offset bracket notation (s[i]) allow indices past end of string, in
" which case, they return empty strings.
fu! s:Translate_fmt_clr_spec(s)
	" Declare modifiable version of input parameter
	let s = a:s
	" Check for empty string (all whitespace considered empty string, as it
	" should have been detected as 'Cancel' request by caller).
	if s =~ '^\s*$'
		" Caller should validate this, but just in case
		let s:err_str = "Empty fmt/clr spec"
		return ''
	endif
	let len = strlen(s)
	let ret_str = ''
	if s[0] ==? 'f'
		" fmt string
		if s[1] == '-'
			if strlen(s) == 2
				" default format
				let ret_str = ret_str.nr2char(b:txtfmt_fmt_first_tok)
			else
				" Shouldn't be anything after f-
				let s:err_str = 'Unexpected chars after "f-"'
				return ''
			endif
		else
			" Not a default fmt request - remainder of string should match
			" [ubi[sr[c]]]
			let s = strpart(s, 1)
			if s =~ '[^'.b:ubisrc_fmt{b:txtfmt_num_formats-1}.']'
				" s contains illegal (but not necessarily invalid) char
				if s !~ '[^ubisrc]'
					" Illegal (but not invalid) char
					" User has mistakenly used s, r or c with one of the
					" 'short' formats or c with a version of Vim that doesn't
					" support undercurl. Give an appropriate warning.
					if !b:txtfmt_cfg_longformats
						let s:err_str = "Only 'u', 'b' and 'i' attributes are permitted when one of the 'short' formats is in effect"
					else
						" Long formats are in use; hence, we can get here only
						" if user attempted to use undercurl in version of Vim
						" that doesn't support it.
						let s:err_str = "Undercurl attribute supported only in Vim 7 or later"
					endif
				else
					let s:err_str = 'Invalid chars in fmt spec after "f"'
				endif
				return ''
			else
				" Convert the entered chars to a binary val used to get token
				" Note: Validation has already been performed; hence, we know
				" that s represents both a valid and active token.
				let bin_val = 0
				if s=~'u' | let bin_val = bin_val + 1 | endif
				if s=~'b' | let bin_val = bin_val + 2 | endif
				if s=~'i' | let bin_val = bin_val + 4 | endif
				if s=~'s' | let bin_val = bin_val + 8  | endif
				if s=~'r' | let bin_val = bin_val + 16 | endif
				if s=~'c' | let bin_val = bin_val + 32 | endif
				let ret_str = ret_str.nr2char(b:txtfmt_fmt_first_tok + bin_val)
			endif
		endif
	elseif s[0] ==? 'c' || s[0] ==? 'k'
		if s[0] ==? 'k' && !b:txtfmt_cfg_bgcolor
			" Oops! Background colors aren't active.
			let s:err_str = "The current 'tokrange' setting does not support background colors."
						\." (:help txtfmt-formats)"
			return ''
		endif
		" clr or bgc string
		if s[1] == '-'
			if strlen(s) == 2
				" default format
				let ret_str = ret_str.nr2char(
							\ s[0] ==? 'c'
								\ ? b:txtfmt_clr_first_tok
								\ : b:txtfmt_bgc_first_tok
				\)
			else
				" Shouldn't be anything after c- or k-
				let s:err_str = 'Unexpected chars after "'.s[0].'-"'
				return ''
			endif
		else
			" Not a default clr/bgc request - remainder of string denotes a
			" color
			let typ = s[0]
			let s = strpart(s, 1)
			" Determine which color index corresponds to color pattern
			let clr_ind = s:Lookup_clr_namepat(typ, s)
			if clr_ind == 0
				let s:err_str = "Invalid color name pattern: '".s."'"
				return ''
			elseif clr_ind < 0
				" TODO_BG: Make sure the help note below is still valid after
				" help has been updated.
				let s:err_str = "Color ".(-1 * clr_ind)." is not an active "
							\.(typ ==? 'c' ? "foreground" : "background")
							\." color. (:help "
							\.(typ ==? 'c' ? "txtfmtFgcolormask" : "txtfmtBgcolormask").")"
				return ''
			endif
			" IMPORTANT NOTE: clr_ind is 1-based index (1 corresponds to first
			" non-default color)
			let ret_str = ret_str.nr2char(
						\(typ ==? 'c'
							\ ? b:txtfmt_clr_first_tok
							\ : b:txtfmt_bgc_first_tok)
						\ + clr_ind)
		endif
	else
		let s:err_str = 'Invalid fmt/clr spec. Must begin with '
			\.(b:txtfmt_cfg_bgcolor ? '"f", "c" or "k"' : '"f" or "c"')
		return ''
	endif
	" Return the token as a string
	return ret_str
endfu
" >>>
" Function: s:Translate_fmt_clr_list() <<<
" Purpose: Translate the input comma/dot-separated list of fmt/clr/bgc spec
" atoms into a string of tokens suitable for insertion into the buffer.
" Validation is performed. Also, cursor offset into translated token string is
" determined based upon the presence of a dot (replaces comma when it appears
" between fmt/clr/bgc atoms - may also appear as first or last character in
" fmt/clr/bgc spec list).
" Input: Comma/Dot-separated list of fmt/clr/bgc spec atoms.
" Return: String of the following format:
" <offset>,<tokstr>
" Error: Return empty string and set s:err_str
" Warning: Set s:wrn_str
fu! s:Translate_fmt_clr_list(s)
	" For convenience
	let s = a:s
	let len = strlen(s)
	" Initializations <<<
	let offset = -1			" -1 means not explicitly set by user
	let offset_fixed = 0	" binary flag
	let i = 0
	let sep = ''			"[,.] or '' for end-of string
	let num_fld = 0			" # of atoms encountered
	let tokstr = ''			" built up in loop
	" >>>
	" Process the fmt/clr/bgc spec atom(s) in a loop
	while i < len
		" Find end of spec ([,.] or end of string)
		" (Commas and dots not allowed except as field sep)
		" NOTE: Match with '$' returns strlen (even for empty string)
		let ie = match(s, '[,.]\|$', i)
		" Extract field sep and text
		let sep = ie<len ? s[ie] : ''
		" TODO - See about consolidating the if's below...
		if ie>i
			let fld = strpart(s, i, ie-i)
			let num_fld = num_fld+1
			" Translate field if non-empty
			let tok = s:Translate_fmt_clr_spec(fld)
			if tok == ''
				" Must have been error
				let s:err_str = "Invalid fmt/clr spec: '".fld."': ".s:err_str
				return ''
			endif
			let tokstr = tokstr.tok
		" Validate the field in various ways
		elseif i==ie	" check null fields
			let fld = ''
			if ie==0	" at beginning of list ('.' permitted)
				if ie==len-1
					let s:err_str = "Separator with nothing to separate"
					return ''
				elseif len==0
					" Note: This should probably be checked before now, but
					" just to be complete...
					let s:err_str = "Invalid empty fmt/clr spec list"
					return ''
				elseif sep=='.'
					let offset = 0
				else
					let s:err_str = "Invalid leading ',' in fmt/clr spec list"
					return ''
				endif
			else	" not at beginning of list
				let s:err_str = "Empty field encountered at '".strpart(s, i)
				return ''
			endif
		endif
		if ie==len-1	" validate last char in string
			if num_fld==0
				" NOTE: Can't actually get here...
				let s:err_str = "fmt/clr spec list contains no fields"
				return ''
			elseif sep!='.'
				let s:err_str = "Trailing comma not allowed in fmt/clr spec list"
				return ''
			endif
		endif
		" If here, field is OK unless atom is bad...
		" Do offset logic
		if offset==-1 && sep=='.'
			let offset = num_fld
		endif
		" Update for next iteration
		let i = ie+1
		if i > len
			break
		endif
		" OLD (implicit) logic for determining cursor offset <<<
		" TODO_BG: Get rid of this...
		"if tok=~b:re_fmt_any_stok || tok=~b:re_fmt_etok
		"	if fmt_begun
		"		" Fix cursor location (if not already fixed)
		"		if offset==0
		"			let offset = num_fld-1
		"		endif
		"	endif
		"	" If fmt start tok, set flag
		"	if tok!~b:re_fmt_etok
		"		let fmt_begun = 1
		"	endif
		"elseif tok=~b:re_clr_any_stok || tok=~b:re_clr_etok
		"	if clr_begun
		"		" Fix cursor location (if not already fixed)
		"		if offset==0
		"			let offset = num_fld-1
		"		endif
		"	endif
		"	" If clr start tok, set flag
		"	if tok!~b:re_clr_etok
		"		let clr_begun = 1
		"	endif
		"endif
		" >>>
	endwhile
	" Return the special format string
	return offset.','.tokstr
endfu
" >>>
" Function: s:Jump_to_tok() <<<
" Purpose: Jumps forward or backwards (as determined by a:dir), to the
" v:count1'th nearest token of type given by a:type ('c'=clr 'k'=bgc 'f'=fmt
" 'a'=any (clr, bgc or fmt)). If 'till' argument is nonzero, jump will
" position cursor one char position closer to starting location than the
" sought token. (This behavior is analogous to t and T normal mode commands.)
" Note: If the map that invokes this function is a visual-mode mapping,
" special logic is required to restore the visual selection prior to
" performing any cursor movement. This is because Vim's default vmap behavior
" is to remove the visual highlighting and position the cursor at the start of
" the visual area as soon as the map is invoked. For the motion mappings that
" call this function, the default behavior is not acceptable.
" Inputs:
" type		1 or 2 chars indicating the type of token sought. Format is as
" 			follows:
" 			[{target-modifier}]{target-type}
"	 			{target-modifier} :=
"	 				b	'begin region' tokens only
"	 				e	'end region' tokens only
"	 			{target-type}
"	 				c = fg color, k = bg color, f = format,
"	 				a = fg color, bg color, or format
" dir		single char indicating direction for search (f=forward, b=back).
" 			Wrap behavior is determined by the 'wrapscan' option.
" till		If nonzero, jump lands cursor not on the token, but just 'before'
"			it (where before indicates the side closest to starting point).
"			'Till' is used because of analogy with Vim's t and T commands in
"			normal mode.
" v:count1	If greater than 1, indicates the number of jumps to be performed.
" 			Allows a count to be used with the invoking mapping when jumping
" 			to the N'th token of a particular type and in a particular
" 			direction is desired.
" a:1		If supplied, represents the count to be used. (Needed when this
"			function is called from a user-map)
" Return: Always return empty string, in case function is called from an
" expression register in insert mode.
" IMPORTANT NOTE: On the use of \%# atom -- When used in search() (i.e.,
" non-interactively), Vim appears to use lookahead to optimize when using
" \%#\@!; however, a '\%#' by itself, or followed by \@=, is NOT optimized.
" (Vim searches the entire file with wraparound before finding the cursor
" position!)
" NOTE: Ideally, if the 'till' flag is set for a backwards search, I would use
" the /e modifier with a ? search begun from normal mode to find the token and
" position the cursor on the character after it. (If token is last char on
" line, cursor would be positioned in first column of following line.)
" However, this can cause problems when tok range includes char code 128. This
" problem can be avoided if search() is used. Unfortunately, search() does not
" permit the /e modifier to be used (and \zs and/or \ze appear to be a bit
" buggy when used just after a newline - e.g., try /\n\zs/ and see what
" happens!). Thus, my strategy for finding the target location when the 'till'
" flag is set is to use search() to find the sought token, employing patterns
" that will match only if the 'till' destination location actually exists. If
" search() finds a valid destination, I then accomplish the 'till' move with a
" subsequent positioning command.
fu! s:Jump_to_tok(mode, type, dir, till, ...)
	" Determine whether we jump only to active tokens
	" By default, we don't.
	let jtin = exists('b:txtfmtJumptoinactive')
				\ ? b:txtfmtJumptoinactive
				\ : exists('g:txtfmtJumptoinactive')
				\   ? g:txtfmtJumptoinactive
				\   : 0 
	" Get the search pattern
	" Design Decision Needed: Decide whether to permit inactive color tokens
	" to serve as target of jump. If this is desired, perhaps create special
	" b:txtfmt_re_CLR_<...> and b:txtfmt_re_BGC_<...> regexes. Alternatively,
	" use the b:re_no_self_esc and b:re_no_bslash_esc patterns on the
	" <...>_atom regexes.
	" Note: Let jumptoinactive option determine whether inactive tokens can
	" serve as jump targets.
	if a:type == 'c'
		let re = b:txtfmt_re_{jtin ? 'CLR' : 'clr'}_tok
	elseif a:type == 'bc'
		let re = b:txtfmt_re_{jtin ? 'CLR' : 'clr'}_stok
	elseif a:type == 'ec'
		let re = b:txtfmt_re_{jtin ? 'CLR' : 'clr'}_etok
	elseif a:type == 'k'
		let re = b:txtfmt_re_{jtin ? 'BGC' : 'bgc'}_tok
	elseif a:type == 'bk'
		let re = b:txtfmt_re_{jtin ? 'BGC' : 'bgc'}_stok
	elseif a:type == 'ek'
		let re = b:txtfmt_re_{jtin ? 'BGC' : 'bgc'}_etok
	elseif a:type == 'f'
		let re = b:txtfmt_re_fmt_tok
	elseif a:type == 'bf'
		let re = b:txtfmt_re_fmt_stok
	elseif a:type == 'ef'
		let re = b:txtfmt_re_fmt_etok
	elseif a:type == 'a'
		let re = b:txtfmt_re_{jtin ? 'ANY' : 'any'}_tok
	elseif a:type == 'ba'
		let re = b:txtfmt_re_{jtin ? 'ANY' : 'any'}_stok
	elseif a:type == 'ea'
		let re = b:txtfmt_re_{jtin ? 'ANY' : 'any'}_etok
	else
		" Error - shouldn't ever get here - just return
		return ''
	endif
	" Important Note: If mode is visual, Vim has already removed the visual
	" highlighting and positioned the cursor at the start of the visual
	" region. Since this is a motion mapping, we need to undo this; i.e.,
	" restore the visual highlighting and put the cursor at the correct
	" end/corner of the visual region, allowing for the fact that any number
	" of "o" and or "O" commands may have been executed to bounce the cursor
	" between ends/corners... Normal mode gv fits the bill.
	" Important Note: When a visual mode mapping invokes this function, Vim
	" has already changed mode to normal before we get here. Thus, we must use
	" the mode string passed from the mapping to determine whether we need to
	" restore the visual selection. Since we're using gv, it doesn't matter
	" which visual sub-mode was in effect.
	if a:mode == 'v'
		normal! gv
	endif
	" Get the search options
	if a:dir == 'b'
		" Leave wrap option alone so that 'wrapscan' will be honored
		let opt = 'b'
		if a:till
			" NOTE: The \n\_. handles the following 2 cases:
			" 1) Sought token is at end of line followed by non-empty line
			" 2) Sought token is at end of line followed by empty line
			" NOTE: The \%#\@! ensures that if we're sitting on a character
			" after the the target token type, we don't match the token just
			" before it. (Otherwise we'd get stuck when trying to do multiple
			" successive backwards jumps.)
			let re = re.'\%(\n\%#\@!\_.\|\%#\@!.\)\@='
		endif
	elseif a:dir == 'f'
		" Leave wrap option alone so that 'wrapscan' will be honored
		let opt = ''
		if a:till
			" The following pattern will position us on the buffer position
			" one char prior to the sought token, even in case where the token
			" is at beginning of a line preceded by blank line.
			" NOTE: landing on a \n puts cursor at end of line ended by the
			" newline.
			" NOTE: \@= is necessary when cpo-c is set to avoid skipping every
			" other token when there are multiple consecutive tokens of same
			" type.
			let re = '\_.'.re.'\@='
		endif
	else
		" Error - Should never get here - just return
		return ''
	endif
	" Get the count, which is either supplied explicitly as optional extra
	" arg, or is obtained from v:count1
	if a:0 > 0
		" Note: Counts are generated internally; hence, validation has
		" been performed already.
		let l:count = a:1
	else
		let l:count = v:count1
	endif
	" In a loop count, perform the search()
	let i = 0
	while i < l:count
		" Note: If search fails, cursor will not be moved.
		" IMPORTANT NOTE: Simplest thing would be to use normal search command
		" here, but that gives problems if tok range includes 128!
		let l2 = search(re, opt)
		" Did we find the sought token?
		if l2 > 0
			" We're on found tok
			if a:till
				" NOTE: 2 cases:
				" 1) Backward search - we're on token, but we need to be at
				" position just past it (and search() assures us the position
				" exists.
				" 2) Forward search - search() got us to correct position (for
				" both 'till' and non-'till' cases.
				if a:dir == 'b'
					" Backward search
					" IMPORTANT NOTE: Original implementation used col() and
					" cursor(), which are *NOT* multi-byte safe!
					" Use virtcol and special search instead.
					" Note: Vim documentation implies that the following holds
					" true when cursor is positioned on the last character of
					" the line: virtcol('.') == virtcol('$') - 1
					let c2 = virtcol('.')
					if c2 != virtcol('$') - 1
						" Not last char on line
						call search('\%'.(c2 + 1).'v', '')
					else
						" Last char on line - move to start of next line
						" Note: cursor() can handle col of 1 even for empty
						" line.  Also, it's mult-byte safe.
						call cursor(l2 + 1, 1)
					endif
				endif
			endif
		else
			" No reason to keep looping...
			break
		endif
		let i = i + 1
	endwhile
	return ''
endfu
" >>>
" Function: s:Mapwarn_check() <<<
" Purpose: Determine whether the user has already been warned about the
" mapping ambiguity/conflict indicated by input arguments, and return nonzero
" if so. Additionally, if the 'add' parameter is true, record the input
" conflict/ambiguity in the data structures maintaining such information so
" that the function will return true for it next time.
" Inputs:
" lhs  - lhs of the new mapping
" rhs  - rhs of the old (existing) mapping
" mode - single character indicating the mode of the mapping (e.g. n=normal,
"        v=visual, i=insert, o=operator-pending, etc...)
" add  - flag indicating whether the conflict indicated by lhs, rhs and mode
"        should be added to the data structures searched by this function
fu! s:Mapwarn_check(lhs, rhs, mode, add)
	let found = 0
	let i = 0
	if exists('g:txtfmt_mapwarn_cnt')
		while i < g:txtfmt_mapwarn_cnt
			if a:lhs == g:txtfmt_mapwarn_lhs{i} &&
				\ a:rhs == g:txtfmt_mapwarn_rhs{i} &&
				\ a:mode == g:txtfmt_mapwarn_mode{i}
				let found = 1
				break
			endif
			let i = i + 1
		endwhile
	endif
	if !found && a:add
		" Make sure g:txtfmt_mapwarn_cnt is self-starting
		if !exists('g:txtfmt_mapwarn_cnt')
			let g:txtfmt_mapwarn_cnt = 0
		endif
		" Add a new conflict/ambiguity to the arrays
		let g:txtfmt_mapwarn_lhs{g:txtfmt_mapwarn_cnt} = a:lhs
		let g:txtfmt_mapwarn_rhs{g:txtfmt_mapwarn_cnt} = a:rhs
		let g:txtfmt_mapwarn_mode{g:txtfmt_mapwarn_cnt} = a:mode
		let g:txtfmt_mapwarn_cnt = g:txtfmt_mapwarn_cnt + 1
	endif
	" Indicate whether input conflict/ambiguity was found
	return found
endfu
" >>>
" Function: s:Undef_map() <<<
" Purpose: Creates an undo action for the map whose lhs, rhs and unmap_cmd are
" input, and adds the undo action to b:undo_ftplugin.
" Inputs:
" mode 	- single char, used as input to maparg, mapcheck, etc...
" lhs   - string representing the lhs of the map to be undone
" rhs   - string representing the rhs of the map to be undone.
" Assumptions:
" -All maps to be undone are buffer-local.
" -All occurrences of '<SID>[_a-zA-Z0-9]' in the rhs of a mapping defined by
"  this plugin represent a call to a script-local function.
" Note: rhs is required so that we can be sure to delete *only* maps created
" by this plugin. (Consider that user could either intentionally or
" inadvertently override one of the txtfmt maps with a completely unrelated
" map after this plugin is loaded. For this reason, we cannot (or should not)
" blindly delete lhs.)
fu! s:Undef_map(lhs, rhs, mode)
	" Determine the unmap command to be used.
	if a:mode=='n'
		let unmap_cmd = 'nunmap'
	elseif a:mode=='i'
		let unmap_cmd = 'iunmap'
	elseif a:mode=='o'
		let unmap_cmd = 'ounmap'
	elseif a:mode=='v'
		let unmap_cmd = 'vunmap'
	else
		echoerr 'Internal error - unsupported mapmode passed to Undef_map()'
		return 1
	endif
	" Create the undo action, taking special care to avoid deleting a map with
	" the same lhs, created by user after the sourcing of this plugin.
	" Note: Prep_for_single_quotes ensures that single quotes contained in lhs
	" or rhs are properly escaped before being wrapped in the single-quoted
	" string that will be parsed when b:undo_ftplugin is exec'ed.
	" Note: Be sure not to add whitespace between the lhs of the map being
	" unmapped and the subsequent '|' as this will result in nonexistent
	" mapping error.
	" Note: When the maparg() is executed, it will return function names of
	" the form '<SNR>{number}_func' rather than '<SID>func'. Thus, to ensure
	" that the delayed comparison works properly, I need to convert a:rhs to
	" the <SNR>{number}_ form now.
	let rhs = substitute(a:rhs, '<SID>\ze[_a-zA-Z0-9]',
		\'\= "<SNR>" . s:SID() . "_"', 'g')
	call s:Add_undo("if maparg('".s:Prep_for_single_quotes(a:lhs)
		\."', '".a:mode."') == '".s:Prep_for_single_quotes(rhs)."' | "
		\.unmap_cmd." <buffer> ".a:lhs."| endif")
endfu
" >>>
" Function: s:Def_map() <<<
" Purpose: Define both the level 1 and level 2 map as appropriate.
" Inputs:
" mode 	- single char, used as input to maparg, mapcheck, etc...
" lhs1	- lhs of first-level map
" lhs2	- rhs of first-level map, lhs of second-level map
" rhs2	- rhs of second-level map
" How: Consider whether user already has a map to level 2 (which should take
" precedence over maplevel 1). Also, make sure the map from level 2, if it
" exists, is not incorrect, etc...
" Note: Cause b:undo_ftplugin to be updated so that whatever mappings are made
" by us will be unmapped when ftplugin is unloaded.
" Return:
" 0			- success
" nonzero	- error
" NOTE: Function will echoerr to user
fu! s:Def_map(mode, lhs1, lhs2, rhs2)
	" TODO - Perhaps eventually support operator mode if needed
	if a:mode=='n'
		let cmd1 = 'nmap'
		let cmd2 = 'nnoremap'
	elseif a:mode=='i'
		let cmd1 = 'imap'
		let cmd2 = 'inoremap'
	elseif a:mode=='o'
		let cmd1 = 'omap'
		let cmd2 = 'onoremap'
	elseif a:mode=='v'
		let cmd1 = 'vmap'
		let cmd2 = 'vnoremap'
	else
		echoerr 'Internal error - unsupported mapmode passed to Def_map()'
		return 1
	endif
	" Do first map level <<<
	if !hasmapto(a:lhs2, a:mode)
		" User hasn't overridden the default level 1 mapping
		" Make sure there's no conflict or ambiguity between an existing map
		" and the default one we plan to add...
		let oldarg = maparg(a:lhs1, a:mode)
		let oldchk = mapcheck(a:lhs1, a:mode)
		" Check for conflicts and ambiguities, decoding applicable portions of
		" mapwarn option character flag string into more immediately useful
		" variables, to avoid messy ternaries in the subsequent logic.
		" Note: Create only the variables that will be used.
		if oldarg != ''
			" Map conflict
			let l:problem = 'c'
			if b:txtfmt_cfg_mapwarn =~ 'M'
				let l:msg_or_err = 'm'
			elseif b:txtfmt_cfg_mapwarn =~ 'E'
				let l:msg_or_err = 'e'
			endif
			if exists('l:msg_or_err')
				let l:once_only = b:txtfmt_cfg_mapwarn =~ 'O'
			endif
			let l:create = b:txtfmt_cfg_mapwarn =~ 'C'
			let l:old_rhs = oldarg
		elseif oldchk != ''
			" Map ambiguity
			let l:problem = 'a'
			if b:txtfmt_cfg_mapwarn =~ 'm'
				let l:msg_or_err = 'm'
			elseif b:txtfmt_cfg_mapwarn =~ 'e'
				let l:msg_or_err = 'e'
			endif
			if exists('l:msg_or_err')
				let l:once_only = b:txtfmt_cfg_mapwarn =~ 'o'
			endif
			let l:create = b:txtfmt_cfg_mapwarn =~ 'c'
			let l:old_rhs = oldchk
		endif
		if exists('l:problem')
			" There's an ambiguity or conflict
			if exists('l:msg_or_err')
				" We need to warn unless warning is precluded by 'once-only'
				" mechanism
				if !l:once_only || !s:Mapwarn_check(a:lhs1, l:old_rhs, a:mode, l:once_only)
					let l:warnstr = 'Level 1 map '
						\.(l:problem == 'a' ? 'ambiguity:' : 'conflict: ')
						\.a:lhs1.' already mapped to '.l:old_rhs
					if l:msg_or_err == 'm'
						echomsg l:warnstr
					else
						echoerr l:warnstr
					endif
				endif
			endif
		endif
		" Do the map for buffer unless map creation is precluded by conflict
		" or ambiguity in absence of the 'create' flag.
		" Note: Do not use <unique> attribute, since that would cause Vim to
		" display error, due to the original mapping.
		if !exists('l:problem') || l:create
			exe cmd1.' <buffer> '.a:lhs1.' '.a:lhs2
			" Create undo action for the map just created
			call s:Undef_map(a:lhs1, a:lhs2, a:mode)
		endif
	else
		"echomsg "Skipping 1st level"
	endif
	" >>>
	" Do second map level <<<
	" Assumption: Second-level mappings have long <Scriptname><...> names,
	" preceded by <Plug>. It is safe to assume user hasn't mapped one to
	" something else...
	exe cmd2.' <silent> <buffer> '.a:lhs2.' '.a:rhs2
	" Create undo action for the map just created
	call s:Undef_map(a:lhs2, a:rhs2, a:mode)
	" >>>
	" Success
	return 0
endfu
" >>>
" Function: s:MakeString() <<<
" Purpose: Build and return a string by concatenating a base string some
" number of times to itself.
" Inputs:
" str	-base string, which will be concatenated to itself
" len	-# of occurrences of 'str' to put in the return string
" Return: The generated string
fu! s:MakeString(str, len)
	let s = ''
	let i = 0
	while i < a:len
		let s = s.a:str
		let i = i + 1
	endwhile
	return s
endfu
" >>>
" Function: s:ShowTokenMap() <<<
" Purpose: Echo to user a table showing the current use of all tokens in the
" range of fmt/clr tokens.
" How: Use echo, as this is intended as a temporary showing for informational
" purposes only. Highlighting of column headers is accomplished via echohl
" Format: Should be something like the sample table shown below...
" Note: char-nr should use the number format indicated by
" b:txtfmt_cfg_starttok_display.
" Note: For inactive colors, an asterisk will be prepended to char-nr, and
" '(inactive)' will be appended to the description. In order to keep the
" numbers aligned properly, active colors will have a space prepended to the
" char-nr.
" TODO: Decide whether it's necessary to wrap inactive char-nr's in parens. If
" not, get rid of it.
"=== [FG] COLORS ===
"char-nr   description        clr-pattern                                clr-def
"180       no color           -
"181       Color0             ^\\%(k\\|bla\\%[ck]\\)$,c:Black,g:#000000  #000000
"182       Color1             ^blu\\%[e]$,c:DarkBlue,g:#0000FF           #0000FF
"183       Color2             ^g\\%[reen]$,c:DarkGreen,g:#00FF00         #00FF00
".
".
"=== FORMAT ===
"char-nr   description        spec
"189       no format          -
"190       italic             i
"191       bold               b
"192       bold,italic        bi
".
".
".
".
" Important Note: The subsequent lines will be output if and only if
" background colors are enabled.
"=== BG COLORS ===
"char-nr   description        clr-pattern                                clr-def
" 197      no color           -
"*198      Color0 (inactive)  ^\\%(k\\|bla\\%[ck]\\)$,c:Black,g:#000000  #000000
" 199      Color1             ^blu\\%[e]$,c:DarkBlue,g:#0000FF           #0000FF
" 200      Color2             ^g\\%[reen]$,c:DarkGreen,g:#00FF00         #00FF00
" .
" .
fu! s:ShowTokenMap()
	" Loop 2 times - first time is just to calculate column widths
	let cw1 = 0 | let cw2 = 0 | let cw3 = 0 | let cw4 = 0
	" Define an array, indexed by fgbg_idx, which may be used to build fg/bg
	" specific var names.
	let clr_or_bgc{0} = 'clr'
	let clr_or_bgc{1} = 'bgc'
	" Initialize the vars that will accumulate table text
	let fmt_header = '' | let fmt_lines = ''
	let clr_header = '' | let clr_lines = ''
	let bgc_header = '' | let bgc_lines = ''
	" Determine number format to use for char-nr column
	let use_hex = strpart(b:txtfmt_cfg_starttok_display, 0, 2) == '0x'
	let i = 0
	while i < 2
		" Loop over all format lines (1 hdr and b:txtfmt_num_formats-1 fmt)
		let iFmt = -1	" start with header line
		while iFmt < b:txtfmt_num_formats
			let line = ''	" Initialize text for current line
			" Column 1
			if iFmt == -1
				let col1_text = ' char-nr'
			else
				let col1_text = b:txtfmt_fmt_first_tok + iFmt
				if use_hex
					" Convert to hex
					let col1_text = TxtfmtUtil_num_to_hex_str(col1_text)
				endif
				" Prepend space for alignment
				let col1_text = ' ' . col1_text
			endif
			if i == 0
				" Calculate col width
				if strlen(col1_text) > cw1
					let cw1 = strlen(col1_text)
				endif
			else
				" Output line
				let line = line.(col1_text.s:MakeString(' ', cw1 + 2 - strlen(col1_text)))
			endif
			" Column 2
			if iFmt == -1
				let col2_text = 'description'
			elseif iFmt == 0
				let col2_text = 'no format'
			else
				let col2_text = b:txtfmt_fmt{iFmt}
			endif
			if i == 0
				" Calculate col width
				if strlen(col2_text) > cw2
					let cw2 = strlen(col2_text)
				endif
			else
				" Output line
				let line = line.(col2_text.s:MakeString(' ', cw2 + 2 - strlen(col2_text)))
			endif
			" Column 3
			if iFmt == -1
				let col3_text = 'fmt-spec'
			elseif iFmt == 0
				let col3_text = '-'
			else
				let col3_text = b:ubisrc_fmt{iFmt}
			endif
			if i == 0
				" Calculate col width
				if strlen(col3_text) > cw3
					let cw3 = strlen(col3_text)
				endif
			else
				" Output line
				let line = line.(col3_text.s:MakeString(' ', cw3 + 2 - strlen(col3_text)))
			endif
			" Accumulate line just built into the list of lines
			if i == 1
				if iFmt == -1
					" Store header line separately so that echohl can be used
					let fmt_header = line
				else
					" Regular row in table (non-header)
					let fmt_lines = fmt_lines.(iFmt==0?'':"\<NL>").line
				endif
			endif
			let iFmt = iFmt + 1
		endwhile
		" Loop over fg colors and (if necessary) bg colors
		let fgbg_idx = 0
		while fgbg_idx < (b:txtfmt_cfg_bgcolor ? 2 : 1)
			if fgbg_idx == 0
				let first_tok = b:txtfmt_clr_first_tok
				let colormask = b:txtfmt_cfg_fgcolormask
			else
				let first_tok = b:txtfmt_bgc_first_tok
				let colormask = b:txtfmt_cfg_bgcolormask
			endif
			" Loop over all color tokens (even inactive ones)
			" Index note: In this loop, index 0 refers to 'no color', while index
			" 1 refers to txtfmtColor{1} (default rgb=0x000000).
			let iClr = -1
			while iClr < b:txtfmt_num_colors
				let line = ''	" Initialize text for current line
				" Column 1
				if iClr == -1
					let col1_text = ' char-nr'
				else
					if iClr >= 0
						let col1_text = (first_tok + iClr)
						if use_hex
							" Convert to hex
							let col1_text = TxtfmtUtil_num_to_hex_str(col1_text)
						endif
						" If color is inactive, prepend char-nr with asterisk
						if iClr > 0 && strpart(colormask, iClr - 1, 1) != '1'
							" This color is inactive
							let col1_text = '*' . col1_text
						else
							" Prepend space for alignment
							let col1_text = ' ' . col1_text
						endif
					endif
				endif
				if i == 0
					" Calculate col width
					if strlen(col1_text) > cw1
						let cw1 = strlen(col1_text)
					endif
				else
					" Output line
					let line = line.(col1_text.s:MakeString(' ', cw1 + 2 - strlen(col1_text)))
				endif
				" Column 2
				if iClr == -1
					let col2_text = 'description'
				elseif iClr == 0
					let col2_text = 'no color'
				else
					let col2_text = 'Color'.iClr
					if strpart(colormask, iClr - 1, 1) != '1'
						let col2_text = col2_text . ' (inactive)'
					endif
				endif
				if i == 0
					" Calculate col width
					if strlen(col2_text) > cw2
						let cw2 = strlen(col2_text)
					endif
				else
					" Output line
					let line = line.(col2_text.s:MakeString(' ', cw2 + 2 - strlen(col2_text)))
				endif
				" Column 3
				if iClr == -1
					let col3_text = 'clr-pattern'
				elseif iClr == 0
					let col3_text = '-'
				else
					let col3_text = b:txtfmt_{clr_or_bgc{fgbg_idx}}_namepat{iClr}
				endif
				if i == 0
					" Calculate col width
					if strlen(col3_text) > cw3
						let cw3 = strlen(col3_text)
					endif
				else
					" Output line
					let line = line.(col3_text.s:MakeString(' ', cw3 + 2 - strlen(col3_text)))
				endif
				" Column 4
				if iClr == -1
					let col4_text = 'clr-def'
				elseif iClr == 0
					let col4_text = 'N.A.'
				else
					let col4_text = b:txtfmt_{clr_or_bgc{fgbg_idx}}{iClr}
				endif
				if i == 0
					" Calculate col width
					if strlen(col4_text) > cw4
						let cw4 = strlen(col4_text)
					endif
				else
					" Output line
					let line = line.(col4_text.s:MakeString(' ', cw4 + 2 - strlen(col4_text)))
				endif
				" Accumulate line just built into the list of lines
				if i == 1
					if iClr == -1
						" Store header line separately so that echohl can be used
						if fgbg_idx == 0
							let clr_header = line
						else
							let bgc_header = line
						endif
					else
						" Regular row in table (non-header)
						if fgbg_idx == 0
							let clr_lines = clr_lines.(iClr==0?'':"\<NL>").line
						else
							let bgc_lines = bgc_lines.(iClr==0?'':"\<NL>").line
						endif
					endif
				endif
				let iClr = iClr + 1
			endwhile
			let fgbg_idx = fgbg_idx + 1
		endwhile
		let i = i + 1
	endwhile
	echohl Title
	echo b:txtfmt_cfg_bgcolor ? ' === FG COLORS ===' : ' === COLORS ==='
	echo clr_header
	echohl None
	echo clr_lines
	echohl Title
	echo ' === FORMAT ==='
	echo fmt_header
	echohl None
	echo fmt_lines
	" If bg colors are not active, we're done
	if b:txtfmt_cfg_bgcolor
		echohl Title
		echo ' === BG COLORS ==='
		echo bgc_header
		echohl None
		echo bgc_lines
	endif
endfu
" >>>
" Function: s:MoveStartTok() <<<
" IMPORTANT NOTE: Special care must be taken when defining this function, as
" it invokes :Refresh command, which causes the script to be re-sourced. This
" leads to E127 'Cannot redefine function' when fu[!] is encountered, since
" the function is in the process of executing.
if !exists('*s:MoveStartTok')
fu! s:MoveStartTok(moveto, ...)
	if a:0
		" Validate and process optional version value
		if a:0 != 1
			echoerr 'Incorrect # of arguments supplied to :MoveStartTok (1 or 2 expected)'
			return
		elseif (0 + a:1) =~ '^[1-9][0-9]\{2}$'
			" Use version supplied by user
			let old_ver = a:1
		else
			echoerr a:1.' is not a valid Vim version number. Should be same format as v:version'
			return
		endif
	else
		" Assume current version
		let old_ver = v:version
	endif
	" Validate the new starttok
	if a:moveto !~ '^\s*'.b:txtfmt_re_number_atom.'\s*$'
		echoerr "Invalid 'starttok' value supplied: `".a:moveto."'"
		return
	endif
	" Get current settings from buffer-local vars
	" Assumption: This function can be invoked only from an active txtfmt
	" buffer
	let old_starttok = b:txtfmt_cfg_starttok
	" Determine new settings
	let new_starttok = a:moveto
	" Determine amount of shift (signed value)
	let l:offset = new_starttok - old_starttok
	
	" Before proceeding, cache 'effective' values for bgcolor, longformats and
	" undercurl. Note that 'effective' values are those that would be in
	" effect if current Vim version were old_ver. Note that effective
	" undercurl may differ from b:txtfmt_cfg_undercurl.
	let bgcolor = b:txtfmt_cfg_bgcolor
	let longformats = b:txtfmt_cfg_longformats
	if old_ver != v:version
		" Effective undercurl could differ from b:txtfmt_cfg_undercurl
		if b:txtfmt_cfg_undercurlpref && old_ver >= b:txtfmt_const_vimver_undercurl
			" Undercurl desired and supported
			let undercurl = 1
		else
			" Undercurl either not desired or not supported
			let undercurl = 0
		endif
	else
		let undercurl = b:txtfmt_cfg_undercurl
	endif
	" Set a flag that indicates whether we will be reserving space for long
	" formats before the start of bgc range. Note that this value can be true
	" even if longformats is false. Also note that its value is N/A if
	" bgcolors are disabled.
	let lf_reserved = bgcolor && (longformats || !b:txtfmt_cfg_pack)
	" Determine size of the entire range
	let rangelen =
		\ b:txtfmt_const_tokrange_size_{bgcolor}{lf_reserved}{lf_reserved}
	" Perform upper-bound check on new range
	if !(new_starttok + rangelen - 1 <=
		\ b:txtfmt_const_tokrange_limit_{b:txtfmt_cfg_enc_class})
		" Invalid destination for move!
		echoerr "Starttok value of `".new_starttok."' causes upper bound for encoding `"
			\.b:txtfmt_cfg_enc."' to be exceeded"
		return
	endif
	" If here, move is legal.
	" Record whether buffer is modified before we start modifying it. This
	" information is used by modeline processing to determine whether save is
	" required.
	let b:txtfmt_ml_save_modified = &modified

	" Build 2 character class interiors (i.e., without the [ ]):
	" 1) all chars that are tokens under old range
	" 2) all chars that are tokens under new range
	" Begin the first range, which begins with fg color and ends either with
	" formats (no bg colors or discontinuity between formats and bg colors) or
	" bg colors.
	" Note: The end of the first range is determined independently of
	" lf_reserved, as the range includes only tokens actually used.
	let re_old_tokrange = nr2char(old_starttok).'-'
	let re_new_tokrange = nr2char(new_starttok).'-'
	if !bgcolor || !(longformats && undercurl)
		" End first range after format tokens
		" Calculate length of range
		let end_offset = b:txtfmt_const_tokrange_size_{0}{longformats}{undercurl} - 1
		" Close the range
		let re_old_tokrange = re_old_tokrange.nr2char(old_starttok + end_offset)
		let re_new_tokrange = re_new_tokrange.nr2char(new_starttok + end_offset)
		" If bgcolor is enabled, start a new range so that logic after this if
		" block needn't know or care whether it was entered
		if bgcolor
			" Determine offset to start of bgc range
			let start_offset = b:txtfmt_const_tokrange_size_{0}{lf_reserved}{lf_reserved}
			let re_old_tokrange = re_old_tokrange.nr2char(old_starttok + start_offset).'-'
			let re_new_tokrange = re_new_tokrange.nr2char(new_starttok + start_offset).'-'
		endif
	endif
	" If bgcolor is enabled, need to close the first or second range. (If no
	" bgcolor, first and only range has already been closed.)
	if bgcolor
		let end_offset = b:txtfmt_const_tokrange_size_{1}{lf_reserved}{lf_reserved} - 1
		let re_old_tokrange = re_old_tokrange.nr2char(old_starttok + end_offset)
		let re_new_tokrange = re_new_tokrange.nr2char(new_starttok + end_offset)
	endif

	" STEP 1: (If and only if escaping is permitted)
	" Before translating any tokens, need to escape characters that are not
	" currently tokens, but will be after the move. Escapes, if applicable,
	" must be taken into account.
	" Note: Also, need to escape any escape chars that would be considered escaping
	" or escaped chars after the move. E.g. (if esc=bslash)
	" <Bslash><Tok> should become <Bslash><Bslash><Bslash><Tok> to ensure that
	" the effective sequence `<Bslash><Tok>' is preserved.
	" The algorithm for `esc=bslash' may be expressed as follows: Escape each
	" char in a sequence consisting of any number of backslashes terminated
	" with a token. Note that it doesn't matter whether number of backslashes
	" is even or odd, since the assumption is that prior to the move, neither
	" the backslashes nor the token chars have any special meaning.
	if b:txtfmt_cfg_escape != 'none'
		" Note: This concat order is *much* more efficient than the
		" alternative (since tokens are less common than non-token chars)
		let re_need_esc =
			\'\%(['.re_new_tokrange.']'
			\.'\&[^'.re_old_tokrange.']\)'
		if b:txtfmt_cfg_escape == 'bslash'
			silent! exe '%s/\%(\\\%(\\*'.re_need_esc.'\)\@=\|'.re_need_esc.'\)/\\\0/g'
		elseif b:txtfmt_cfg_escape == 'self'
			" TODO_BG: Decide whether to use escape() on re_need_esc or
			" whether to hardcode the extra escapes...
			silent! exe '%s/'.substitute(b:re_no_self_esc, 'placeholder',
				\ escape(re_need_esc, '&\'), '').'/\0\0/g'
		endif
	endif

	" STEP 2: Translate token range
	let re_move = '['.re_old_tokrange.']'
	if b:txtfmt_cfg_escape != 'none'
		if b:txtfmt_cfg_escape == 'bslash'
			let re_move = b:re_no_bslash_esc.re_move
		elseif b:txtfmt_cfg_escape == 'self'
			let re_move = substitute(b:re_no_self_esc, 'placeholder', re_move, '')
		endif
	endif
	silent! exe '%s/'.re_move.'/\='
		\.'nr2char(char2nr(submatch(0)) + l:offset)'
		\.'/g'

	" STEP 3: (If and only if escaping is permitted)
	" Remove escape chars for characters that are txtfmt tokens under old
	" tokrange setting, but not under new. Also, since this post-unescaping
	" step is the complement of the pre-escaping performed above, we must
	" unescape backslashes that occur in sequences leading up to the escaped
	" token. E.g.,
	" <Bslash><Bslash><Bslash><Tok> would become <Bslash><Tok>, since neither
	" the <Bslash> nor the subsequent <Tok> is significant after the move.
	" Note that there's no need to check for even/odd number of backslashes
	" preceding tokens. The number will always be odd. For proof, see the
	" Rationale below.
	" Note: Any character that is in the old tokrange but not the new is an
	" escaped token that no longer needs escaping.
	" Rationale: All unescaped tokens of the old range have been translated,
	" and hence will be tokens in the new range as well. Thus, any token that
	" is within the old range but not within the new must, by definition, have
	" been escaped (else it would have been translated to the new range).
	" Design Decision: An escape is an escape if it's escaping any txtfmt
	" token, even a useless 'no-format' or 'no-color' token appearing outside
	" a region. (Recall that I don't highlight these to facilitate removal by
	" user...)
	" Rationale: The goal of this function is not to clean up user's file, but
	" simply to translate tokrange
	if b:txtfmt_cfg_escape != 'none'
		" Note: This concat order is *much* more efficient than the
		" alternative (since tokens are less common than non-token chars)
		let re_noneed_esc =
			\'\%(['.re_old_tokrange.']'
			\.'\&[^'.re_new_tokrange.']\)'
		" Perform substitution
		if b:txtfmt_cfg_escape == 'bslash'
			" Note: The nature of global substitutions is such that the first
			" char matched will always be an escaping (not an escaped) char.
			silent! exe '%s/\\\(\\\%(\\*'.re_noneed_esc.'\)\@=\|'.re_noneed_esc.'\)/\1/g'
		else " self-escape
			silent! exe '%s/\('.re_noneed_esc.'\)\(\1\)/\1/g'
		endif
	endif
	" Cause buffer to be refreshed with the new settings
	" Note: The following events are consumed by modeline processing logic,
	" which may need to alter the starttok value in a modeline
	" Note: <f-args> ensures that new_starttok is a string. This is important
	" because it permits the modeline processing function to respect user's
	" choice of hex or dec when altering the modeline.
	let b:txtfmt_ml_new_starttok = new_starttok
	:Refresh
endfu
endif	" if !exists('*s:MoveStartTok')
" >>>
" Function: s:GetTokInfo() <<<
" Purpose: Return a string, which gives information about a token at a
" specific line/col. If optional line/col pair is not supplied, cursor
" location will be assumed.
" Inputs:
" [line]	Optional arg #1. Line number of char for which info is desired. If
" 			present, 2nd optional arg (col) must also be supplied.
" [col]		Optional arg #2. Column number of char for which info is desired.
" 			Note: This number is actually a byte index, such as would be
" 			returned by Vim's col() function.
" Return: Variable format string as follows:
" *** fg color token ***
" c<clr_num> [(inactive)]
" Note: <clr_num> is 1 based.
" Also Note: `(inactive)' is appended if the token corresponds to a color that
" is not in the active color mask
" *** bg color token ***
" k<clr_num> [(inactive)]
" Note: <clr_num> is 1 based.
" Also Note: `(inactive)' is appended if the token corresponds to a color that
" is not in the active color mask
" *** format token ***
" f<[u][b][i]>
" i.e., the format descriptor in fiducial form
" *** non-token ***
" <char_code>
" *** invalid char location ***
" 'NUL' (just like Vim's ga builtin)
" *** invalid inputs ***
" <empty string> (and echoerr a warning)
" Note: Will show warning to user if inputs were invalid in a syntactical
" sense. (No error msg for nonexistent char position.)
" Interface note: This function is meant to be used both from a mapping (which
" assumes cursor position) and from a command (which permits user to specify
" position).
" IMPORTANT NOTE: This function is multibyte-safe.
fu! s:GetTokInfo(...)
	" The output of the if/else will be line/col of character of interest,
	" assuming the inputs are valid.
	if a:0 == 0
		" Character of interest is at cursor position
		let line = line('.')
		let col = col('.')
	elseif a:0 == 1
		" Makes no sense to supply line but not column!
		echoerr 'GetTokInfo(): Attempt to specify line without column'
		return ''
	elseif a:0 == 2
		" Check for nonnegative line number
		if a:1 =~ '^[1-9][0-9]*$'
			let line = a:1
		else
			echoerr 'GetTokInfo(): '.a:1.' is not a valid line #'
			return ''
		endif
		" Check for nonnegative col number
		if a:2 =~ '^[1-9][0-9]*$'
			let col = a:2
		else
			echoerr 'GetTokInfo(): '.a:2.' is not a valid col #'
			return ''
		endif
	else
		echoerr 'GetTokInfo(): Wrong # of args - should be 0 or 2'
		return ''
	endif
	" If here, inputs are syntactically valid and line/col represents the
	" position of character about which information is desired. Obtain a
	" string whose first character is the character of interest.
	" Note: char2nr considers only first character in a string, so we don't
	" need to strip subsequent characters yet (and we can't do so with
	" byte-aware strpart anyway).
	let ch = strpart(getline(line), col - 1)
	" Note: If input position was invalid, ch will contain empty string.
	if ch == ''
		" Char pos doesn't exist - not an error
		return 'NUL'
	endif
	" If here, we have a character! Get its character code.
	let char_nr = char2nr(ch)
	" Get *single* char corresponding to the char code.
	" Note: strpart() and expr-[] deal with bytes not chars!
	let ch = nr2char(char_nr)
	" Determine the range within which token lies
	if char_nr >= b:txtfmt_fmt_first_tok && char_nr <= b:txtfmt_fmt_last_tok
		" fmt token
		return 'f'.b:ubisrc_fmt{char_nr - b:txtfmt_fmt_first_tok}
	elseif char_nr >= b:txtfmt_clr_first_tok && char_nr <= b:txtfmt_clr_last_tok
		" clr token
		" offset 0 = 'no color', represented by 'c-'
		" offset i = txtfmtColor{i}
		" Note: User-visible array is 1-based, and b:txtfmt_clr_first_tok
		" corresponds to the default fg color token
		let offset = char_nr - b:txtfmt_clr_first_tok
		let ret_str = 'c'.(offset == 0 ? '-' : ''.offset.'')
		" Distinguish between active/inactive start color tokens
		if char_nr > b:txtfmt_clr_first_tok && ch !~ '['.b:txtfmt_re_clr_stok_atom.']'
			let ret_str = ret_str.' (inactive)'
		endif
		return ret_str
	elseif char_nr >= b:txtfmt_bgc_first_tok && char_nr <= b:txtfmt_bgc_last_tok
		" bgc token
		" offset 0 = 'no color', represented by 'k-'
		" offset i = txtfmtColor{i}
		" Note: User-visible array is 1-based, and b:txtfmt_bgc_first_tok
		" corresponds to the default bg color token
		let offset = char_nr - b:txtfmt_bgc_first_tok
		let ret_str = 'k'.(offset == 0 ? '-' : ''.offset.'')
		" Distinguish between active/inactive start color tokens
		if char_nr > b:txtfmt_bgc_first_tok && ch !~ '['.b:txtfmt_re_bgc_stok_atom.']'
			let ret_str = ret_str.' (inactive)'
		endif
		return ret_str
	else
		" Not a txtfmt token - just return ascii value
		return ''.char_nr.''
	endif
endfu
" >>>
" >>>
" Configuration <<<
" Needed only for ftplugin
" Note: Performed after the Common Configuration, which sets the 'starttok'
" option, needed when processing user maps

" Function: s:Expand_user_map_macro() <<<
" Purpose: Expand the input string, which is assumed to be the `...' in one of
" the user-map expansion sequences of the form <...>.
" Return: If the macro is valid, return the expanded text, just as it would
" appear in the rhs of the map; otherwise, an empty string.
fu! s:Expand_user_map_macro(s)
	let re_ins_tok_i   = '^i\\:\(.\+\)$'
	let re_ins_tok_n   = '^n\([1-9]\d*\)\?\\\(v\?\)\([iIaAoOs]\):\(.\+\)$'
	let re_jump_to_tok = '^\([nvio]\)\([1-9]\d*\)\?\([][]\)\(t\?\)\([be]\?[fkca]\)'
	" Determine which macro type we have
	if a:s =~ re_ins_tok_n . '\|' . re_ins_tok_i
		" Insert-token macro
		if a:s[0] == 'n'
			" Insert-token macro (normal)
			let l:count       = substitute(a:s, re_ins_tok_n, '\1', '')
			let end_in_norm   = substitute(a:s, re_ins_tok_n, '\2', '') == 'v'
			let enter_ins_cmd = substitute(a:s, re_ins_tok_n, '\3', '')
			let fmtclr_list   = substitute(a:s, re_ins_tok_n, '\4', '')
		else
			" Insert-token macro (insert)
			let fmtclr_list = substitute(a:s, re_ins_tok_i, '\1', '')
		endif
		" Validate / Translate the fmt/clr list
		let tokstr = s:Translate_fmt_clr_list(fmtclr_list)
		if tokstr==''
			" Invalid fmt/clr list
			" TODO: Perhaps fix up the error string.
			let s:err_str = "Invalid fmt/clr list in user map rhs: ".s:err_str
			return ''
		endif
		" Create the mode-specific expansion text
		if a:s[0] == 'n'
			" normal mode
			let seq = ":call <SID>Insert_tokstr('"
				\.tokstr."', '".enter_ins_cmd."', 1, ".end_in_norm
				\.(strlen(l:count) ? (", ".l:count) : "")
				\.")<CR>"
				\.":call <SID>Adjust_cursor()<CR>"
		else
			" insert mode
			let seq = "<C-R>=<SID>Insert_tokstr('".tokstr."', 'i', 1, 0)<CR>"
			\."<C-R>=<SID>Adjust_cursor()<CR>"
		endif
	elseif a:s =~ re_jump_to_tok
		" Jump to token macro
		let l:mode   = substitute(a:s, re_jump_to_tok, '\1', '')
		let l:count  = substitute(a:s, re_jump_to_tok, '\2', '')
		let l:dir    = substitute(a:s, re_jump_to_tok, '\3', '') == '[' ? 'b' : 'f'
		let l:till   = substitute(a:s, re_jump_to_tok, '\4', '') == 't' ? 1 : 0
		let l:target = substitute(a:s, re_jump_to_tok, '\5', '')
		if l:mode =~ '[nvo]'
			let l:seq = ":<C-U>call <SID>Jump_to_tok('"
				\.l:mode."', '".l:target."', '".l:dir."', ".l:till
				\.(strlen(l:count) ? (", ".l:count) : "")
				\.")<CR>"
		else
			" TODO - Permit insert-mode?
			let l:seq = "<C-R>=<SID>Jump_to_tok('"
				\.l:mode."', '".l:target."', '".l:dir."', ".l:till
				\.(strlen(l:count) ? (", ".l:count) : "")
				\.")<CR>"
		endif
	else
		let s:err_str = "Invalid user-map expansion sequence: `<".a:s.">'"
		return ''
	endif
	" If here, expansion was successul. Return the expanded text.
	return seq
endfu
" >>>
" Function: s:Translate_user_map_rhs() <<<
" Purpose: Convert the rhs specified in a user map definition string to the
" rhs that will be used in the actual map command. Special <<...>> sequences
" are expanded.
" Input: rhs string as it would appear in a user-map string
" Return: The rhs as it would appear in a map command (with user-map macros
" expanded)
" Error: Set s:err_str and return empty string
fu! s:Translate_user_map_rhs(rhs)
	let s = a:rhs
	" Catch empty (or all ws) strings - shouldn't be input
	if s =~ '^[[:space:]]*$'
		let s:err_str = "f:User map rhs must contain at least 1 non-whitespace char"
		return ''
	endif
	" Loop until special sequences are all expanded
	let ret_str = ''	" build up in loop
	let len = strlen(s)
	let i1 = 0
	let i2 = 0
	while i2 < len
		" Find start of <<...>> sequence - this is safe even if i2 is index of
		" next '<'
		"let i1 = matchend(s, '\%(\\\_.\|[^<]\)*', i2)
		let i1 = matchend(s, '<<', i2)
		if i1 < 0
			" String is exhausted - accumulate up to end
			let ret_str = ret_str.strpart(s, i2)
			break
		else
			" Accumulate, prior to processing <<...>>
			let ret_str = ret_str.strpart(s, i2, i1-i2-2)
		endif
		" Now find closing `>>' (it's not optional at this point)
		let i2 = match(s, '>>', i1)
		if i2 < 0
			let s:err_str = "Unmatched `<<' in user map rhs"
			return ''
		endif
		" Extract stuff inside <<...>>
		" i1 points to 1st char beyond `<<'
		" i2 points to first `>'
		" i1 == i2 implies empty ...
		if i2 > i1
			let seq = strpart(s, i1, i2-i1)
		else
			let s:err_str = "Empty fmt/clr map sequence"
			return ''
		endif
		" We have a non-empty sequence. Convert txtfmt-specific <rt> to `>'
		" before passing to Expand_user_map_macro for expansion.
		"let seq = substitute(seq, '\\\(.\)', '\1', 'g')
		let seq = substitute(seq, '<rt>', '>', 'g')
		" Expand the macro
		let expseq = s:Expand_user_map_macro(seq)
		" Was it valid?
		if expseq == ''
			let s:err_str = "Invalid usermap rhs: " . seq 
			return ''
		endif
		" Append the expanded text to the return string
		let ret_str = ret_str.expseq
		" Make i2 point just past `>>' (it's on the 1st `>')
		let i2 = i2+2
	endwhile
	" Return the now completely expanded string
	return ret_str
endfu
" >>>
" Function: s:Do_user_maps() <<<
" Purpose: Process any special global variables set by user, for the purpose
" of allowing him to build his own map sequences from primitives.
" How:
fu! s:Do_user_maps()
	" In the following regex, \1=map command, \2=lhs, \3=rhs
	" RULES:
	" map_cmd must be imap, inoremap, nmap or nnoremap
	" map_lhs is terminated by first unescaped whitespace
	"   -whitespace may appear in lhs if preceded by <C-V>
	" map_rhs is everything else in the string
	" 	-must have extra level of escaping for \ and <
	" 	-may contain special <[in]:...> sequences
	" 	TODO - Fix up the regex...
	let re_usermap = '^\s*\([in]\%(nore\)\?map\)\s\+'
		\.'\(\%('."\<C-V>.".'\|\S\)\+\)\s\+\(.\+\)'
	" Allow up to configurable number of user maps
	" Note: txtfmtUsermaplimit option may be set globally or buflocally, with
	" precedence given to buflocal set.
	let bset = exists('b:txtfmtUsermaplimit')
	let gset = exists('g:txtfmtUsermaplimit')
	if bset || gset
		let user_map_limit = bset ? b:txtfmtUsermaplimit : g:txtfmtUsermaplimit
		" Validate the limit set by user
		if user_map_limit !~ '^\s*\([1-9]\d*\|0x\x\+\)\s*$'
			" Invalid format - Warn and abort user-map processing
			echoerr "Aborting user-defined map processing: "
				\.(bset ? 'b:' : 'g:').'txtfmtUsermaplimit set to invalid value: '
				\."`".user_map_limit."'"
			return
		endif
	else
		" Set default
		let user_map_limit = 25
	endif
	" Loop over all possible maps
	let i = 1
	while i <= user_map_limit
		" Determine whether buflocal or global setting exists for this element
		let bset = exists('b:txtfmtUsermap'.i)
		let gset = exists('g:txtfmtUsermap'.i)
		if bset || gset
			" Obtain the buflocal or global element
			let s = bset ? b:txtfmtUsermap{i} : g:txtfmtUsermap{i}
			" Validate and process the user map string
			if s !~ re_usermap
				echoerr 'Ignoring malformed user-defined map specified by '
					\.(bset ? 'b:' : 'g:').'txtfmtUsermap{'.i.'}: '
					\.'help txtfmt-user-map-fmt'
			else
				" Extract the map command and the map lhs/rhs
				let map_cmd = substitute(s, re_usermap, '\1', '')
				let map_lhs = substitute(s, re_usermap, '\2', '')
				let map_rhs = substitute(s, re_usermap, '\3', '')
				" Process non-empty rhs for special sequences
				" NOTE: rhs has extra level of \ and < escaping because of the
				" special embedded <...> sequences
				let map_rhs = s:Translate_user_map_rhs(map_rhs)
				if map_rhs==''
					echoerr "User-defined map #".i." ignored due to error: ".s:err_str
				else
					" Attempt to define the map
					exe map_cmd.' <buffer> '.map_lhs.' '.map_rhs
					" Add corresponding undo action (n or i unmap)
					" TODO - Figure out how to use s:Undef_map and avoid "no
					" such mapping error.
					call s:Add_undo(map_cmd[0].'unmap <buffer> '.map_lhs)
				endif
			endif
		endif
		" Progress to next possible user map
		let i = i + 1
	endwhile
endfu
" >>>
" Function: s:Set_mapwarn() <<<
" Purpose: Set txtfmt_cfg_mapwarn option either from user-supplied
" g:txtfmtMapwarn or to default value. Global var txtfmtMapwarn is a character
" flag option, which may contain the following flags: mMeEcCoO. Although the
" flags may appear in any combination and in any order, there are certain
" combinations that make no sense and should (arguably) result in a warning:
" -m and e should not be used together
" -M and E should not be used together
" Note: If either of the above 2 rules are violated, the last supplied flag
" takes precedence.
" -o should not be used without either e or m
" -O should not be used without either E or M
fu! s:Set_mapwarn()
	" The following buffer-local config option is the output of this function,
	" and must be set before return.
	unlet! b:txtfmt_cfg_mapwarn
	if exists('g:txtfmtMapwarn')
		" Process value supplied by user, storing to buffer-local config
		" variable a valid and normalized set of character flags.
		" Design Decision: Preserve the order of flags being retained rather
		" than arranging them in fiducial order.
		" Note: Existence of l:mapwarn after the loop implies that no error
		" was found with user-supplied option value. (Note that empty string
		" is a valid setting.)
		let mapwarn = ''
		let i = strlen(g:txtfmtMapwarn) - 1
		while i >= 0
			let ch = g:txtfmtMapwarn[i]
			if ch !~ '[mMeEcCoO]'
				" Invalid flag!
				unlet mapwarn
				break
			endif
			" Make sure flags already in mapwarn don't preclude addition of
			" this one.
			if (
				\-1 == stridx(mapwarn, ch) &&
				\(ch != 'm' || -1 == stridx(mapwarn, 'e')) &&
				\(ch != 'e' || -1 == stridx(mapwarn, 'm')) &&
				\(ch != 'M' || -1 == stridx(mapwarn, 'E')) &&
				\(ch != 'E' || -1 == stridx(mapwarn, 'M'))
			\)
				" Prepend the flag to preserve order. (Recall that loop is in
				" reverse order.)
				let mapwarn = ch . mapwarn
			endif
			" Retreat to preceding character flag
			let i = i - 1
		endwhile
		if exists('l:mapwarn')
			" No errors were encountered in the set of mapwarn.
			let b:txtfmt_cfg_mapwarn = mapwarn
		else
			" Warn user that his setting was not valid
			echomsg "Ignoring invalid setting of txtfmtMapwarn: `".g:txtfmtMapwarn
				\."' (:he txtfmtMapwarn)"
		endif
	endif
	" If option was not set by user to a valid value, set to default
	if !exists('b:txtfmt_cfg_mapwarn')
		" Use default
		let b:txtfmt_cfg_mapwarn = 'mMoOcC'
	endif
endfu
" >>>
" Function: s:Define_user_map_defaults() <<<
" Purpose: Set up some default user maps for testing...
fu! s:Define_user_map_defaults()
	" User map definition examples for test <<<

	" Map CTRL-B in insert mode to start and terminate a 'bold' region,
	" leaving the cursor positioned in the region interior, ready to type bold
	" text.
	" Hint: Similar maps might be created for underline and italic
	let g:txtfmtUsermap1 = 'inoremap <C-B> <<i\:fb.f->>'

	" Map CTRL-\f in insert mode to end current format region.
	let g:txtfmtUsermap2 = 'inoremap <C-\>f <<i\:f->>'

	" Map CTRL-\k in insert mode to end current bg color region.
	let g:txtfmtUsermap3 = 'inoremap <C-\>k <<i\:k->>'

	" Map \t in normal mode to embolden, underline and center (i.e.
	" 'title-ize') the current line
	let g:txtfmtUsermap4 =
	    \'nnoremap <Bslash>t <<n\vI:fbu>><<n\vA:f->>:ce<CR>'

	" Map \cf in normal mode to change all text within the current format
	" region (without deleting the tokens that begin and end the region).
	" Note: Since the default jump-to-token mappings are used in the rhs
	" (rather than the special expansion macros), nmap must be used (rather
	" than nnoremap).
	" Note: The reason the ]f does not cause the format 'end region' token to
	" be deleted is that the operator-pending jump-to-token maps work
	" 'exclusively' when there is no 'v' between operator and motion.
	let g:txtfmtUsermap5 =
	    \'nmap <Bslash>cf [tbfc]f'

	" Same as preceding map but for current color region.
	" Note: This one demonstrates the use of the 'jump-to-token' expansion
	" macros.
	let g:txtfmtUsermap6 =
		\'nnoremap <Bslash>cc <<n[tbc>>c<<o]c>>'

	" Map <LocalLeader>bw in normal mode to embolden the word under the
	" cursor. (The extra complexity is needed to ensure that you can invoke
	" with cursor anywhere on the word.)
	let g:txtfmtUsermap7 =
	    \'nnoremap <LocalLeader>bw :if col(".")!=1 && '
	    \.'getline(".")[col(".")-2]=~"\\w"<Bar>exe "norm!  b"<Bar>'
	    \.'endif<CR><<n\vi:fb>>e<<n\va:f->>b'

	" Map \vf in normal mode to select all of the current format region
	" visually.
	" Note: Unlike the earlier one for changing the current format region,
	" this one doesn't constrain the backwards jump to a 'begin' region token;
	" hence, it will also highlight the text between regions.
	let g:txtfmtUsermap8 =
	    \'nnoremap <LocalLeader>vf <<n[tf>>v<<v]tf>>'

	" Map <C-\>vf in insert mode to do the same in insert mode
	let g:txtfmtUsermap9 =
	    \'inoremap <C-\>vf <<i[tf>><Esc>lv<<v]tf>>'

	" Map <LocalLeader><Space> in normal mode to jump forward to the 3rd
	" 'begin format region' token. (Not overly practical, but demonstrates the
	" use of whitespace in the lhs, as well as the use of the optional count
	" with the jump-to-token expansion macros.)
	let g:txtfmtUsermap10 =
	    \'nnoremap <LocalLeader><Space> <<n3]bf>>'

	" Map <LocalLeader>_ in normal mode to substitute the next 4 characters
	" with a 'bold' format token followed by a 'no format' token, leaving the
	" cursor positioned between the two.
	" (This map is not intended to be useful, but merely to demonstrate the
	" specification of a count with an insert-token expansion macro.)
	let g:txtfmtUsermap11 =
	    \'nnoremap <LocalLeader>_ <<n4\s:fb.f->>'

	" Map <LocalLeader>rb in normal mode to make the current line bold with a
	" red background.
	let g:txtfmtUsermap12 =
	    \'nnoremap <LocalLeader>rb <<n\vI:kr,fb>><<n\vA:f-,k->>'
	" >>>
endfu
" >>>
" Function: s:Do_config() <<<
" Purpose: Set script local variables, taking into account whether user has
" overriden via txtfmt globals.
fu! s:Do_config()
	" set vim 'iskeyword' option <<<
	" Exclude the special tokens from iskeyword option, so that word movement
	" normal commands will work intuitively. (Recall that the delimiters will
	" appear as space characters.)
	" IMPORTANT NOTE: Ideally, we would be able to have the tokens treated
	" just like whitespace, from the standpoint of word and WORD motions;
	" unfortunately, we can't instruct Vim to do this - the best we can do is
	" make them non-keyword, which means they'll be treated like punctation;
	" i.e., word motions will stop on them and on the beginning of subsequent
	" word.
	" IMPORTANT TODO: Vim doesn't allow multi-byte characters above 255 to be
	" excluded!
	" Decide whether there's a workaround. For now, don't do this if we're
	" dealing with tokens above 255.
	" Note: I'm intentionally including inactive color tokens in the ranges.
	" Rationale: I don't feel that the complexity that would be added by the
	" logic to exclude them is justified by any advantage doing so would
	" provide.
	if (b:txtfmt_last_tok <= 255) 
		let val = '^'.b:txtfmt_clr_first_tok.'-'.b:txtfmt_last_tok
		exe 'setlocal iskeyword+='.val
		call s:Add_undo('setlocal iskeyword-='.val)
	endif
	" >>>
	" Process txtfmtMapwarn option <<<
	call s:Set_mapwarn()
	" >>>
	" txtfmtUsermaplimit: Max # of user maps that will be checked <<<
	" Allow nonnegative dec, hex, or oct
	" Cannot set from modeline
	if exists('g:txtfmtUsermaplimit') && g:txtfmtUsermaplimit =~ '^\%(0[xX]\)\?[0-9]\+$'
		let s:txtfmtUsermaplimit = g:txtfmtUsermaplimit
	else
		" Set to reasonable default
		let s:txtfmtUsermaplimit = 25
	endif
	" >>>
	" TEST ONLY: Define some default user-maps for testing <<<
	"call s:Define_user_map_defaults()
	" >>>
	" Process any user-defined maps <<<
	call s:Do_user_maps()
	" >>>
endfu
" >>>
call s:Do_config()
" >>>
" Public-interface functions <<<
" Function: g:Txtfmt_GetTokInfo() <<<
" !!!!!!!!!!!!!!!!!!!!!!
" !!!!! DEPRECATED !!!!!
" !!!!!!!!!!!!!!!!!!!!!!
" Purpose: Return a string, which gives information about a token at a
" specific line/col. If optional line/col pair is not supplied, cursor
" location will be assumed.
" Important Note: This function is conceptually a wrapper for script-local
" s:GetTokInfo. For backwards-compatibility reasons, however, the meaning of
" the 'col' parameter is slightly different. For this function, col represents
" a 1-based char index; for s:GetTokInfo it is a 1-based byte index.
" Note: See s:GetTokInfo for additional description
" Interface note: This function is meant to be used by plugin user; e.g., from
" mappings.
" IMPORTANT NOTE: This function now works for multibyte encodings.
fu! Txtfmt_GetTokInfo(...)
	" Call s:GetTokInfo with the appropriate arguments
	if a:0 == 0
		return s:GetTokInfo()
	elseif a:0 == 1
		" Makes no sense to supply line but not column!
		echoerr 'Txtfmt_GetTokInfo(): Attempt to specify line without column'
		return ''
	elseif a:0 == 2
		" Check for nonnegative line number
		if a:1 =~ '^[1-9][0-9]*$'
			let line = a:1
		else
			echoerr 'Txtfmt_GetTokInfo(): '.a:1.' is not a valid line #'
			return ''
		endif
		" Check for nonnegative col number
		if a:2 =~ '^[1-9][0-9]*$'
			" Note: Input col is 1-based character index. Use byteidx to convert
			" to 1-based byte index for strpart.
			let col = byteidx(getline(line), a:2 - 1) + 1
			if col == 0
				" Invalid (too large) col position - not error...
				return 'NUL'
			else
				return s:GetTokInfo(line, col)
			endif
		else
			echoerr 'Txtfmt_GetTokInfo(): '.a:2.' is not a valid col #'
			return ''
		endif
	else
		echoerr 'Txtfmt_GetTokInfo(): Wrong # of args - should be 0 or 2'
		return ''
	endif
endfu
" >>>
" Function: g:OldTxtfmt_GetTokInfo() <<<
" Purpose: Return a string, which gives information about a token at a
" specific line/col. If optional line/col pair is not supplied, cursor
" location will be assumed.
" Inputs:
" [line]	Optional arg #1. Line number of char for which info is desired. If
" 			present, 2nd optional arg (col) must also be supplied.
" [col]		Optional arg #2. Column number of char for which info is desired.
" NOTE: Currently, even when a multi-byte encoding is used, [col] is used as a
" byte offset rather than a character offset.
" TODO: Decide whether I should stop obtaining the character via
" getline()[pos] in favor of a multi-byte safe way.
" Return: Variable format string as follows:
" *** color token ***
" c<clr_num>
" Note: <clr_num> is 1 based.
" *** format token ***
" f<[u][b][i]>
" i.e., the format descriptor in fiducial form
" *** non-token ***
" <ascii_char_code>
" *** invalid char location or wrong # of inputs ***
" <empty string>
" Note: Will show warning to user if inputs were invalid in a syntactical
" sense. (No error msg for nonexistent char position.)
" Interface note: This function is meant to be used by plugin user; e.g., from
" mappings.
" IMPORTANT NOTE: This function now works for multibyte encodings.
" TODO_BG: Delete this "old" version of the function if I haven't rolled back
" prior to the release of 2.0...
fu! OldTxtfmt_GetTokInfo(...)
	" The output of the if/else will be a variable (ch) whose first character
	" is the token about which information is requested
	if a:0 == 0
		let ch = strpart(getline('.'), col('.') - 1)
	elseif a:0 == 1
		" Makes no sense to supply line but not column!
		echoerr 'Txtfmt_GetTokInfo(): Attempt to specify line without column'
		return ''
	elseif a:0 == 2
		" Check for nonnegative line number
		if a:1 =~ '^[1-9][0-9]*$'
			let line = a:1
		else
			echoerr 'Txtfmt_GetTokInfo(): '.a:1.' is not a valid line #'
			return ''
		endif
		" Check for nonnegative col number
		if a:2 =~ '^[1-9][0-9]*$'
			" Note: Input col is 1-based character index. Use byteidx to convert
			" to byte index for strpart.
			let col0 = byteidx(getline(line), a:2 - 1)
			if col0 == -1
				" Invalid (too large) col position - not error...
				let ch = ''
			else
				let ch = strpart(getline(line), col0)
			endif
		else
			echoerr 'Txtfmt_GetTokInfo(): '.a:2.' is not a valid col #'
			return ''
		endif
	else
		echoerr 'Txtfmt_GetTokInfo(): Wrong # of args - should be 0 or 2'
		return ''
	endif
	" If here, inputs are syntactically valid and ch holds a string whose
	" first character is the one about which info is requested, or empty
	" string if the requested position is invalid.
	if ch == ''
		" Char pos doesn't exist - not an error
		return ''
	endif
	let char_nr = char2nr(ch)
	" Determine the range within which token lies
	if char_nr >= b:txtfmt_fmt_first_tok && char_nr <= b:txtfmt_fmt_last_tok
		" fmt token
		return 'f'.b:ubisrc_fmt{char_nr - b:txtfmt_fmt_first_tok}
	elseif char_nr >= b:txtfmt_clr_first_tok && char_nr <= b:txtfmt_clr_last_tok
		" clr token
		" offset 0 = 'no color', represented by 'c-'
		" offset i = color{i-1}
		let offset = char_nr - b:txtfmt_clr_first_tok
		return 'c'.(offset == 0 ? '-' : ''.(offset-1).'')
	else
		" Not a txtfmt token - just return ascii value
		return ''.char_nr.''
	endif
endfu
" >>>
" Function: g:Txtfmt_GetTokStr() <<<
" Purpose: Translate the input fmt/clr spec list and return the resulting
" token string.
" Inputs:
" s		fmt/clr spec list to be translated
" Return: If input spec list is valid, the corresponding literal token
" sequence is returned as a string; otherwise, empty string is returned and
" error msg is output.
fu! Txtfmt_GetTokStr(s)
	" Make sure this is a txtfmt buffer
	if !exists('b:loaded_txtfmt')
		echoerr "Function Txtfmt_GetTokStr can be used only within a 'txtfmt' buffer"
		return ''
	endif
	" Call script-local function to perform the translation
	let tokstr = s:Translate_fmt_clr_list(a:s)
	if (tokstr == '')
		echoerr "`".a:s."' is not a valid fmt/clr spec list"
		return ''
	else
		" We have a translated fmt/clr spec comprising an offset followed by
		" the actual fmt/clr token sequence. Extract the literal token string
		" and throw the offset away.
		" TODO - Embed this in a special accessor function that may be used
		" elsewhere...
		let tokstr = substitute(tokstr, '\(\-\?[[:digit:]]\+\),\(.*\)', '\2', '')
		return tokstr
	endif
endfu
" >>>
" >>>
" Public-interface commands <<<
com! -buffer ShowTokenMap call <SID>ShowTokenMap()
com! -buffer -nargs=? MoveStartTok call <SID>MoveStartTok(<f-args>)
com! -buffer -nargs=* GetTokInfo echo <SID>GetTokInfo(<f-args>)
" >>>
" MAPS: LEVEL 1 & 2 (reconfig): normal/insert mode --> <Plug>... mappings <<<
" Note: <C-R> used (rather than <C-O>) to prevent side-effect when insert-mode
" mapping invoked past end of line (cursor pos off by 1)
" normal mode jump 'to' token mappings <<<
" Align sequence <<<
" AlignCtrl default
" AlignCtrl w=p0P1 ,
" AlignCtrl g ^call
" '<,'>Align
" >>>
call s:Def_map('n', '[bf', '<Plug>TxtfmtBckToFmtBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bf', 'b', 0)<CR>")
call s:Def_map('n', ']bf', '<Plug>TxtfmtFwdToFmtBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bf', 'f', 0)<CR>")
call s:Def_map('n', '[bc', '<Plug>TxtfmtBckToClrBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bc', 'b', 0)<CR>")
call s:Def_map('n', ']bc', '<Plug>TxtfmtFwdToClrBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bc', 'f', 0)<CR>")
call s:Def_map('n', '[bk', '<Plug>TxtfmtBckToBgcBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bk', 'b', 0)<CR>")
call s:Def_map('n', ']bk', '<Plug>TxtfmtFwdToBgcBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bk', 'f', 0)<CR>")
call s:Def_map('n', '[ba', '<Plug>TxtfmtBckToAnyBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'ba', 'b', 0)<CR>")
call s:Def_map('n', ']ba', '<Plug>TxtfmtFwdToAnyBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'ba', 'f', 0)<CR>")
call s:Def_map('n', '[f' , '<Plug>TxtfmtBckToFmtTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'f' , 'b', 0)<CR>")
call s:Def_map('n', ']f' , '<Plug>TxtfmtFwdToFmtTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'f' , 'f', 0)<CR>")
call s:Def_map('n', '[c' , '<Plug>TxtfmtBckToClrTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'c' , 'b', 0)<CR>")
call s:Def_map('n', ']c' , '<Plug>TxtfmtFwdToClrTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'c' , 'f', 0)<CR>")
call s:Def_map('n', '[k' , '<Plug>TxtfmtBckToBgcTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'k' , 'b', 0)<CR>")
call s:Def_map('n', ']k' , '<Plug>TxtfmtFwdToBgcTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'k' , 'f', 0)<CR>")
call s:Def_map('n', '[a' , '<Plug>TxtfmtBckToAnyTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'a' , 'b', 0)<CR>")
call s:Def_map('n', ']a' , '<Plug>TxtfmtFwdToAnyTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'a' , 'f', 0)<CR>")
call s:Def_map('n', '[ef', '<Plug>TxtfmtBckToFmtEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ef', 'b', 0)<CR>")
call s:Def_map('n', ']ef', '<Plug>TxtfmtFwdToFmtEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ef', 'f', 0)<CR>")
call s:Def_map('n', '[ec', '<Plug>TxtfmtBckToClrEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ec', 'b', 0)<CR>")
call s:Def_map('n', ']ec', '<Plug>TxtfmtFwdToClrEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ec', 'f', 0)<CR>")
call s:Def_map('n', '[ek', '<Plug>TxtfmtBckToBgcEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ek', 'b', 0)<CR>")
call s:Def_map('n', ']ek', '<Plug>TxtfmtFwdToBgcEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ek', 'f', 0)<CR>")
call s:Def_map('n', '[ea', '<Plug>TxtfmtBckToAnyEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ea', 'b', 0)<CR>")
call s:Def_map('n', ']ea', '<Plug>TxtfmtFwdToAnyEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ea', 'f', 0)<CR>")
" >>>
" visual mode jump 'to' token mappings <<<
call s:Def_map('v', '[bf', '<Plug>TxtfmtBckToFmtBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bf', 'b', 0)<CR>")
call s:Def_map('v', ']bf', '<Plug>TxtfmtFwdToFmtBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bf', 'f', 0)<CR>")
call s:Def_map('v', '[bc', '<Plug>TxtfmtBckToClrBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bc', 'b', 0)<CR>")
call s:Def_map('v', ']bc', '<Plug>TxtfmtFwdToClrBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bc', 'f', 0)<CR>")
call s:Def_map('v', '[bk', '<Plug>TxtfmtBckToBgcBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bk', 'b', 0)<CR>")
call s:Def_map('v', ']bk', '<Plug>TxtfmtFwdToBgcBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bk', 'f', 0)<CR>")
call s:Def_map('v', '[ba', '<Plug>TxtfmtBckToAnyBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'ba', 'b', 0)<CR>")
call s:Def_map('v', ']ba', '<Plug>TxtfmtFwdToAnyBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'ba', 'f', 0)<CR>")
call s:Def_map('v', '[f' , '<Plug>TxtfmtBckToFmtTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'f' , 'b', 0)<CR>")
call s:Def_map('v', ']f' , '<Plug>TxtfmtFwdToFmtTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'f' , 'f', 0)<CR>")
call s:Def_map('v', '[c' , '<Plug>TxtfmtBckToClrTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'c' , 'b', 0)<CR>")
call s:Def_map('v', ']c' , '<Plug>TxtfmtFwdToClrTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'c' , 'f', 0)<CR>")
call s:Def_map('v', '[k' , '<Plug>TxtfmtBckToBgcTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'k' , 'b', 0)<CR>")
call s:Def_map('v', ']k' , '<Plug>TxtfmtFwdToBgcTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'k' , 'f', 0)<CR>")
call s:Def_map('v', '[a' , '<Plug>TxtfmtBckToAnyTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'a' , 'b', 0)<CR>")
call s:Def_map('v', ']a' , '<Plug>TxtfmtFwdToAnyTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'a' , 'f', 0)<CR>")
call s:Def_map('v', '[ef', '<Plug>TxtfmtBckToFmtEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ef', 'b', 0)<CR>")
call s:Def_map('v', ']ef', '<Plug>TxtfmtFwdToFmtEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ef', 'f', 0)<CR>")
call s:Def_map('v', '[ec', '<Plug>TxtfmtBckToClrEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ec', 'b', 0)<CR>")
call s:Def_map('v', ']ec', '<Plug>TxtfmtFwdToClrEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ec', 'f', 0)<CR>")
call s:Def_map('v', '[ek', '<Plug>TxtfmtBckToBgcEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ek', 'b', 0)<CR>")
call s:Def_map('v', ']ek', '<Plug>TxtfmtFwdToBgcEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ek', 'f', 0)<CR>")
call s:Def_map('v', '[ea', '<Plug>TxtfmtBckToAnyEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ea', 'b', 0)<CR>")
call s:Def_map('v', ']ea', '<Plug>TxtfmtFwdToAnyEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ea', 'f', 0)<CR>")
" >>>
" operator-pending mode jump 'to' token mappings <<<
" Note: 'v' can be used with these to toggle inclusive/exclusive
call s:Def_map('o', '[bf', '<Plug>TxtfmtBckToFmtBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bf', 'b', 0)<CR>")
call s:Def_map('o', ']bf', '<Plug>TxtfmtFwdToFmtBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bf', 'f', 0)<CR>")
call s:Def_map('o', '[bc', '<Plug>TxtfmtBckToClrBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bc', 'b', 0)<CR>")
call s:Def_map('o', ']bc', '<Plug>TxtfmtFwdToClrBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bc', 'f', 0)<CR>")
call s:Def_map('o', '[bk', '<Plug>TxtfmtBckToBgcBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bk', 'b', 0)<CR>")
call s:Def_map('o', ']bk', '<Plug>TxtfmtFwdToBgcBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bk', 'f', 0)<CR>")
call s:Def_map('o', '[ba', '<Plug>TxtfmtBckToAnyBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'ba', 'b', 0)<CR>")
call s:Def_map('o', ']ba', '<Plug>TxtfmtFwdToAnyBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'ba', 'f', 0)<CR>")
call s:Def_map('o', '[f' , '<Plug>TxtfmtBckToFmtTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'f' , 'b', 0)<CR>")
call s:Def_map('o', ']f' , '<Plug>TxtfmtFwdToFmtTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'f' , 'f', 0)<CR>")
call s:Def_map('o', '[c' , '<Plug>TxtfmtBckToClrTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'c' , 'b', 0)<CR>")
call s:Def_map('o', ']c' , '<Plug>TxtfmtFwdToClrTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'c' , 'f', 0)<CR>")
call s:Def_map('o', '[k' , '<Plug>TxtfmtBckToBgcTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'k' , 'b', 0)<CR>")
call s:Def_map('o', ']k' , '<Plug>TxtfmtFwdToBgcTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'k' , 'f', 0)<CR>")
call s:Def_map('o', '[a' , '<Plug>TxtfmtBckToAnyTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'a' , 'b', 0)<CR>")
call s:Def_map('o', ']a' , '<Plug>TxtfmtFwdToAnyTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'a' , 'f', 0)<CR>")
call s:Def_map('o', '[ef', '<Plug>TxtfmtBckToFmtEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ef', 'b', 0)<CR>")
call s:Def_map('o', ']ef', '<Plug>TxtfmtFwdToFmtEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ef', 'f', 0)<CR>")
call s:Def_map('o', '[ec', '<Plug>TxtfmtBckToClrEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ec', 'b', 0)<CR>")
call s:Def_map('o', ']ec', '<Plug>TxtfmtFwdToClrEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ec', 'f', 0)<CR>")
call s:Def_map('o', '[ek', '<Plug>TxtfmtBckToBgcEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ek', 'b', 0)<CR>")
call s:Def_map('o', ']ek', '<Plug>TxtfmtFwdToBgcEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ek', 'f', 0)<CR>")
call s:Def_map('o', '[ea', '<Plug>TxtfmtBckToAnyEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ea', 'b', 0)<CR>")
call s:Def_map('o', ']ea', '<Plug>TxtfmtFwdToAnyEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ea', 'f', 0)<CR>")
" >>>
" normal mode jump 'till' token mappings <<<
call s:Def_map('n', '[tbf', '<Plug>TxtfmtBckTillFmtBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bf', 'b', 1)<CR>")
call s:Def_map('n', ']tbf', '<Plug>TxtfmtFwdTillFmtBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bf', 'f', 1)<CR>")
call s:Def_map('n', '[tbc', '<Plug>TxtfmtBckTillClrBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bc', 'b', 1)<CR>")
call s:Def_map('n', ']tbc', '<Plug>TxtfmtFwdTillClrBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bc', 'f', 1)<CR>")
call s:Def_map('n', '[tbk', '<Plug>TxtfmtBckTillBgcBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bk', 'b', 1)<CR>")
call s:Def_map('n', ']tbk', '<Plug>TxtfmtFwdTillBgcBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'bk', 'f', 1)<CR>")
call s:Def_map('n', '[tba', '<Plug>TxtfmtBckTillAnyBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'ba', 'b', 1)<CR>")
call s:Def_map('n', ']tba', '<Plug>TxtfmtFwdTillAnyBegTok', ":<C-U>call <SID>Jump_to_tok('n', 'ba', 'f', 1)<CR>")
call s:Def_map('n', '[tf' , '<Plug>TxtfmtBckTillFmtTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'f' , 'b', 1)<CR>")
call s:Def_map('n', ']tf' , '<Plug>TxtfmtFwdTillFmtTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'f' , 'f', 1)<CR>")
call s:Def_map('n', '[tc' , '<Plug>TxtfmtBckTillClrTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'c' , 'b', 1)<CR>")
call s:Def_map('n', ']tc' , '<Plug>TxtfmtFwdTillClrTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'c' , 'f', 1)<CR>")
call s:Def_map('n', '[tk' , '<Plug>TxtfmtBckTillBgcTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'k' , 'b', 1)<CR>")
call s:Def_map('n', ']tk' , '<Plug>TxtfmtFwdTillBgcTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'k' , 'f', 1)<CR>")
call s:Def_map('n', '[ta' , '<Plug>TxtfmtBckTillAnyTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'a' , 'b', 1)<CR>")
call s:Def_map('n', ']ta' , '<Plug>TxtfmtFwdTillAnyTok'   , ":<C-U>call <SID>Jump_to_tok('n', 'a' , 'f', 1)<CR>")
call s:Def_map('n', '[tef', '<Plug>TxtfmtBckTillFmtEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ef', 'b', 1)<CR>")
call s:Def_map('n', ']tef', '<Plug>TxtfmtFwdTillFmtEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ef', 'f', 1)<CR>")
call s:Def_map('n', '[tec', '<Plug>TxtfmtBckTillClrEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ec', 'b', 1)<CR>")
call s:Def_map('n', ']tec', '<Plug>TxtfmtFwdTillClrEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ec', 'f', 1)<CR>")
call s:Def_map('n', '[tek', '<Plug>TxtfmtBckTillBgcEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ek', 'b', 1)<CR>")
call s:Def_map('n', ']tek', '<Plug>TxtfmtFwdTillBgcEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ek', 'f', 1)<CR>")
call s:Def_map('n', '[tea', '<Plug>TxtfmtBckTillAnyEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ea', 'b', 1)<CR>")
call s:Def_map('n', ']tea', '<Plug>TxtfmtFwdTillAnyEndTok', ":<C-U>call <SID>Jump_to_tok('n', 'ea', 'f', 1)<CR>")
" >>>
" visual mode jump 'till' token mappings <<<
call s:Def_map('v', '[tbf', '<Plug>TxtfmtBckTillFmtBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bf', 'b', 1)<CR>")
call s:Def_map('v', ']tbf', '<Plug>TxtfmtFwdTillFmtBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bf', 'f', 1)<CR>")
call s:Def_map('v', '[tbc', '<Plug>TxtfmtBckTillClrBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bc', 'b', 1)<CR>")
call s:Def_map('v', ']tbc', '<Plug>TxtfmtFwdTillClrBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bc', 'f', 1)<CR>")
call s:Def_map('v', '[tbk', '<Plug>TxtfmtBckTillBgcBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bk', 'b', 1)<CR>")
call s:Def_map('v', ']tbk', '<Plug>TxtfmtFwdTillBgcBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'bk', 'f', 1)<CR>")
call s:Def_map('v', '[tba', '<Plug>TxtfmtBckTillAnyBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'ba', 'b', 1)<CR>")
call s:Def_map('v', ']tba', '<Plug>TxtfmtFwdTillAnyBegTok', ":<C-U>call <SID>Jump_to_tok('v', 'ba', 'f', 1)<CR>")
call s:Def_map('v', '[tf' , '<Plug>TxtfmtBckTillFmtTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'f' , 'b', 1)<CR>")
call s:Def_map('v', ']tf' , '<Plug>TxtfmtFwdTillFmtTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'f' , 'f', 1)<CR>")
call s:Def_map('v', '[tc' , '<Plug>TxtfmtBckTillClrTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'c' , 'b', 1)<CR>")
call s:Def_map('v', ']tc' , '<Plug>TxtfmtFwdTillClrTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'c' , 'f', 1)<CR>")
call s:Def_map('v', '[tk' , '<Plug>TxtfmtBckTillBgcTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'k' , 'b', 1)<CR>")
call s:Def_map('v', ']tk' , '<Plug>TxtfmtFwdTillBgcTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'k' , 'f', 1)<CR>")
call s:Def_map('v', '[ta' , '<Plug>TxtfmtBckTillAnyTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'a' , 'b', 1)<CR>")
call s:Def_map('v', ']ta' , '<Plug>TxtfmtFwdTillAnyTok'   , ":<C-U>call <SID>Jump_to_tok('v', 'a' , 'f', 1)<CR>")
call s:Def_map('v', '[tef', '<Plug>TxtfmtBckTillFmtEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ef', 'b', 1)<CR>")
call s:Def_map('v', ']tef', '<Plug>TxtfmtFwdTillFmtEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ef', 'f', 1)<CR>")
call s:Def_map('v', '[tec', '<Plug>TxtfmtBckTillClrEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ec', 'b', 1)<CR>")
call s:Def_map('v', ']tec', '<Plug>TxtfmtFwdTillClrEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ec', 'f', 1)<CR>")
call s:Def_map('v', '[tek', '<Plug>TxtfmtBckTillBgcEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ek', 'b', 1)<CR>")
call s:Def_map('v', ']tek', '<Plug>TxtfmtFwdTillBgcEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ek', 'f', 1)<CR>")
call s:Def_map('v', '[tea', '<Plug>TxtfmtBckTillAnyEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ea', 'b', 1)<CR>")
call s:Def_map('v', ']tea', '<Plug>TxtfmtFwdTillAnyEndTok', ":<C-U>call <SID>Jump_to_tok('v', 'ea', 'f', 1)<CR>")
" >>>
" operator-pending mode jump 'till' token mappings <<<
" Note: 'v' can be used with these to toggle inclusive/exclusive
call s:Def_map('o', '[tbf', '<Plug>TxtfmtBckTillFmtBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bf', 'b', 1)<CR>")
call s:Def_map('o', ']tbf', '<Plug>TxtfmtFwdTillFmtBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bf', 'f', 1)<CR>")
call s:Def_map('o', '[tbc', '<Plug>TxtfmtBckTillClrBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bc', 'b', 1)<CR>")
call s:Def_map('o', ']tbc', '<Plug>TxtfmtFwdTillClrBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bc', 'f', 1)<CR>")
call s:Def_map('o', '[tbk', '<Plug>TxtfmtBckTillBgcBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bk', 'b', 1)<CR>")
call s:Def_map('o', ']tbk', '<Plug>TxtfmtFwdTillBgcBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'bk', 'f', 1)<CR>")
call s:Def_map('o', '[tba', '<Plug>TxtfmtBckTillAnyBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'ba', 'b', 1)<CR>")
call s:Def_map('o', ']tba', '<Plug>TxtfmtFwdTillAnyBegTok', ":<C-U>call <SID>Jump_to_tok('o', 'ba', 'f', 1)<CR>")
call s:Def_map('o', '[tf' , '<Plug>TxtfmtBckTillFmtTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'f' , 'b', 1)<CR>")
call s:Def_map('o', ']tf' , '<Plug>TxtfmtFwdTillFmtTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'f' , 'f', 1)<CR>")
call s:Def_map('o', '[tc' , '<Plug>TxtfmtBckTillClrTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'c' , 'b', 1)<CR>")
call s:Def_map('o', ']tc' , '<Plug>TxtfmtFwdTillClrTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'c' , 'f', 1)<CR>")
call s:Def_map('o', '[tk' , '<Plug>TxtfmtBckTillBgcTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'k' , 'b', 1)<CR>")
call s:Def_map('o', ']tk' , '<Plug>TxtfmtFwdTillBgcTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'k' , 'f', 1)<CR>")
call s:Def_map('o', '[ta' , '<Plug>TxtfmtBckTillAnyTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'a' , 'b', 1)<CR>")
call s:Def_map('o', ']ta' , '<Plug>TxtfmtFwdTillAnyTok'   , ":<C-U>call <SID>Jump_to_tok('o', 'a' , 'f', 1)<CR>")
call s:Def_map('o', '[tef', '<Plug>TxtfmtBckTillFmtEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ef', 'b', 1)<CR>")
call s:Def_map('o', ']tef', '<Plug>TxtfmtFwdTillFmtEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ef', 'f', 1)<CR>")
call s:Def_map('o', '[tec', '<Plug>TxtfmtBckTillClrEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ec', 'b', 1)<CR>")
call s:Def_map('o', ']tec', '<Plug>TxtfmtFwdTillClrEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ec', 'f', 1)<CR>")
call s:Def_map('o', '[tek', '<Plug>TxtfmtBckTillBgcEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ek', 'b', 1)<CR>")
call s:Def_map('o', ']tek', '<Plug>TxtfmtFwdTillBgcEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ek', 'f', 1)<CR>")
call s:Def_map('o', '[tea', '<Plug>TxtfmtBckTillAnyEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ea', 'b', 1)<CR>")
call s:Def_map('o', ']tea', '<Plug>TxtfmtFwdTillAnyEndTok', ":<C-U>call <SID>Jump_to_tok('o', 'ea', 'f', 1)<CR>")
" >>>
" normal mode insert token mappings <<<
" These mappings may be used from normal mode to insert special tokens.
" Note: The first set leaves cursor in insert mode, and is probably the most
" useful. The second set enters insert mode to do the insert and puts cursor
" at correct offset prior to returning to normal mode. Works just like
" inserting the token, then hitting <Esc>.
" TODO - This one is redundant to the \vi one - use the latter instead for
" notational consistency?
call s:Def_map('n', '<C-\><C-\>', '<Plug>TxtfmtInsertTok_n',
			\":<C-U>call <SID>Insert_tokstr('', 'i', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
" Start in normal / End in insert
call s:Def_map('n', '<LocalLeader>i', '<Plug>TxtfmtInsertTok_i',
			\":<C-U>call <SID>Insert_tokstr('', 'i', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>I', '<Plug>TxtfmtInsertTok_I',
			\":<C-U>call <SID>Insert_tokstr('', 'I', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>a', '<Plug>TxtfmtInsertTok_a',
			\":<C-U>call <SID>Insert_tokstr('', 'a', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>A', '<Plug>TxtfmtInsertTok_A',
			\":<C-U>call <SID>Insert_tokstr('', 'A', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>o', '<Plug>TxtfmtInsertTok_o',
			\":<C-U>call <SID>Insert_tokstr('', 'o', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>O', '<Plug>TxtfmtInsertTok_O',
			\":<C-U>call <SID>Insert_tokstr('', 'O', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>s', '<Plug>TxtfmtInsertTok_s',
			\":<C-U>call <SID>Insert_tokstr('', 's', 0, 0)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
" Start in normal / End in normal
call s:Def_map('n', '<LocalLeader>vi', '<Plug>TxtfmtInsertTok_vi',
			\":<C-U>call <SID>Insert_tokstr('', 'i', 0, 1)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>vI', '<Plug>TxtfmtInsertTok_vI',
			\":<C-U>call <SID>Insert_tokstr('', 'I', 0, 1)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>va', '<Plug>TxtfmtInsertTok_va',
			\":<C-U>call <SID>Insert_tokstr('', 'a', 0, 1)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>vA', '<Plug>TxtfmtInsertTok_vA',
			\":<C-U>call <SID>Insert_tokstr('', 'A', 0, 1)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>vo', '<Plug>TxtfmtInsertTok_vo',
			\":<C-U>call <SID>Insert_tokstr('', 'o', 0, 1)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>vO', '<Plug>TxtfmtInsertTok_vO',
			\":<C-U>call <SID>Insert_tokstr('', 'O', 0, 1)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
call s:Def_map('n', '<LocalLeader>vs', '<Plug>TxtfmtInsertTok_vs',
			\":<C-U>call <SID>Insert_tokstr('', 's', 0, 1)<CR>"
			\.":call <SID>Adjust_cursor()<CR>")
" >>>
" insert mode insert token mappings <<<
" NOTE: Default is to use something that wouldn't be typed as text for the
" insert mode map. User may wish to remap this one to a Function key or
" something else entirely. I find <C-\><C-\> very easy to type...
call s:Def_map('i', '<C-\><C-\>', '<Plug>TxtfmtInsertTok_i',
			\"<C-R>=<SID>Insert_tokstr('', 'i', 0, 0)<CR>"
			\."<C-R>=<SID>Adjust_cursor()<CR>")
" >>>
" normal mode get token info mapping <<<
call s:Def_map('n', '<LocalLeader>ga', '<Plug>TxtfmtGetTokInfo',
			\":<C-U>echo <SID>GetTokInfo()<CR>")
" >>>
" NOTES <<<
" -enterinsert default is 'i'
" -mode default is 'ni'
" -<C-0> can't be used in insert-mode mapping for some reason...
" >>>
" TODO <<<
" -Convert ASCII only pattern character classes to ones that will work with
" multi-byte chars
" -Add commands/functions for detecting and altering the range of character
"  codes used for txtfmt tokens.
" -Use syntax clusters instead of the double definition trickery I used when I
"  didn't know about syntax clusters.
" >>>
" >>>
" Restore compatibility options <<<
" Restore compatibility options to what they were
let &cpo = s:save_cpo
" >>>
	" vim: sw=4 ts=4 foldmethod=marker foldmarker=<<<,>>> :
syntax/txtfmt.vim	[[[1
2262
" Txtfmt: Set of Vim plugins (syntax, ftplugin, plugin) for creating and
" displaying formatted text with Vim.
" File: This is the txtfmt syntax file
" Creation:	2004 Nov 06
" Last Change: 2010 Sep 04
" Maintainer:	Brett Pershing Stahlman <brettstahlman@comcast.net>
" License:	This file is placed in the public domain.
" Let the common code know whether this is syntax file or ftplugin

let s:script_name = 'syntax'
" Constants <<<
" >>>
" Common Configuration <<<
" Note: No point in having the modeline and/or global options processed by
" both the syntax and ftplugin files.
" IMPORTANT: Everything inside the "Common Configuration" fold should be
" identical between the syntax and ftplugin files. Keep in sync as changes are
" made...
if !exists('b:txtfmt_did_common_config')
	let b:txtfmt_did_common_config = 1
	" Ensure that the code within plugin/txtfmt.vim will be executed when the
	" file is sourced.
	let b:txtfmt_do_common_config = 1
	" TODO - Should we ensure that warning occurs for missing file?
	runtime plugin/txtfmt.vim 
	" Make sure the common config doesn't run again
	unlet b:txtfmt_do_common_config

endif
" >>>
" Config <<<
" Needed only for syntax file
" Note: Performed after the Common Configuration, which sets the 'escape'
" option, needed when defining syntax
" Function: s:Do_config() <<<
" Purpose: Do configuration required only for syntax file.
" Assumption: Common config has already been performed, so that needed options
" have been set.
fu! s:Do_config()
	" Nothing to do here now that skip def is defined in Define_syntax
	" TODO...
endfu
" >>>
call s:Do_config()
" >>>
" Function: s:Winrestcmd() <<<
" Purpose: Works just like Vim's winrestcmd, which was added in Vim 6.3,
" (and therefore, is not something I want to rely upon). Returns a
" string that can be :execute'd to restore the current window layout,
" assuming exactly the same set of windows exist when the string is
" exe'd.
" Note: winrestcmd() format looks like this:
" 1resize <height1>|vert 1resize <width1>| ... Nresize <heightN>|vert Nresize <widthN>|
" Note how the final element is terminated by a vertical bar.
" Testing: Verified for non-trivial window layout that winrestcmd() and
" this function return the same string.
fu! s:Winrestcmd()
	let i = 1
	let N = winnr('$')
	let cmd = ''
	while i <= N
		let cmd = cmd . i . 'resize ' . winheight(i) . '|vert ' . i . 'resize ' . winwidth(i) . '|'
		let i = i + 1
	endwhile
	return cmd
endfu
" >>>
" Function: s:Create_scratch_buffer() <<<
" Purpose: Create an empty scratch buffer in the current window, hiding
" the current buffer.
" Assumption: The hidden buffer will be restored by a call to
" s:Cleanup_scratch_buffer() later.
" Vim Idiosyncrasy: Special care must be taken when the current window
" contains an empty, [No Name] buffer; in that case, :hide enew will, by
" default, reuse that buffer for the newly created one (discarding any
" existing buf-local variables). This is problematic, since we need to
" return to the original buffer when we're finished with the scratch
" buffer. Note that in some cases, Txtfmt options may already have been
" stored to buf-local variables in the empty, [No Name] buffer before
" this function is called.
" Solution: Bram suggested adding a blank line to the original buffer to
" ensure it isn't reused. The blank line can be removed in the
" s:Cleanup_scratch_buffer() function.
" Note: Before this function was added, the scratch buffer was created
" in a new window. The problem with that approach was that it fails when
" there's no room to create another window.
fu! s:Create_scratch_buffer()
	" See whether the current buffer is an empty, unnamed buffer that
	" will be discarded by the :hide enew below.
	if line('$') == 1 && col('$') == 1 && bufname('%') == ''
		" Current buffer is an empty, unnamed buffer
		" To prevent its being discarded by :hide enew, add a blank
		" line, which we'll remove in the associated cleanup function
		" Make sure the buffer is modifiable, taking care to save and restore
		" current setting.
		let modifiable_save = &l:modifiable
		setlocal modifiable
		call append(1, '')
		let &l:modifiable = modifiable_save
		let s:Added_blank_line_to_empty_buffer = 1
	endif
	" Create the scratch buffer
	hide enew
	set buftype=nofile
	set bufhidden=wipe
	set noswapfile
	" The following setlocal is necessary to prevent E21 in the event that
	" 'nomodifiable' is set globally.
	setlocal modifiable
endfu
" >>>
" Function: s:Cleanup_scratch_buffer() <<<
" Purpose: Wipe out the scratch buffer in the current window, restoring
" the buffer it supplanted.
" Assumption: s:Create_scratch_buffer() was called to create the scratch
" buffer in the current window.
fu! s:Cleanup_scratch_buffer()
	" Return to the buffer that was current when the associated create
	" function was called
	" Note: The scratch buffer 'bufhidden' option will ensure that it's
	" bwipe'd
	buffer #
	if exists('s:Added_blank_line_to_empty_buffer')
		unlet s:Added_blank_line_to_empty_buffer
		" Get rid of the blank line we added in the associated create
		" function.
		" Note: Make sure the buffer is modifiable, taking care to save and
		" restore current setting.
		let modifiable_save = &l:modifiable
		setlocal modifiable
		undo
		let &l:modifiable = modifiable_save
	endif
endfu
" >>>
" Function: s:Is_match_offset_char_based() <<<
" Purpose: Return nonzero if and only if the this version of Vim treats match
" offsets as character offsets.
" Assumption: Current encoding is multi-byte
fu! s:Is_match_offset_char_based()
	let s = "AB" . nr2char(0x100) . 'C'
	" Set lazyredraw to ensure user never sees the buffer we create
	let lazyredraw_save = &lazyredraw
	set lazyredraw
	" Create a scratch buffer in the current window
	call s:Create_scratch_buffer()
	" Put the test string at the head of the new scratch buffer
	call setline(1, s)
	" Create syntax region that will include the last character on the line if
	" and only if this Vim treats match offsets as char offsets
	syn match Tf_Test /AB/me=e+2,he=e+2
	" Is the last char in the Tf_Test syntax group?
	if synIDattr(synID(line("."), col("$") - 1, 1), "name") == 'Tf_Test'
		let off_is_char = 1
	else
		let off_is_char = 0
	endif
	" Clean up the scratch buffer, returning to the previous buffer
	call s:Cleanup_scratch_buffer()
	" Restore old lazyredraw setting
	if !lazyredraw_save
		set nolazyredraw
	endif
	" Return true if and only if offsets are char-based
	return off_is_char
endfu
" >>>
" Function: s:Get_bytes_per_token() <<<
" Purpose: Return the number of bytes used to encode the first Txtfmt token,
" warning user if this number is different from the number of bytes used to
" encode the last.
" Assumption: # of bytes per token will never decrease as character codes
" increase
fu! s:Get_bytes_per_token()
	let num_bytes = strlen(nr2char(b:txtfmt_clr_first_tok))
	" Make sure first and last token comprise the same number of bytes,
	" and warn user if not...
	if num_bytes != strlen(nr2char(b:txtfmt_fmt_last_tok))
		" Note: Txtfmt highlighting will probably be incorrect, but there's
		" not much we can do about it other than warn user...
		echohl WarningMsg
		echomsg "Warning! The 'tokrange' setting you have chosen may not work correctly"
		echomsg "because not all tokens within the range are encoded with the same number"
		echomsg "of bytes. If fmt/clr regions do not display correctly, you should either"
		echomsg "choose a different 'tokrange', or apply the multi-byte patch included with"
		echomsg "the plugin."
		echohl Comment
		echomsg "    :help txtfmt-choosing-token-range"
		echohl MoreMsg
		echomsg "Hit any key to continue..."
		echohl None
		call getchar()
	endif
	" Return # of bytes used by first token
	return num_bytes
endfu
" >>>
" Function: s:Define_syntax() <<<
fu! s:Define_syntax()
	" Define a convenience flag that indicates whether background colors are
	" in effect
	let bgc_enabled = b:txtfmt_cfg_bgcolor && b:txtfmt_cfg_numbgcolors > 0
	let clr_enabled = b:txtfmt_cfg_numfgcolors > 0

	" cui (color uniqueness index) will contain a different index for each
	" color configuration (and will be empty string in the unlikely event that
	" both numfgcolors and numbgcolors are 0 - i.e., no colors used)
	" Note: This strategy is necessary because Vim's highlight groups are not
	" buffer-specific, but there is a buffer-specific version of txtfmtColor{}
	let cui = b:txtfmt_color_uniq_idx

	" Concealment group <<<
	" Create a concealment highlight group, to which others can link
	" The Ignore group is a preferred group, defined in distributed
	" syncolor.vim
	" IMPORTANT NOTE: Some of the distributed colorschemes DO NOT hide text in
	" the Ignore group. I disagree with this practice, and have posted to the
	" Vim list on the subject, but the situation is unlikely to change...
	" Fortunately, there is a workaround that always works for the GUI,and
	" sometimes works for a cterm.
	" Workaround: *Attempt* to define fg=bg. This will always work for the
	" GUI, and will work for a cterm if the colorscheme has defined ctermbg
	" for the Normal group. If the attempt fails, simply link to Ignore group,
	" which may or may not hide text.
	if has('gui_running')
		hi Tf_conceal guifg=bg
	else
		let v:errmsg = ""
		silent! hi Tf_conceal ctermfg=bg
		if v:errmsg != ""
			" Link to Ignore and put suggestions in help file for users of
			" colorschemes that don't hide Ignore'd text.
			hi link Tf_conceal Ignore
		endif
	endif
	" Check for existence of 'conceal' patch (and desire on part of user to
	" use it)
	if b:txtfmt_cfg_conceal
		" Note: 'conceallevel' and 'concealcursor' are window-local
		setl conceallevel=3
		let &l:concealcursor = b:txtfmt_cfg_concealcursor
		let concealends = ' concealends'
		let conceal = ' conceal'
	else
		let concealends = ''
		let conceal = ''
	endif
	" >>>
	" Define match offset that corresponds to a single txtfmt token <<<
	" Note: This is required because of a Vim bug: as of Vim 7.1, syntax match
	" offsets are always treated as byte offsets, though the documentation
	" suggests offsets are char-based. There is a patch floating around,
	" however, which fixes this; also, Vim 7.2 *may* fix it; thus, it's not
	" safe to assume anything about whether the running Vim uses byte or char
	" offsets. If necessary, Is_match_offset_char_based will find out.
	" Note: Eventually, the if and first elseif can be combined, but for now,
	" I want to set b:txtfmt_dbg_syn_off as a debug var, in case any users
	" experience problems...
	if b:txtfmt_cfg_enc_class == '1'
		let tok_off = 1
		" Nonexistence of b:txtfmt_dbg_syn_off indicates
		" Is_match_offset_char_based wasn't run
		unlet! b:txtfmt_dbg_syn_off
	silent elseif s:Is_match_offset_char_based()
		let tok_off = 1
		let b:txtfmt_dbg_syn_off = 'char'
	else
		" Offsets are measured in bytes; hence, we need to determine how many
		" bytes per token
		let tok_off = s:Get_bytes_per_token()
		let b:txtfmt_dbg_syn_off = 'byte'
	endif
	" >>>
	" 'containedin' list (option dependent) <<<
	if b:txtfmt_cfg_nested
		" Ensure that txtfmt top-level item can be contained by a non-txtfmt
		" syntax group (e.g. C-language comment).
		" TODO - Perhaps put inner_esc groups into a cluster.
		if b:txtfmt_cfg_escape != 'none'
			let containedin_def = ' containedin=ALLBUT,@Tf'.cui.'_all,Tf_def_tok'
						\.',Tf_outer_esc,Tf_any_stok_inner_esc'
						\.(clr_enabled ? ',Tf_clr_etok_inner_esc' : '')
						\.(bgc_enabled ? ',Tf_bgc_etok_inner_esc' : '').',Tf_fmt_etok_inner_esc'
		else
			let containedin_def = ' containedin=ALLBUT,@Tf'.cui.'_all,Tf_def_tok'
		endif
	else
		let containedin_def = ''
	endif
	" >>>
	" Define special default token group <<<
	" This group ensures that 'no clr', 'no bgc', and 'no fmt' tokens at top
	" level (including those that end a clr only, bgc only, or fmt only group)
	" will be concealed.
	" Order note: This region is defined here to ensure that it has a lower
	" priority than any of the other txtfmt regions that can be begun by a
	" default token.
	exe 'syn match Tf_def_tok /['.b:txtfmt_re_any_etok_atom.']/ contained'.conceal
	hi link Tf_def_tok Tf_conceal
	" >>>
	" Choose cterm or gui versions of color and format assignments
	if has('gui_running')
		let eq_clr = ' guifg='
		let eq_bgc = ' guibg='
		let eq_fmt = ' gui='
	else
		let eq_clr = ' ctermfg='
		let eq_bgc = ' ctermbg='
		let eq_fmt = ' cterm='
	endif
	" NOTES TO PRESERVE
	" TODO - Decide whether the inner_esc regions obviate the need for the
	" skip-def. (I don't think so...)
	" UNDER CONSTRUCTION

	" Create background-color specific concealment groups
	" Note: Use cui to ensure that different buffers could have different sets
	" of background colors in effect
	" Loop over active colors only (with the aid of index indirection array)
	let pi = 1
	while pi <= (b:txtfmt_cfg_bgcolor ? b:txtfmt_cfg_numbgcolors : 0)
		let i = b:txtfmt_cfg_bgcolor{pi}
		exe 'hi Tf'.cui.'_conceal_'.i.' '.eq_bgc.b:txtfmt_bgc{i}.eq_clr.b:txtfmt_bgc{i}
		let pi = pi + 1
	endwhile
	" Create vars to facilitate switching between normal (toplevel)
	" concealment group and background-color-specific groups
	let matchgroup_top_def = ' matchgroup=Tf_conceal'
	let matchgroup_def = matchgroup_top_def

	" Important Note: The following line may be executed on the Vim command
	" line to regenerate the code within the BEGIN...<<< / END...>>> markers.
	" The script generating the code is a perl script appended to the end of
	" this file: specifically, between the `#!perl' and the __END__ marker.
	" :0/BEGIN AUTOGENERATED CODE BLOCK <\{3}/;/END AUTOGENERATED CODE BLOCK >\{3}/d|exe '.-1r !perl -x %'|exe "norm '["

	" BEGIN AUTOGENERATED CODE BLOCK <<<
	" Last update: Sun Sep 27 16:16:52 2009

	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	"===
	"*** clr
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_clr=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_clr_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_clr = ' skip=/\\./'
		else
			let skip_clr = ' skip=/\(.\)\1/'
		endif
	else
		let contains_clr = ''
		let skip_clr = ''
	endif
	let end_clr =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.']/me=e-'.tok_off
	let r1_clr =
		\skip_clr
		\.contains_clr
		\.end_clr
		\.containedin_def
	let start_clr =
		\' start=/['
		\.(bgc_enabled ? b:txtfmt_re_bgc_etok_atom : '').b:txtfmt_re_fmt_etok_atom
		\.']/'
	let r2_clr =
		\skip_clr
		\.contains_clr
		\.start_clr
		\.end_clr
		\.' contained'
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	"===
	"*** clr-bgc
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_clrbgc=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_clr_etok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_clrbgc = ' skip=/\\./'
		else
			let skip_clrbgc = ' skip=/\(.\)\1/'
		endif
	else
		let contains_clrbgc = ''
		let skip_clrbgc = ''
	endif
	let end_clrbgc =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.']/me=e-'.tok_off
	let r1_clrbgc =
		\skip_clrbgc
		\.contains_clrbgc
		\.end_clrbgc
		\.' contained'
	let start_clrbgc =
		\' start=/['
		\.b:txtfmt_re_fmt_etok_atom
		\.']/'
	let r2_clrbgc =
		\skip_clrbgc
		\.contains_clrbgc
		\.start_clrbgc
		\.end_clrbgc
		\.' contained'
	"===
	"*** clr-bgc-fmt
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_clrbgcfmt=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_clr_etok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_clrbgcfmt = ' skip=/\\./'
		else
			let skip_clrbgcfmt = ' skip=/\(.\)\1/'
		endif
	else
		let contains_clrbgcfmt = ''
		let skip_clrbgcfmt = ''
	endif
	let end_clrbgcfmt =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.']/me=e-'.tok_off
	let r1_clrbgcfmt =
		\skip_clrbgcfmt
		\.contains_clrbgcfmt
		\.end_clrbgcfmt
		\.' contained'
	" Revert to toplevel (no background color) matchgroup
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"===
	"*** clr-fmt
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_clrfmt=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_clr_etok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_clrfmt = ' skip=/\\./'
		else
			let skip_clrfmt = ' skip=/\(.\)\1/'
		endif
	else
		let contains_clrfmt = ''
		let skip_clrfmt = ''
	endif
	let end_clrfmt =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.']/me=e-'.tok_off
	let r1_clrfmt =
		\skip_clrfmt
		\.contains_clrfmt
		\.end_clrfmt
		\.' contained'
	" Define the r2 region vars if and only if at least one of the
	" region types whose end token could begin this region is active
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	let start_clrfmt =
		\' start=/['
		\.b:txtfmt_re_bgc_etok_atom
		\.']/'
	let r2_clrfmt =
		\skip_clrfmt
		\.contains_clrfmt
		\.start_clrfmt
		\.end_clrfmt
		\.' contained'
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	"===
	"*** clr-fmt-bgc
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_clrfmtbgc=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_clr_etok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_clrfmtbgc = ' skip=/\\./'
		else
			let skip_clrfmtbgc = ' skip=/\(.\)\1/'
		endif
	else
		let contains_clrfmtbgc = ''
		let skip_clrfmtbgc = ''
	endif
	let end_clrfmtbgc =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.']/me=e-'.tok_off
	let r1_clrfmtbgc =
		\skip_clrfmtbgc
		\.contains_clrfmtbgc
		\.end_clrfmtbgc
		\.' contained'
	" Revert to toplevel (no background color) matchgroup
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	"===
	"*** bgc
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_bgc=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_bgc = ' skip=/\\./'
		else
			let skip_bgc = ' skip=/\(.\)\1/'
		endif
	else
		let contains_bgc = ''
		let skip_bgc = ''
	endif
	let end_bgc =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.']/me=e-'.tok_off
	let r1_bgc =
		\skip_bgc
		\.contains_bgc
		\.end_bgc
		\.containedin_def
	let start_bgc =
		\' start=/['
		\.(clr_enabled ? b:txtfmt_re_clr_etok_atom : '').b:txtfmt_re_fmt_etok_atom
		\.']/'
	let r2_bgc =
		\skip_bgc
		\.contains_bgc
		\.start_bgc
		\.end_bgc
		\.' contained'
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	"===
	"*** bgc-clr
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_bgcclr=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc,'
			\.'Tf_clr_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_bgcclr = ' skip=/\\./'
		else
			let skip_bgcclr = ' skip=/\(.\)\1/'
		endif
	else
		let contains_bgcclr = ''
		let skip_bgcclr = ''
	endif
	let end_bgcclr =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.']/me=e-'.tok_off
	let r1_bgcclr =
		\skip_bgcclr
		\.contains_bgcclr
		\.end_bgcclr
		\.' contained'
	let start_bgcclr =
		\' start=/['
		\.b:txtfmt_re_fmt_etok_atom
		\.']/'
	let r2_bgcclr =
		\skip_bgcclr
		\.contains_bgcclr
		\.start_bgcclr
		\.end_bgcclr
		\.' contained'
	"===
	"*** bgc-clr-fmt
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_bgcclrfmt=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc,'
			\.'Tf_clr_etok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_bgcclrfmt = ' skip=/\\./'
		else
			let skip_bgcclrfmt = ' skip=/\(.\)\1/'
		endif
	else
		let contains_bgcclrfmt = ''
		let skip_bgcclrfmt = ''
	endif
	let end_bgcclrfmt =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.']/me=e-'.tok_off
	let r1_bgcclrfmt =
		\skip_bgcclrfmt
		\.contains_bgcclrfmt
		\.end_bgcclrfmt
		\.' contained'
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"===
	"*** bgc-fmt
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_bgcfmt=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_bgcfmt = ' skip=/\\./'
		else
			let skip_bgcfmt = ' skip=/\(.\)\1/'
		endif
	else
		let contains_bgcfmt = ''
		let skip_bgcfmt = ''
	endif
	let end_bgcfmt =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.']/me=e-'.tok_off
	let r1_bgcfmt =
		\skip_bgcfmt
		\.contains_bgcfmt
		\.end_bgcfmt
		\.' contained'
	" Define the r2 region vars if and only if at least one of the
	" region types whose end token could begin this region is active
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	let start_bgcfmt =
		\' start=/['
		\.b:txtfmt_re_clr_etok_atom
		\.']/'
	let r2_bgcfmt =
		\skip_bgcfmt
		\.contains_bgcfmt
		\.start_bgcfmt
		\.end_bgcfmt
		\.' contained'
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	"===
	"*** bgc-fmt-clr
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_bgcfmtclr=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc,'
			\.'Tf_clr_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_bgcfmtclr = ' skip=/\\./'
		else
			let skip_bgcfmtclr = ' skip=/\(.\)\1/'
		endif
	else
		let contains_bgcfmtclr = ''
		let skip_bgcfmtclr = ''
	endif
	let end_bgcfmtclr =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.']/me=e-'.tok_off
	let r1_bgcfmtclr =
		\skip_bgcfmtclr
		\.contains_bgcfmtclr
		\.end_bgcfmtclr
		\.' contained'
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	" Revert to toplevel (no background color) matchgroup
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"===
	"*** fmt
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_fmt=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_fmt = ' skip=/\\./'
		else
			let skip_fmt = ' skip=/\(.\)\1/'
		endif
	else
		let contains_fmt = ''
		let skip_fmt = ''
	endif
	let end_fmt =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.']/me=e-'.tok_off
	let r1_fmt =
		\skip_fmt
		\.contains_fmt
		\.end_fmt
		\.containedin_def
	" Define the r2 region vars if and only if at least one of the
	" region types whose end token could begin this region is active
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled || bgc_enabled
	let start_fmt =
		\' start=/['
		\.(clr_enabled ? b:txtfmt_re_clr_etok_atom : '').(bgc_enabled ? b:txtfmt_re_bgc_etok_atom : '')
		\.']/'
	let r2_fmt =
		\skip_fmt
		\.contains_fmt
		\.start_fmt
		\.end_fmt
		\.' contained'
	endif " clr_enabled || bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	"===
	"*** fmt-clr
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_fmtclr=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc,'
			\.'Tf_clr_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_fmtclr = ' skip=/\\./'
		else
			let skip_fmtclr = ' skip=/\(.\)\1/'
		endif
	else
		let contains_fmtclr = ''
		let skip_fmtclr = ''
	endif
	let end_fmtclr =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.']/me=e-'.tok_off
	let r1_fmtclr =
		\skip_fmtclr
		\.contains_fmtclr
		\.end_fmtclr
		\.' contained'
	" Define the r2 region vars if and only if at least one of the
	" region types whose end token could begin this region is active
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	let start_fmtclr =
		\' start=/['
		\.b:txtfmt_re_bgc_etok_atom
		\.']/'
	let r2_fmtclr =
		\skip_fmtclr
		\.contains_fmtclr
		\.start_fmtclr
		\.end_fmtclr
		\.' contained'
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	"===
	"*** fmt-clr-bgc
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_fmtclrbgc=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc,'
			\.'Tf_clr_etok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_fmtclrbgc = ' skip=/\\./'
		else
			let skip_fmtclrbgc = ' skip=/\(.\)\1/'
		endif
	else
		let contains_fmtclrbgc = ''
		let skip_fmtclrbgc = ''
	endif
	let end_fmtclrbgc =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.']/me=e-'.tok_off
	let r1_fmtclrbgc =
		\skip_fmtclrbgc
		\.contains_fmtclrbgc
		\.end_fmtclrbgc
		\.' contained'
	" Revert to toplevel (no background color) matchgroup
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	"===
	"*** fmt-bgc
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_fmtbgc=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_fmtbgc = ' skip=/\\./'
		else
			let skip_fmtbgc = ' skip=/\(.\)\1/'
		endif
	else
		let contains_fmtbgc = ''
		let skip_fmtbgc = ''
	endif
	let end_fmtbgc =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.']/me=e-'.tok_off
	let r1_fmtbgc =
		\skip_fmtbgc
		\.contains_fmtbgc
		\.end_fmtbgc
		\.' contained'
	" Define the r2 region vars if and only if at least one of the
	" region types whose end token could begin this region is active
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	let start_fmtbgc =
		\' start=/['
		\.b:txtfmt_re_clr_etok_atom
		\.']/'
	let r2_fmtbgc =
		\skip_fmtbgc
		\.contains_fmtbgc
		\.start_fmtbgc
		\.end_fmtbgc
		\.' contained'
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	"===
	"*** fmt-bgc-clr
	"===
	if b:txtfmt_cfg_escape != 'none'
		let contains_fmtbgcclr=
			\' contains='
			\.'Tf_any_stok_inner_esc,'
			\.'Tf_fmt_etok_inner_esc,'
			\.'Tf_bgc_etok_inner_esc,'
			\.'Tf_clr_etok_inner_esc'
		if b:txtfmt_cfg_escape == 'bslash'
			let skip_fmtbgcclr = ' skip=/\\./'
		else
			let skip_fmtbgcclr = ' skip=/\(.\)\1/'
		endif
	else
		let contains_fmtbgcclr = ''
		let skip_fmtbgcclr = ''
	endif
	let end_fmtbgcclr =
		\' end=/['
		\.b:txtfmt_re_any_stok_atom
		\.b:txtfmt_re_fmt_etok_atom
		\.b:txtfmt_re_bgc_etok_atom
		\.b:txtfmt_re_clr_etok_atom
		\.']/me=e-'.tok_off
	let r1_fmtbgcclr =
		\skip_fmtbgcclr
		\.contains_fmtbgcclr
		\.end_fmtbgcclr
		\.' contained'
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	" Revert to toplevel (no background color) matchgroup
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if clr_enabled
	"===
	"*** Loop over clr levels
	"===
	let ip = 1
	while ip <= b:txtfmt_cfg_numfgcolors
		let i = b:txtfmt_cfg_fgcolor{ip}
		let chi = nr2char(b:txtfmt_clr_first_tok + i)
		" Add to appropriate clusters
		exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_clr_'.i
		exe 'syn cluster Tf'.cui.'_clr_all add=Tf'.cui.'_clr_'.i
		" Cache the nextgroup clause
		let ng = ' nextgroup=@Tf'.cui.'_clr_all'.(bgc_enabled ? ',@Tf'.cui.'_clrbgc_'.i.'_all' : '').',@Tf'.cui.'_clrfmt_'.i.'_all,Tf_def_tok'
		" Define region that is begun by a start token
		exe 'syn region Tf'.cui.'_clr_'.i.matchgroup_def
			\.' start=/'.chi.'/'.r1_clr.ng.concealends
		" Define region that is begun by an end token
		" (when permitted by a nextgroup)
		exe 'syn region Tf'.cui.'_clr_'.i.'_rtd'.matchgroup_def
			\.r2_clr.ng.concealends
		" Define highlighting for this region
		" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
		" handled correctly in a cterm.
		"	:help cterm-colors
		exe 'hi Tf'.cui.'_clr_'.i
			\.eq_clr.b:txtfmt_clr{i}
		" Link rtd to non-rtd group
		exe 'hi link Tf'.cui.'_clr_'.i.'_rtd Tf'.cui.'_clr_'.i
		"============= BEGIN NON-INDENTING BLOCK =============
		if bgc_enabled
		"===
		"*** Loop over clr-bgc levels
		"===
		let jp = 1
		while jp <= b:txtfmt_cfg_numbgcolors
			let j = b:txtfmt_cfg_bgcolor{jp}
			let chj = nr2char(b:txtfmt_bgc_first_tok + j)
			" Add to appropriate clusters
			exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_clrbgc_'.i.'_'.j
			exe 'syn cluster Tf'.cui.'_clrbgc_'.i.'_all add=Tf'.cui.'_clrbgc_'.i.'_'.j
			" Ensure that this and higher order regions use bgc-specific concealment group
			let matchgroup_def = ' matchgroup=Tf'.cui.'_conceal_'.j
			" Cache the nextgroup clause
			let ng = ' nextgroup=Tf'.cui.'_bgc_'.j.'_rtd,Tf'.cui.'_clr_'.i.'_rtd,@Tf'.cui.'_bgcclr_'.j.'_all,@Tf'.cui.'_clrbgc_'.i.'_all,@Tf'.cui.'_clrbgcfmt_'.i.'_'.j.'_all'
			" Define region that is begun by a start token
			exe 'syn region Tf'.cui.'_clrbgc_'.i.'_'.j.matchgroup_def
				\.' start=/'.chj.'/'.r1_clrbgc.ng.concealends
			" Define region that is begun by an end token
			" (when permitted by a nextgroup)
			exe 'syn region Tf'.cui.'_clrbgc_'.i.'_'.j.'_rtd'.matchgroup_def
				\.r2_clrbgc.ng.concealends
			" Define highlighting for this region
			" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
			" handled correctly in a cterm.
			"	:help cterm-colors
			exe 'hi Tf'.cui.'_clrbgc_'.i.'_'.j
				\.eq_clr.b:txtfmt_clr{i}.eq_bgc.b:txtfmt_bgc{j}
			" Link rtd to non-rtd group
			exe 'hi link Tf'.cui.'_clrbgc_'.i.'_'.j.'_rtd Tf'.cui.'_clrbgc_'.i.'_'.j
			"===
			"*** Loop over clr-bgc-fmt levels
			"===
			let k = 1
			while k <= b:txtfmt_num_formats - 1
				let chk = nr2char(b:txtfmt_fmt_first_tok + k)
				" Add to appropriate clusters
				exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_clrbgcfmt_'.i.'_'.j.'_'.k
				exe 'syn cluster Tf'.cui.'_clrbgcfmt_'.i.'_'.j.'_all add=Tf'.cui.'_clrbgcfmt_'.i.'_'.j.'_'.k
				" Define region that is begun by a start token
				exe 'syn region Tf'.cui.'_clrbgcfmt_'.i.'_'.j.'_'.k.matchgroup_def
					\.' start=/'.chk.'/'.r1_clrbgcfmt.' nextgroup=Tf'.cui.'_bgcfmt_'.j.'_'.k.'_rtd,Tf'.cui.'_clrfmt_'.i.'_'.k.'_rtd,Tf'.cui.'_clrbgc_'.i.'_'.j.'_rtd,@Tf'.cui.'_bgcfmtclr_'.j.'_'.k.'_all,@Tf'.cui.'_clrfmtbgc_'.i.'_'.k.'_all,@Tf'.cui.'_clrbgcfmt_'.i.'_'.j.'_all'.concealends
				" Define highlighting for this region
				" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
				" handled correctly in a cterm.
				"	:help cterm-colors
				exe 'hi Tf'.cui.'_clrbgcfmt_'.i.'_'.j.'_'.k
					\.eq_clr.b:txtfmt_clr{i}.eq_bgc.b:txtfmt_bgc{j}.eq_fmt.b:txtfmt_fmt{k}
				let k = k + 1
			endwhile
			let jp = jp + 1
		endwhile
		" Revert to toplevel (no background color) matchgroup
		let matchgroup_def = matchgroup_top_def
		endif " bgc_enabled
		"=============  END NON-INDENTING BLOCK  =============
		"===
		"*** Loop over clr-fmt levels
		"===
		let j = 1
		while j <= b:txtfmt_num_formats - 1
			let chj = nr2char(b:txtfmt_fmt_first_tok + j)
			" Add to appropriate clusters
			exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_clrfmt_'.i.'_'.j
			exe 'syn cluster Tf'.cui.'_clrfmt_'.i.'_all add=Tf'.cui.'_clrfmt_'.i.'_'.j
			" Cache the nextgroup clause
			let ng = ' nextgroup=Tf'.cui.'_fmt_'.j.'_rtd,Tf'.cui.'_clr_'.i.'_rtd,@Tf'.cui.'_fmtclr_'.j.'_all,@Tf'.cui.'_clrfmt_'.i.'_all'.(bgc_enabled ? ',@Tf'.cui.'_clrfmtbgc_'.i.'_'.j.'_all' : '')
			" Define region that is begun by a start token
			exe 'syn region Tf'.cui.'_clrfmt_'.i.'_'.j.matchgroup_def
				\.' start=/'.chj.'/'.r1_clrfmt.ng.concealends
			" Define the following region if and only if at least one of the
			" region types whose end token could begin this region is active
			"============= BEGIN NON-INDENTING BLOCK =============
			if bgc_enabled
			" Define region that is begun by an end token
			" (when permitted by a nextgroup)
			exe 'syn region Tf'.cui.'_clrfmt_'.i.'_'.j.'_rtd'.matchgroup_def
				\.r2_clrfmt.ng.concealends
			endif " bgc_enabled
			"=============  END NON-INDENTING BLOCK  =============
			" Define highlighting for this region
			" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
			" handled correctly in a cterm.
			"	:help cterm-colors
			exe 'hi Tf'.cui.'_clrfmt_'.i.'_'.j
				\.eq_clr.b:txtfmt_clr{i}.eq_fmt.b:txtfmt_fmt{j}
			" Link rtd to non-rtd group
			exe 'hi link Tf'.cui.'_clrfmt_'.i.'_'.j.'_rtd Tf'.cui.'_clrfmt_'.i.'_'.j
			"============= BEGIN NON-INDENTING BLOCK =============
			if bgc_enabled
			"===
			"*** Loop over clr-fmt-bgc levels
			"===
			let kp = 1
			while kp <= b:txtfmt_cfg_numbgcolors
				let k = b:txtfmt_cfg_bgcolor{kp}
				let chk = nr2char(b:txtfmt_bgc_first_tok + k)
				" Add to appropriate clusters
				exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_clrfmtbgc_'.i.'_'.j.'_'.k
				exe 'syn cluster Tf'.cui.'_clrfmtbgc_'.i.'_'.j.'_all add=Tf'.cui.'_clrfmtbgc_'.i.'_'.j.'_'.k
				" Ensure that this and higher order regions use bgc-specific concealment group
				let matchgroup_def = ' matchgroup=Tf'.cui.'_conceal_'.k
				" Define region that is begun by a start token
				exe 'syn region Tf'.cui.'_clrfmtbgc_'.i.'_'.j.'_'.k.matchgroup_def
					\.' start=/'.chk.'/'.r1_clrfmtbgc.' nextgroup=Tf'.cui.'_fmtbgc_'.j.'_'.k.'_rtd,Tf'.cui.'_clrbgc_'.i.'_'.k.'_rtd,Tf'.cui.'_clrfmt_'.i.'_'.j.'_rtd,@Tf'.cui.'_fmtbgcclr_'.j.'_'.k.'_all,@Tf'.cui.'_clrbgcfmt_'.i.'_'.k.'_all,@Tf'.cui.'_clrfmtbgc_'.i.'_'.j.'_all'.concealends
				" Define highlighting for this region
				" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
				" handled correctly in a cterm.
				"	:help cterm-colors
				exe 'hi Tf'.cui.'_clrfmtbgc_'.i.'_'.j.'_'.k
					\.eq_clr.b:txtfmt_clr{i}.eq_bgc.b:txtfmt_bgc{k}.eq_fmt.b:txtfmt_fmt{j}
				let kp = kp + 1
			endwhile
			" Revert to toplevel (no background color) matchgroup
			let matchgroup_def = matchgroup_top_def
			endif " bgc_enabled
			"=============  END NON-INDENTING BLOCK  =============
			let j = j + 1
		endwhile
		let ip = ip + 1
	endwhile
	endif " clr_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"============= BEGIN NON-INDENTING BLOCK =============
	if bgc_enabled
	"===
	"*** Loop over bgc levels
	"===
	let ip = 1
	while ip <= b:txtfmt_cfg_numbgcolors
		let i = b:txtfmt_cfg_bgcolor{ip}
		let chi = nr2char(b:txtfmt_bgc_first_tok + i)
		" Add to appropriate clusters
		exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_bgc_'.i
		exe 'syn cluster Tf'.cui.'_bgc_all add=Tf'.cui.'_bgc_'.i
		" Ensure that this and higher order regions use bgc-specific concealment group
		let matchgroup_def = ' matchgroup=Tf'.cui.'_conceal_'.i
		" Cache the nextgroup clause
		let ng = ' nextgroup=@Tf'.cui.'_bgc_all'.(clr_enabled ? ',@Tf'.cui.'_bgcclr_'.i.'_all' : '').',@Tf'.cui.'_bgcfmt_'.i.'_all,Tf_def_tok'
		" Define region that is begun by a start token
		exe 'syn region Tf'.cui.'_bgc_'.i.matchgroup_def
			\.' start=/'.chi.'/'.r1_bgc.ng.concealends
		" Define region that is begun by an end token
		" (when permitted by a nextgroup)
		exe 'syn region Tf'.cui.'_bgc_'.i.'_rtd'.matchgroup_def
			\.r2_bgc.ng.concealends
		" Define highlighting for this region
		" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
		" handled correctly in a cterm.
		"	:help cterm-colors
		exe 'hi Tf'.cui.'_bgc_'.i
			\.eq_bgc.b:txtfmt_bgc{i}
		" Link rtd to non-rtd group
		exe 'hi link Tf'.cui.'_bgc_'.i.'_rtd Tf'.cui.'_bgc_'.i
		"============= BEGIN NON-INDENTING BLOCK =============
		if clr_enabled
		"===
		"*** Loop over bgc-clr levels
		"===
		let jp = 1
		while jp <= b:txtfmt_cfg_numfgcolors
			let j = b:txtfmt_cfg_fgcolor{jp}
			let chj = nr2char(b:txtfmt_clr_first_tok + j)
			" Add to appropriate clusters
			exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_bgcclr_'.i.'_'.j
			exe 'syn cluster Tf'.cui.'_bgcclr_'.i.'_all add=Tf'.cui.'_bgcclr_'.i.'_'.j
			" Cache the nextgroup clause
			let ng = ' nextgroup=Tf'.cui.'_clr_'.j.'_rtd,Tf'.cui.'_bgc_'.i.'_rtd,@Tf'.cui.'_clrbgc_'.j.'_all,@Tf'.cui.'_bgcclr_'.i.'_all,@Tf'.cui.'_bgcclrfmt_'.i.'_'.j.'_all'
			" Define region that is begun by a start token
			exe 'syn region Tf'.cui.'_bgcclr_'.i.'_'.j.matchgroup_def
				\.' start=/'.chj.'/'.r1_bgcclr.ng.concealends
			" Define region that is begun by an end token
			" (when permitted by a nextgroup)
			exe 'syn region Tf'.cui.'_bgcclr_'.i.'_'.j.'_rtd'.matchgroup_def
				\.r2_bgcclr.ng.concealends
			" Define highlighting for this region
			" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
			" handled correctly in a cterm.
			"	:help cterm-colors
			exe 'hi Tf'.cui.'_bgcclr_'.i.'_'.j
				\.eq_clr.b:txtfmt_clr{j}.eq_bgc.b:txtfmt_bgc{i}
			" Link rtd to non-rtd group
			exe 'hi link Tf'.cui.'_bgcclr_'.i.'_'.j.'_rtd Tf'.cui.'_bgcclr_'.i.'_'.j
			"===
			"*** Loop over bgc-clr-fmt levels
			"===
			let k = 1
			while k <= b:txtfmt_num_formats - 1
				let chk = nr2char(b:txtfmt_fmt_first_tok + k)
				" Add to appropriate clusters
				exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_bgcclrfmt_'.i.'_'.j.'_'.k
				exe 'syn cluster Tf'.cui.'_bgcclrfmt_'.i.'_'.j.'_all add=Tf'.cui.'_bgcclrfmt_'.i.'_'.j.'_'.k
				" Define region that is begun by a start token
				exe 'syn region Tf'.cui.'_bgcclrfmt_'.i.'_'.j.'_'.k.matchgroup_def
					\.' start=/'.chk.'/'.r1_bgcclrfmt.' nextgroup=Tf'.cui.'_clrfmt_'.j.'_'.k.'_rtd,Tf'.cui.'_bgcfmt_'.i.'_'.k.'_rtd,Tf'.cui.'_bgcclr_'.i.'_'.j.'_rtd,@Tf'.cui.'_clrfmtbgc_'.j.'_'.k.'_all,@Tf'.cui.'_bgcfmtclr_'.i.'_'.k.'_all,@Tf'.cui.'_bgcclrfmt_'.i.'_'.j.'_all'.concealends
				" Define highlighting for this region
				" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
				" handled correctly in a cterm.
				"	:help cterm-colors
				exe 'hi Tf'.cui.'_bgcclrfmt_'.i.'_'.j.'_'.k
					\.eq_clr.b:txtfmt_clr{j}.eq_bgc.b:txtfmt_bgc{i}.eq_fmt.b:txtfmt_fmt{k}
				let k = k + 1
			endwhile
			let jp = jp + 1
		endwhile
		endif " clr_enabled
		"=============  END NON-INDENTING BLOCK  =============
		"===
		"*** Loop over bgc-fmt levels
		"===
		let j = 1
		while j <= b:txtfmt_num_formats - 1
			let chj = nr2char(b:txtfmt_fmt_first_tok + j)
			" Add to appropriate clusters
			exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_bgcfmt_'.i.'_'.j
			exe 'syn cluster Tf'.cui.'_bgcfmt_'.i.'_all add=Tf'.cui.'_bgcfmt_'.i.'_'.j
			" Cache the nextgroup clause
			let ng = ' nextgroup=Tf'.cui.'_fmt_'.j.'_rtd,Tf'.cui.'_bgc_'.i.'_rtd,@Tf'.cui.'_fmtbgc_'.j.'_all,@Tf'.cui.'_bgcfmt_'.i.'_all'.(clr_enabled ? ',@Tf'.cui.'_bgcfmtclr_'.i.'_'.j.'_all' : '')
			" Define region that is begun by a start token
			exe 'syn region Tf'.cui.'_bgcfmt_'.i.'_'.j.matchgroup_def
				\.' start=/'.chj.'/'.r1_bgcfmt.ng.concealends
			" Define the following region if and only if at least one of the
			" region types whose end token could begin this region is active
			"============= BEGIN NON-INDENTING BLOCK =============
			if clr_enabled
			" Define region that is begun by an end token
			" (when permitted by a nextgroup)
			exe 'syn region Tf'.cui.'_bgcfmt_'.i.'_'.j.'_rtd'.matchgroup_def
				\.r2_bgcfmt.ng.concealends
			endif " clr_enabled
			"=============  END NON-INDENTING BLOCK  =============
			" Define highlighting for this region
			" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
			" handled correctly in a cterm.
			"	:help cterm-colors
			exe 'hi Tf'.cui.'_bgcfmt_'.i.'_'.j
				\.eq_bgc.b:txtfmt_bgc{i}.eq_fmt.b:txtfmt_fmt{j}
			" Link rtd to non-rtd group
			exe 'hi link Tf'.cui.'_bgcfmt_'.i.'_'.j.'_rtd Tf'.cui.'_bgcfmt_'.i.'_'.j
			"============= BEGIN NON-INDENTING BLOCK =============
			if clr_enabled
			"===
			"*** Loop over bgc-fmt-clr levels
			"===
			let kp = 1
			while kp <= b:txtfmt_cfg_numfgcolors
				let k = b:txtfmt_cfg_fgcolor{kp}
				let chk = nr2char(b:txtfmt_clr_first_tok + k)
				" Add to appropriate clusters
				exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_bgcfmtclr_'.i.'_'.j.'_'.k
				exe 'syn cluster Tf'.cui.'_bgcfmtclr_'.i.'_'.j.'_all add=Tf'.cui.'_bgcfmtclr_'.i.'_'.j.'_'.k
				" Define region that is begun by a start token
				exe 'syn region Tf'.cui.'_bgcfmtclr_'.i.'_'.j.'_'.k.matchgroup_def
					\.' start=/'.chk.'/'.r1_bgcfmtclr.' nextgroup=Tf'.cui.'_fmtclr_'.j.'_'.k.'_rtd,Tf'.cui.'_bgcclr_'.i.'_'.k.'_rtd,Tf'.cui.'_bgcfmt_'.i.'_'.j.'_rtd,@Tf'.cui.'_fmtclrbgc_'.j.'_'.k.'_all,@Tf'.cui.'_bgcclrfmt_'.i.'_'.k.'_all,@Tf'.cui.'_bgcfmtclr_'.i.'_'.j.'_all'.concealends
				" Define highlighting for this region
				" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
				" handled correctly in a cterm.
				"	:help cterm-colors
				exe 'hi Tf'.cui.'_bgcfmtclr_'.i.'_'.j.'_'.k
					\.eq_clr.b:txtfmt_clr{k}.eq_bgc.b:txtfmt_bgc{i}.eq_fmt.b:txtfmt_fmt{j}
				let kp = kp + 1
			endwhile
			endif " clr_enabled
			"=============  END NON-INDENTING BLOCK  =============
			let j = j + 1
		endwhile
		let ip = ip + 1
	endwhile
	" Revert to toplevel (no background color) matchgroup
	let matchgroup_def = matchgroup_top_def
	endif " bgc_enabled
	"=============  END NON-INDENTING BLOCK  =============
	"===
	"*** Loop over fmt levels
	"===
	let i = 1
	while i <= b:txtfmt_num_formats - 1
		let chi = nr2char(b:txtfmt_fmt_first_tok + i)
		" Add to appropriate clusters
		exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_fmt_'.i
		exe 'syn cluster Tf'.cui.'_fmt_all add=Tf'.cui.'_fmt_'.i
		" Cache the nextgroup clause
		let ng = ' nextgroup=@Tf'.cui.'_fmt_all'.(clr_enabled ? ',@Tf'.cui.'_fmtclr_'.i.'_all' : '').(bgc_enabled ? ',@Tf'.cui.'_fmtbgc_'.i.'_all' : '').',Tf_def_tok'
		" Define region that is begun by a start token
		exe 'syn region Tf'.cui.'_fmt_'.i.matchgroup_def
			\.' start=/'.chi.'/'.r1_fmt.ng.concealends
		" Define the following region if and only if at least one of the
		" region types whose end token could begin this region is active
		"============= BEGIN NON-INDENTING BLOCK =============
		if clr_enabled || bgc_enabled
		" Define region that is begun by an end token
		" (when permitted by a nextgroup)
		exe 'syn region Tf'.cui.'_fmt_'.i.'_rtd'.matchgroup_def
			\.r2_fmt.ng.concealends
		endif " clr_enabled || bgc_enabled
		"=============  END NON-INDENTING BLOCK  =============
		" Define highlighting for this region
		" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
		" handled correctly in a cterm.
		"	:help cterm-colors
		exe 'hi Tf'.cui.'_fmt_'.i
			\.eq_fmt.b:txtfmt_fmt{i}
		" Link rtd to non-rtd group
		exe 'hi link Tf'.cui.'_fmt_'.i.'_rtd Tf'.cui.'_fmt_'.i
		"============= BEGIN NON-INDENTING BLOCK =============
		if clr_enabled
		"===
		"*** Loop over fmt-clr levels
		"===
		let jp = 1
		while jp <= b:txtfmt_cfg_numfgcolors
			let j = b:txtfmt_cfg_fgcolor{jp}
			let chj = nr2char(b:txtfmt_clr_first_tok + j)
			" Add to appropriate clusters
			exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_fmtclr_'.i.'_'.j
			exe 'syn cluster Tf'.cui.'_fmtclr_'.i.'_all add=Tf'.cui.'_fmtclr_'.i.'_'.j
			" Cache the nextgroup clause
			let ng = ' nextgroup=Tf'.cui.'_clr_'.j.'_rtd,Tf'.cui.'_fmt_'.i.'_rtd,@Tf'.cui.'_clrfmt_'.j.'_all,@Tf'.cui.'_fmtclr_'.i.'_all'.(bgc_enabled ? ',@Tf'.cui.'_fmtclrbgc_'.i.'_'.j.'_all' : '')
			" Define region that is begun by a start token
			exe 'syn region Tf'.cui.'_fmtclr_'.i.'_'.j.matchgroup_def
				\.' start=/'.chj.'/'.r1_fmtclr.ng.concealends
			" Define the following region if and only if at least one of the
			" region types whose end token could begin this region is active
			"============= BEGIN NON-INDENTING BLOCK =============
			if bgc_enabled
			" Define region that is begun by an end token
			" (when permitted by a nextgroup)
			exe 'syn region Tf'.cui.'_fmtclr_'.i.'_'.j.'_rtd'.matchgroup_def
				\.r2_fmtclr.ng.concealends
			endif " bgc_enabled
			"=============  END NON-INDENTING BLOCK  =============
			" Define highlighting for this region
			" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
			" handled correctly in a cterm.
			"	:help cterm-colors
			exe 'hi Tf'.cui.'_fmtclr_'.i.'_'.j
				\.eq_clr.b:txtfmt_clr{j}.eq_fmt.b:txtfmt_fmt{i}
			" Link rtd to non-rtd group
			exe 'hi link Tf'.cui.'_fmtclr_'.i.'_'.j.'_rtd Tf'.cui.'_fmtclr_'.i.'_'.j
			"============= BEGIN NON-INDENTING BLOCK =============
			if bgc_enabled
			"===
			"*** Loop over fmt-clr-bgc levels
			"===
			let kp = 1
			while kp <= b:txtfmt_cfg_numbgcolors
				let k = b:txtfmt_cfg_bgcolor{kp}
				let chk = nr2char(b:txtfmt_bgc_first_tok + k)
				" Add to appropriate clusters
				exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_fmtclrbgc_'.i.'_'.j.'_'.k
				exe 'syn cluster Tf'.cui.'_fmtclrbgc_'.i.'_'.j.'_all add=Tf'.cui.'_fmtclrbgc_'.i.'_'.j.'_'.k
				" Ensure that this and higher order regions use bgc-specific concealment group
				let matchgroup_def = ' matchgroup=Tf'.cui.'_conceal_'.k
				" Define region that is begun by a start token
				exe 'syn region Tf'.cui.'_fmtclrbgc_'.i.'_'.j.'_'.k.matchgroup_def
					\.' start=/'.chk.'/'.r1_fmtclrbgc.' nextgroup=Tf'.cui.'_clrbgc_'.j.'_'.k.'_rtd,Tf'.cui.'_fmtbgc_'.i.'_'.k.'_rtd,Tf'.cui.'_fmtclr_'.i.'_'.j.'_rtd,@Tf'.cui.'_clrbgcfmt_'.j.'_'.k.'_all,@Tf'.cui.'_fmtbgcclr_'.i.'_'.k.'_all,@Tf'.cui.'_fmtclrbgc_'.i.'_'.j.'_all'.concealends
				" Define highlighting for this region
				" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
				" handled correctly in a cterm.
				"	:help cterm-colors
				exe 'hi Tf'.cui.'_fmtclrbgc_'.i.'_'.j.'_'.k
					\.eq_clr.b:txtfmt_clr{j}.eq_bgc.b:txtfmt_bgc{k}.eq_fmt.b:txtfmt_fmt{i}
				let kp = kp + 1
			endwhile
			" Revert to toplevel (no background color) matchgroup
			let matchgroup_def = matchgroup_top_def
			endif " bgc_enabled
			"=============  END NON-INDENTING BLOCK  =============
			let jp = jp + 1
		endwhile
		endif " clr_enabled
		"=============  END NON-INDENTING BLOCK  =============
		"============= BEGIN NON-INDENTING BLOCK =============
		if bgc_enabled
		"===
		"*** Loop over fmt-bgc levels
		"===
		let jp = 1
		while jp <= b:txtfmt_cfg_numbgcolors
			let j = b:txtfmt_cfg_bgcolor{jp}
			let chj = nr2char(b:txtfmt_bgc_first_tok + j)
			" Add to appropriate clusters
			exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_fmtbgc_'.i.'_'.j
			exe 'syn cluster Tf'.cui.'_fmtbgc_'.i.'_all add=Tf'.cui.'_fmtbgc_'.i.'_'.j
			" Ensure that this and higher order regions use bgc-specific concealment group
			let matchgroup_def = ' matchgroup=Tf'.cui.'_conceal_'.j
			" Cache the nextgroup clause
			let ng = ' nextgroup=Tf'.cui.'_bgc_'.j.'_rtd,Tf'.cui.'_fmt_'.i.'_rtd,@Tf'.cui.'_bgcfmt_'.j.'_all,@Tf'.cui.'_fmtbgc_'.i.'_all'.(clr_enabled ? ',@Tf'.cui.'_fmtbgcclr_'.i.'_'.j.'_all' : '')
			" Define region that is begun by a start token
			exe 'syn region Tf'.cui.'_fmtbgc_'.i.'_'.j.matchgroup_def
				\.' start=/'.chj.'/'.r1_fmtbgc.ng.concealends
			" Define the following region if and only if at least one of the
			" region types whose end token could begin this region is active
			"============= BEGIN NON-INDENTING BLOCK =============
			if clr_enabled
			" Define region that is begun by an end token
			" (when permitted by a nextgroup)
			exe 'syn region Tf'.cui.'_fmtbgc_'.i.'_'.j.'_rtd'.matchgroup_def
				\.r2_fmtbgc.ng.concealends
			endif " clr_enabled
			"=============  END NON-INDENTING BLOCK  =============
			" Define highlighting for this region
			" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
			" handled correctly in a cterm.
			"	:help cterm-colors
			exe 'hi Tf'.cui.'_fmtbgc_'.i.'_'.j
				\.eq_bgc.b:txtfmt_bgc{j}.eq_fmt.b:txtfmt_fmt{i}
			" Link rtd to non-rtd group
			exe 'hi link Tf'.cui.'_fmtbgc_'.i.'_'.j.'_rtd Tf'.cui.'_fmtbgc_'.i.'_'.j
			"============= BEGIN NON-INDENTING BLOCK =============
			if clr_enabled
			"===
			"*** Loop over fmt-bgc-clr levels
			"===
			let kp = 1
			while kp <= b:txtfmt_cfg_numfgcolors
				let k = b:txtfmt_cfg_fgcolor{kp}
				let chk = nr2char(b:txtfmt_clr_first_tok + k)
				" Add to appropriate clusters
				exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_fmtbgcclr_'.i.'_'.j.'_'.k
				exe 'syn cluster Tf'.cui.'_fmtbgcclr_'.i.'_'.j.'_all add=Tf'.cui.'_fmtbgcclr_'.i.'_'.j.'_'.k
				" Define region that is begun by a start token
				exe 'syn region Tf'.cui.'_fmtbgcclr_'.i.'_'.j.'_'.k.matchgroup_def
					\.' start=/'.chk.'/'.r1_fmtbgcclr.' nextgroup=Tf'.cui.'_bgcclr_'.j.'_'.k.'_rtd,Tf'.cui.'_fmtclr_'.i.'_'.k.'_rtd,Tf'.cui.'_fmtbgc_'.i.'_'.j.'_rtd,@Tf'.cui.'_bgcclrfmt_'.j.'_'.k.'_all,@Tf'.cui.'_fmtclrbgc_'.i.'_'.k.'_all,@Tf'.cui.'_fmtbgcclr_'.i.'_'.j.'_all'.concealends
				" Define highlighting for this region
				" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is
				" handled correctly in a cterm.
				"	:help cterm-colors
				exe 'hi Tf'.cui.'_fmtbgcclr_'.i.'_'.j.'_'.k
					\.eq_clr.b:txtfmt_clr{k}.eq_bgc.b:txtfmt_bgc{j}.eq_fmt.b:txtfmt_fmt{i}
				let kp = kp + 1
			endwhile
			endif " clr_enabled
			"=============  END NON-INDENTING BLOCK  =============
			let jp = jp + 1
		endwhile
		" Revert to toplevel (no background color) matchgroup
		let matchgroup_def = matchgroup_top_def
		endif " bgc_enabled
		"=============  END NON-INDENTING BLOCK  =============
		let i = i + 1
	endwhile
	" END AUTOGENERATED CODE BLOCK >>>
	" Handle escape/escapee token pairs both inside and outside of fmt/clr
	" regions.
	" Important Note: These groups must be defined after the fmt/clr regions,
	" since they must take precedence over them.
	" Objectives:
	" -Conceal the escape token
	" -Prevent escaped or escaping tokens from beginning a region
	" -Prevent escaped or escaping tokens from ending a region
	" Note: Must take into account the txtfmt 'escape' option
	" Also note: Must take into account the size in bytes of the escape char
	" if this Vim treats offsets as byte offsets
	" TODO_BG: Guard against reliance upon _bgc_ vars when they wouldn't have
	" been defined.
	if b:txtfmt_cfg_escape == 'bslash' || b:txtfmt_cfg_escape == 'self'
		if b:txtfmt_cfg_escape == 'self'
			let re_outer_esc_pair = '\(['.b:txtfmt_re_any_stok_atom.']\)\1'
			let re_any_stok_esc_pair = '\(['.b:txtfmt_re_any_stok_atom.']\)\1'
			let re_fmt_etok_esc_pair = '\(['.b:txtfmt_re_fmt_etok_atom.']\)\1'
			if bgc_enabled
				let re_bgc_etok_esc_pair = '\(['.b:txtfmt_re_bgc_etok_atom.']\)\1'
			endif
			if clr_enabled
				let re_clr_etok_esc_pair = '\(['.b:txtfmt_re_clr_etok_atom.']\)\1'
			endif
			" Escape char is same number of bytes as a token
			let esc_off = tok_off
		elseif b:txtfmt_cfg_escape == 'bslash'
			let re_outer_esc_pair = '\\\%(\\\%(\\*['.b:txtfmt_re_any_stok_atom.']\)\@=\|['.b:txtfmt_re_any_stok_atom.']\)'
			let re_any_stok_esc_pair = '\\\%(\\\%(\\*['.b:txtfmt_re_any_stok_atom.']\)\@=\|['.b:txtfmt_re_any_stok_atom.']\)'
			let re_fmt_etok_esc_pair = '\\\%(\\\%(\\*['.b:txtfmt_re_fmt_etok_atom.']\)\@=\|['.b:txtfmt_re_fmt_etok_atom.']\)'
			if bgc_enabled
				let re_bgc_etok_esc_pair = '\\\%(\\\%(\\*['.b:txtfmt_re_bgc_etok_atom.']\)\@=\|['.b:txtfmt_re_bgc_etok_atom.']\)'
			endif
			if clr_enabled
				let re_clr_etok_esc_pair = '\\\%(\\\%(\\*['.b:txtfmt_re_clr_etok_atom.']\)\@=\|['.b:txtfmt_re_clr_etok_atom.']\)'
			endif
			" Escape char is single byte
			let esc_off = 1
		endif
		" The following group prevents escaping or escaped token from starting
		" a region, and causes the escaping token to be hidden
		exe 'syn match Tf_outer_esc /'.re_outer_esc_pair.'/he=s+'.esc_off.containedin_def.conceal
		" The following group allows escaping tokens to be hidden within a fmt/clr
		" region.
		exe 'syn match Tf_any_stok_inner_esc /'.re_any_stok_esc_pair.'/he=s+'.esc_off.' contains=NONE'
			\.' contained'.conceal
		exe 'syn match Tf_fmt_etok_inner_esc /'.re_fmt_etok_esc_pair.'/he=s+'.esc_off.' contains=NONE'
			\.' contained'.conceal
		if bgc_enabled
			exe 'syn match Tf_bgc_etok_inner_esc /'.re_bgc_etok_esc_pair.'/he=s+'.esc_off.' contains=NONE'
				\.' contained'.conceal
		endif
		if clr_enabled
			exe 'syn match Tf_clr_etok_inner_esc /'.re_clr_etok_esc_pair.'/he=s+'.esc_off.' contains=NONE'
				\.' contained'.conceal
		endif
		" Define highlighting for the outer and inner escape tokens
		hi link Tf_outer_esc Tf_conceal
		hi link Tf_any_stok_inner_esc Tf_conceal
		hi link Tf_fmt_etok_inner_esc Tf_conceal
		if bgc_enabled
			hi link Tf_bgc_etok_inner_esc Tf_conceal
		endif
		if clr_enabled
			hi link Tf_clr_etok_inner_esc Tf_conceal
		endif
	endif
endfu	" >>>
" Function: s:Define_syntax_syncing() <<<
fu! s:Define_syntax_syncing()
	" Configure syncing based upon syncmethod and (if applicable) synclines
	" options. (Note that 'sync' is the only option visible to user. It is
	" decoded into the two more convenient options by Do_config_common ->
	" Set_syncing.)
	if b:txtfmt_cfg_syncmethod == 'fromstart'
		syn sync fromstart
	elseif b:txtfmt_cfg_syncmethod == 'minlines'
		exe 'syn sync minlines='.b:txtfmt_cfg_synclines
	endif
	" TODO - Get rid of the function code after the following return prior to
	" release.
	return
	" SYNTAX SYNCHRONIZATION using regions correctly but with a flaw <<<
	" NOTE: This is the most promising method other than 'minlines'. The only
	" problem is, there's no good way to handle the case of txtfmt regions
	" intermixed with other types of regions. Note that a problem exists both
	" for the nested and nonested cases:
	" 'nested' problem scenario: We synchronize to a nested txtfmt region.
	" When the nested txtfmt region ends, the containing region is not
	" resumed. (If we had used 'minlines', the presumption is we would have
	" gone back far enough to parse the containing region.)
	" 'nonested' problem scenario: We incorrectly synchronize to a nested
	" txtfmt region because, not knowing anything about the non-txtfmt region
	" definitions, we have no way of knowing when we are within one.
	" TODO - If I decide to dust this off and use it, I need to look at the
	" handling of <no_fmt> and <no_clr> regions.
	if 0
	" IMPORTANT NOTE: This should probably just be removed, but if it's ever
	" used, [] need to be wrapped around the tok atoms.
	" 'skip' pattern (option dependent) <<<
	if b:txtfmt_cfg_escape != 'none'
		" Make sure tokens that are part of an escape sequence cannot end a
		" region.
		if b:txtfmt_cfg_escape == 'bslash'
			" TODO - Decide on allowing newlines as tokens (\_. or . ?)
			let skip_def = ' skip=/\\./'
		elseif b:txtfmt_cfg_escape == 'self'
			let skip_def = ' skip=/\('.b:txtfmt_re_any_tok_atom.'\)\1/'
		else
			let skip_def = ''
		endif
	else
		let skip_def = ''
	endif
	" >>>
	" 'contains' list (option dependent) <<<
	" Note: I'm intentionally keeping this out of the 'if' for skip_def to
	" keep the logic compartmentalized.
	if b:txtfmt_cfg_escape != 'none'
		" Permit txtfmt regions to contain specially highlighted pairs of
		" escape-escapee tokens.
		let contains_def = ' contains=Tf_inner_esc'
	else
		let contains_def = ''
	endif
	" >>>
	" 'containedin' list (option dependent) <<<
	if b:txtfmt_cfg_nested
		" Ensure that txtfmt top-level item can be contained by a non-txtfmt
		" syntax group (e.g. C-language comment).
		if b:txtfmt_cfg_escape != 'none'
			let containedin_def = ' containedin=ALLBUT,@Tf_all,Tf_outer_esc,Tf_inner_esc'
		else
			let containedin_def = ' containedin=ALLBUT,@Tf_all'
		endif
	else
		let containedin_def = ''
	endif
	" >>>
	" Loop over the clr only regions <<<
	let i = 1
	let ch = nr2char(b:txtfmt_clr_first_tok + 1)
	while i < b:txtfmt_num_colors
		" clr{i} region (top level) <<<
		" Add to appropriate clusters
		exe 'syn cluster Tf_all add=Tf_clr_'.i
		exe 'syn cluster Tf_clr_all add=Tf_clr_'.i
		" Define nextgroup, which is common to all definitions of this group
		let nextgroup_def = ' nextgroup=@Tf_clrfmt_'.i.'_all,@Tf_clr_all'
		" Define a clr region that is not contained and is introduced by a clr
		" token. This one can match at top level. If txtfmt 'nested' option is
		" set, it can also match within non-txtfmt regions.
		" Order note: This definition *must* occur prior to the combined
		" fmtclr regions that begin with this fmt token.
		exe 'syn region Tf_clr_'.i.' matchgroup=Ignore start=/'.ch.'/'
			\.skip_def
			\.' end=/'.b:txtfmt_re_any_tok_atom.'/me=e-1 '
			\.nextgroup_def
			\.contains_def
			\.containedin_def
		" Define a 'contained' clr region that is introduced by the 'no fmt'
		" token when permitted by a 'nextgroup'
		exe 'syn region Tf_clr_'.i.' matchgroup=Ignore'
			\.' start=/'.nr2char(b:txtfmt_fmt_first_tok).'/'
			\.skip_def
			\.' end=/'.b:txtfmt_re_any_tok_atom.'/me=e-1 '
			\.nextgroup_def
			\.contains_def
			\.' contains=Tfsm_clr_'.i
			\.' contained'
		exe 'syn sync match Tfsm_clr_'.i.' contained grouphere Tf_clr_'.i.' /./'
		" >>>
		" Update for next iteration
		let i = i + 1
		let ch = nr2char(b:txtfmt_clr_first_tok + i)
	endwhile
	" >>>
	" Loop over the fmt only regions <<<
	let i = 1
	let ch = nr2char(b:txtfmt_fmt_first_tok + 1)
	while i < b:txtfmt_num_formats
		" fmt{i} region (top level) <<<
		" Add to appropriate clusters
		exe 'syn cluster Tf_all add=Tf_fmt_'.i
		exe 'syn cluster Tf_fmt_all add=Tf_fmt_'.i
		" Define nextgroup, which is common to all definitions of this group
		let nextgroup_def = ' nextgroup=@Tf_fmtclr_'.i.'_all,@Tf_fmt_all'
		" Define a fmt region that is not contained and is introduced by a fmt
		" token. This one can match at top level. If txtfmt 'nested' option is
		" set, it can also match within non-txtfmt regions.
		" Order note: This definition *must* occur prior to the combined
		" clrfmt regions that begin with this fmt token.
		exe 'syn region Tf_fmt_'.i.' matchgroup=Ignore start=/'.ch.'/'
			\.skip_def
			\.' end=/'.b:txtfmt_re_any_tok_atom.'/me=e-1 '
			\.nextgroup_def
			\.contains_def
			\.containedin_def
		" Define a 'contained' fmt region that is introduced by the 'no clr'
		" token when permitted by a 'nextgroup'
		exe 'syn region Tf_fmt_'.i.' matchgroup=Ignore'
			\.' start=/'.nr2char(b:txtfmt_clr_first_tok).'/'
			\.skip_def
			\.' end=/'.b:txtfmt_re_any_tok_atom.'/me=e-1'
			\.nextgroup_def
			\.contains_def
			\.' contained'
			\.' contains=Tfsm_fmt_'.i
		exe 'syn sync match Tfsm_fmt_'.i.' contained grouphere Tf_fmt_'.i.' /./'
		" >>>
		" Update for next iteration
		let i = i + 1
		let ch = nr2char(b:txtfmt_fmt_first_tok + i)
	endwhile
	" >>>
	" Loop over the clrfmt regions <<<
	let i = 1
	while i < b:txtfmt_num_colors
		" clr{i} -- fmt{j} <<<
		let j = 1
		let ch = nr2char(b:txtfmt_fmt_first_tok + 1)
		while j < b:txtfmt_num_formats
			" Add to appropriate clusters
			exe 'syn cluster Tf_all add=Tf_clrfmt_'.i.'_'.j
			exe 'syn cluster Tf_clrfmt_'.i.'_all add=Tf_clrfmt_'.i.'_'.j
			let nextgroup_def =
				\' nextgroup=@Tf_clr_'.i.',@Tf_fmt_'.j.',@Tf_clrfmt_'.i.'_all,@Tf_fmtclr_'.j.'_all'
			exe 'syn region Tf_clrfmt_'.i.'_'.j.' matchgroup=Ignore'
				\.' start=/'.ch.'/'.skip_def
				\.' end=/'.b:txtfmt_re_any_tok_atom.'/me=e-1'
				\.nextgroup_def
				\.contains_def
				\.' contained'
				\.' contains='.'Tfsm_clrfmt_'.i.'_'.j
			exe 'syn sync match Tfsm_clrfmt_'.i.'_'.j.' contained grouphere Tf_clrfmt_'.i.'_'.j.' /./'
			" Update for next iteration
			let j = j + 1
			let ch = nr2char(b:txtfmt_fmt_first_tok + j)
		endwhile
		" >>>
		" Update for next iteration <<<
		let i = i + 1
		" >>>
	endwhile
	" >>>
	" Loop over the fmtclr regions <<<
	let i = 1
	while i < b:txtfmt_num_formats
		" fmt{i} -- clr{j} <<<
		let j = 1
		let ch = nr2char(b:txtfmt_clr_first_tok + 1)
		while j < b:txtfmt_num_colors
			" Add to appropriate clusters
			exe 'syn cluster Tf_all add=Tf_fmtclr_'.i.'_'.j
			exe 'syn cluster Tf_fmtclr_'.i.'_all add=Tf_fmtclr_'.i.'_'.j
			let nextgroup_def =
				\' nextgroup=@Tf_fmt_'.i.',@Tf_clr_'.j.',@Tf_fmtclr_'.i.'_all,@Tf_clrfmt_'.j.'_all'
			exe 'syn region Tf_fmtclr_'.i.'_'.j.' matchgroup=Ignore'
				\.' start=/'.ch.'/'.skip_def
				\.' end=/'.b:txtfmt_re_any_tok_atom.'/me=e-1'
				\.nextgroup_def
				\.contains_def
				\.' contained'
				\.' contains='.'Tfsm_fmtclr_'.i.'_'.j
			exe 'syn sync match Tfsm_fmtclr_'.i.'_'.j.' contained grouphere Tf_fmtclr_'.i.'_'.j.' /./'
			" Update for next iteration
			let j = j + 1
			let ch = nr2char(b:txtfmt_clr_first_tok + j)
		endwhile
		" >>>
		" Update for next iteration <<<
		let i = i + 1
		" >>>
	endwhile
	" >>>
	endif
	" >>>
endfu	" >>>
" Function: s:Set_current_syntax() <<<
" Purpose: Set b:current_syntax to something sensible. If txtfmt is loaded
" in conjunction with one or more other plugins, we should set
" b:current_syntax to a dot-separated syntax name list that reflects all
" syntaxes loaded up to and including ours. Note that the b:txtfmt_syntax
" variable should permit us to do this even when other syntax plugins in the
" load chain have not respected assignments to b:current_syntax made by their
" predecessors in the load chain.
fu! s:Set_current_syntax()
	if exists('b:txtfmt_syntax') && b:txtfmt_syntax =~ '\%(^\|\.\)txtfmt\%(\.\|$\)'
		" Set b:current_syntax to the portion of b:txtfmt_syntax up to and
		" including the first (and hopefully the only) occurrence of 'txtfmt'
		let b:current_syntax =
			\ substitute(b:txtfmt_syntax,
			\ '\(.\{-}\%(^\|\.\)txtfmt\%(\.\|$\)\).*', '\1', '')
	else
		" This shouldn't happen unless user is manually sourcing the txtfmt
		" plugin files (which also shouldn't happen). Still, if it does,
		" 'txtfmt' is the most sensible choice.
		let b:current_syntax = 'txtfmt'
	endif
endfu
" >>>
" Call functions to define syntax and syntax syncing <<<
call s:Define_syntax()
call s:Define_syntax_syncing()
" >>>
" Call function to set b:current_syntax variable <<<
call s:Set_current_syntax()
" >>>
" LESSONS LEARNED <<<
" -By default, an item is contained only at top level.
" -containedin=TOP causes an item to be contained not just in top level, but
"  in an item which does not have contained set.
" -When an inner (contained) region is truncated because of a keepend in a
"  containing region, the inner regions highlighting is used up until the
"  point where truncation occurs!!!!! This is not obvious from help. However,
"  it's simple to demonstrate: copy the nested parens example from Vim help
"  as-is, but add the keepend argument to par1 region. Source the file and
"  view text with 3 levels of parens. Colors will be as expected until the
"  first close paren is encountered. It will be colored according to the
"  highlighting of the innermost nested paren region, not the outer as I would
"  have expected.
" -You can use patterns for contains=, containedin=, etc..., but only groups
"  defined at the time the command is executed will be matched! (In original
"  implementation, this is why I ran the Define_syntax() function twice. Now I
"  use clusters.)
" -With keepend, when doing matches for contained groups, the match is
"  performed prior to checking for end of containing group. If containing
"  group ends inside the contained group, the contained group will be
"  truncated, but for purposes of ms=, me=, hs=, he=, the end of the contained
"  group is not altered to reflect the point of truncation!!!!!
" -There is an apparent bug with the way contains= and containedin= work with
"  matchgroup. I have submitted to Vim list, and am awaiting Bram's return
"  from Uganda, at which time he has suggested he will investigate.
" -NOTE: A transparent group inherits the contains= arguments of its
"  containing group! (Can lead to unexpected behavior.)
" -Apparent bug with transparent groups inheriting syntax of contained group,
"  even when the current location in containing group has syntax disabled due
"  to a he=<...>. Example: An empty format region has its open delimiter
"  highlighted as error. The remainder of the region is not highlighted
"  specially. However, when a transparent escape-escapee pair appears inside
"  the empty region, it takes on Error syntax, even though it is past the
"  portion of the empty region highlighted as error.
" -IT IS POSSIBLE to have multiple containedin= attributes in the same group,
"  even where they would appear to conflict.
"  Example: group A may be contained by any group whose name matches
"  MyGroup.*Special; additionally, it may be contained in any group whose name
"  does not begin with MyGroup.
"  containedin=ALLBUT,MyGroup.* containedin=MyGroup.*Special
"  Note that this works because when Vim encounters a containedin, it simply
"  adds the appropriate contains= attributes to the specified containing
"  groups; i.e., a containedin= cannot "rule out" future containment due to a
"  subsequent containedin=.
" E56 - (* operand could be empty) workaround for the following pattern:
" \(ab\)\1*
" which will generate E56 in Vim, even though \1 cannot be empty
" Workaround: \(ab\)\%(\1\@=..\)*
" >>>

" IMPORTANT NOTE: The Vim script ends here. The perl script used to generate
" portions of this file follows...
finish

#!perl

# This script generates the core of the Define_syntax function of Brett
# Stahlman's Txtfmt Vim plugin
# It is designed to be invoked from a Vim external program read filter, as
# follows:
# :r !gen_txtfmt_def_syn.pl
# There are 2 passes:
# Pass 1) Generates definitions, which are specific to a token type combination
# (e.g., "fmt", "fmtclr", etc...)
# Pass 2) Generates the nested loops used to define syntax regions

@rgn = qw(clr bgc fmt);
# TODO: If I keep support for separate bgc and clr definitions, I can get rid
# of the %rhs hash (after making corresponding code modifications)
%rhs = qw(clr clr bgc bgc fmt fmt);
%ord = qw(clr 0 bgc 1 fmt 2);
# Note which types of regions can be disabled through Vim options
@can_dsbl = qw(clr bgc);
# Subtract 1 from b:txtfmt_num_formats (which currently includes the default
# format token)
%loopinfo = (
	clr => {
		cnt =>'b:txtfmt_cfg_numfgcolors',
		indarr => 'b:txtfmt_cfg_fgcolor',
	},
	bgc => {
		cnt =>'b:txtfmt_cfg_numbgcolors',
		indarr => 'b:txtfmt_cfg_bgcolor',
	},
	fmt => {
		cnt =>'b:txtfmt_num_formats - 1',
		indarr => undef,
	},
);
# TODO: Get rid of %cnt and %idxind if I elect to keep %loopinfo
%cnt = (
	clr => 'b:txtfmt_cfg_numfgcolors',
	bgc => 'b:txtfmt_cfg_numbgcolors',
	fmt => 'b:txtfmt_num_formats - 1'
);
# Define a hash supporting index indirection
%idxind = (
	clr => 'b:txtfmt_cfg_fgcolor',
	bgc => 'b:txtfmt_cfg_bgcolor',
	fmt => undef
	# Could omit fmt or leave it undef
);

# Define base indentlevel of the entire block
$init_il = 1;

# Define the various output passes
use constant {
	DEFS  => 0,
	LOOPS => 1,
};

# This semaphore helps determine when an "if <typ>_enabled" construct in the
# Vim code would be redundant with a containing one.
# TODO: Currently unused - remove...
my $bgc_guard_cnt = 0;

sub do_lvl($$$)
{
	# Description of arrays
	# @a1 - $_[1]: lhs (fixed) array of token type names. Upon function entry,
	#      this array represents the most recent region combination to have
	#      been processed.
	# @a1n - lhs (fixed) array of token type names that will be passed in next
	#       recursive call to this function. Created by appending a single
	#       token type name from @a2
	# @a2 - $_[2]: rhs (unfixed) array of token type names. Upon function
	#       entry, this array contains the token type names not included in the
	#       currently processed region combination. (e.g, if we're currently
	#       processing "fmt-clr" regions, then @a2 contains "bgc")
	# @a2n - rhs (unfixed) array of token type names that will be passed in
	#        next recursive call to this function. Created by removing a single
	#        token type name from @a2

	# Basic algorithm
	# Loop over the token type names in @a2, appending each, in turn, to @a1
	# (and calling the result @a1n). For each iteration, process the
	# corresponding region combination, which will involve all token type names
	# contained in @a1n, then call self recursively (passing @a1n and @a2n) to
	# process the next level.
	my $section = shift;
	my @a1 = @{shift()}; # Fixed portion
	my @a2 = @{shift()}; # Unfixed portion
	# Determine the level of this recursive call according to number of
	# elements in @a1
	my $lvl = @a1;
	# Loop over unfixed portion
	for my $a2 (@a2) {
		my @a1n = (@a1, $a2);
		# Create a hash mapping region names to loop var names
		my %idx = ();
		my $var = 'i';
		for my $a1n (@a1n) {
			$idx{$a1n} = $var++;
		}

		my @a2n = grep { $_ ne $a2 } @a2;
		# Description of @lor, @sor, @hor
		# These 3 arrays are a convenience. They are 2D arrays containing
		# specific useful combinations of token type names corresponding to the
		# preceding level, the current level, and the next level, respectively.

		# Lower order
		# Remove each element in turn from @a1n
		my @lor = ();
		if (@a1n > 1) {
			for my $r (@a1n) {
				push @lor, [ grep { $_ ne $r } @a1n ];
			}
		}
		# Same order
		# Move each element within @a1n to the end
		my @sor = ();
		for (my $i = 0; $i < @a1n; $i++) {
			my @r = @a1n;
			my $r = splice @r, $i, 1;
			push @sor, [ @r, $r ];
		}
		# Higher order
		# Add region types from @a2n to the end
		my @hor = ();
		for my $r (@a2n) {
			push @hor, [ @a1n, $r ];
		}
		# Determine initial indent level
		my $il;
		if ($section == DEFS) {
			$il = "\t";
		} else { # if $section == LOOPS
			$il = "\t" x ($init_il + $lvl);
		}

		# Set convenience variable $need_r2_guard if and only if all the
		# region types yet to be pulled in (i.e., the ones whose end tokens
		# could begin the current region) are regions that can be disabled.
		my $need_r2_guard = join('', sort @can_dsbl) =~ join('', sort @a2n);

		# Begin outputting
		# Insert an "if <typ>_enabled" if and only if the rightmost region
		# type in the fixed array is <typ> (i.e., the region being begun
		# should not exist if <typ>_enabled is false). (If the fixed portion
		# contains <typ> prior to the last element, we're already inside an
		# "if <typ>_enabled", in which case, another would be redundant.)
		for my $typ (grep { $_ eq $a1n[-1] } @can_dsbl) {
			print "\n$il", '"============= BEGIN NON-INDENTING BLOCK =============';
			print "\n$il", "if ${typ}_enabled";
		}

		# PRE RECURSION
		if ($section == DEFS) {
			# Determine current level's indent
			$il = "\t";
			print "\n$il\"===";
			print "\n$il\"*** ", join("-", @a1n);
			print "\n$il\"===";

			print "\n$il", "if b:txtfmt_cfg_escape != 'none'";
			print "\n$il\t", "let contains_", join("", @a1n), "=",
				"\n$il\t\t\\' contains='",
				"\n$il\t\t\\.'Tf_any_stok_inner_esc,'",
				"\n$il\t\t\\.'",
				join(",'\n$il\t\t\\.'",
					map { "Tf_${_}_etok_inner_esc" } @a1n
				),
				"'"
			;
			print "\n$il\t", "if b:txtfmt_cfg_escape == 'bslash'";
			print "\n$il\t\t", "let skip_", join("", @a1n), " = ' skip=/\\\\./'";
			print "\n$il\t", "else";
			# TODO: Decide whether to keep this or go back to the more complex pattern
			print "\n$il\t\t", "let skip_", join("", @a1n), " = ' skip=/\\(.\\)\\1/'";
			print "\n$il\t", "endif";
			print "\n$il", "else";
			print "\n$il\t", "let contains_", join("", @a1n), " = ''";
			print "\n$il\t", "let skip_", join("", @a1n), " = ''";
			print "\n$il", "endif";
			print "\n$il", "let end_", join("", @a1n), " =";
			print "\n$il\t", "\\' end=/['";
			print "\n$il\t", "\\.b:txtfmt_re_any_stok_atom";
			print "\n$il\t", "\\.",
				join("\n$il\t\\.",
					map { "b:txtfmt_re_${_}_etok_atom" } @a1n
				),
				"\n$il\t", "\\.']/me=e-'.tok_off"
			;
			# Define r1_<rgn> var
			print "\n$il", "let r1_", join("", @a1n), " =";
			print "\n$il\t", "\\skip_", join("", @a1n);
			print "\n$il\t", "\\.contains_", join("", @a1n);
			print "\n$il\t", "\\.end_", join("", @a1n);
			if (@a1n == 1) {
				print "\n$il\t", "\\.containedin_def";
			} else {
				print "\n$il\t", "\\.' contained'";
			}
			# Don't define r2_<rgn> var if there's not at least 1 higher order
			# region
			if (@a2n) {
				# Ensure that we don't define the r2 region variables if all
				# of the <typ>'s whose end token could begin the region are
				# inactive. If at least one of these <typ>'s is active, the
				# vars will be defined, and <typ>_enabled ternaries will be
				# used as necessary to ensure that we don't consider end
				# tokens for inactive region types.
				if ($need_r2_guard) {
					print "\n$il", '" Define the r2 region vars if and only if at least one of the';
					print "\n$il", '" region types whose end token could begin this region is active';
					print "\n$il", '"============= BEGIN NON-INDENTING BLOCK =============';
					print "\n$il", "if ",
						join ' || ', map { "${_}_enabled" } @a2n
					;
				}
				print "\n$il", "let start_", join("", @a1n), " =";
				print "\n$il\t", "\\' start=/['";
				print "\n$il\t", "\\.",
					join(".",
						map {
							# Wrap the end token for <typ> in ternary guard
							# unless a containing `if <typ>_enabled' renders
							# it redundant.
							# Note: The ternary is never redundant when
							# multiple types are logically or'ed in the
							# containing if: e.g.,
							# if <typ1>_enabled || <typ2>_enabled
							# Note: If $need_r2_guard is true, @a2n is
							# precisely the number of conditions in the if
							my $typ = $_;
							my $need_ternary =
								(grep { $_ eq $typ } @can_dsbl
								and !$need_r2_guard || @a2n > 1);
							(
								$need_ternary
								? "(${typ}_enabled ? "
								: ""
							) .
							"b:txtfmt_re_${typ}_etok_atom" .
							(
								$need_ternary
								? " : '')"
								: ""
							)
						} @a2n
					)
				;
				print "\n$il\t", "\\.']/'";

				print "\n$il", "let r2_", join("", @a1n), " =";
				print "\n$il\t", "\\skip_", join("", @a1n);
				print "\n$il\t", "\\.contains_", join("", @a1n);
				print "\n$il\t", "\\.start_", join("", @a1n);
				print "\n$il\t", "\\.end_", join("", @a1n);
				print "\n$il\t", "\\.' contained'";
				if ($need_r2_guard) {
					print "\n$il", "endif \" ",
						join ' || ', map { "${_}_enabled" } @a2n;
					print "\n$il", '"=============  END NON-INDENTING BLOCK  =============';
				}
			}
		} else { # $section == LOOPS
			# Determine current level's indent
			$il = "\t" x ($init_il + $lvl);
			print "\n$il\"===";
			print "\n$il\"*** Loop over ", join("-", @a1n), " levels";
			print "\n$il\"===";
			# TODO: Think about cleaning this up a bit and adding comments for
			# the index indirection...
			print "\n$il", "let $idx{$a1n[-1]}", ($loopinfo{$a1n[-1]}{indarr} ? 'p' : ''), " = 1";
			print "\n$il", "while $idx{$a1n[-1]}", ($loopinfo{$a1n[-1]}{indarr} ? 'p' : ''), " <= $loopinfo{$a1n[-1]}{cnt}";
			$il .= "\t";
			print "\n$il", "let $idx{$a1n[-1]} = $loopinfo{$a1n[-1]}{indarr}\{$idx{$a1n[-1]}p\}"
				if $loopinfo{$a1n[-1]}{indarr};
			print "\n$il", "let ch$idx{$a1n[-1]} = nr2char(b:txtfmt_$a1n[-1]_first_tok + $idx{$a1n[-1]})";

			print "\n$il\" Add to appropriate clusters";
			print "\n$il", "exe 'syn cluster Tf'.cui.'_all add=Tf'.cui.'_",
				join("", @a1n), "_'.",
				join(".'_'.", @idx{@a1n})
			;
			print "\n$il", "exe 'syn cluster Tf'.cui.'_",
				join("", @a1n),
				(@a1n > 1
					? "_'." . join(".'_'.", @idx{@a1n[0 .. $#a1n - 1]}) . ".'"
					: ""
				),
				"_all add=Tf'.cui.'_",
				join("", @a1n),
				"_'.",
				join(".'_'.", @idx{@a1n})
			;
			# Define matchgroup if background color could be changing (i.e., if
			# last element of @a1n is 'bgc')
			# Note: matchgroup will retain setting given until we move back to
			# a lower order region
			# Also note: bgc_enabled check would be superfluous here, since
			# code won't be executed if bgc_enabled is false
			if ($a1n[-1] eq 'bgc') {
				print "\n$il", '" Ensure that this and higher order regions use bgc-specific concealment group';
				print "\n$il", "let matchgroup_def = ' matchgroup=Tf'.cui.'_conceal_'.$idx{$a1n[-1]}";
			}

			# Define nextgroup
			my $ng = "";
			for my $lor (@lor) {
				# Transitions to lower-order groups will always be made to one
				# of the special "return to default" (rtd) groups.
				$ng .= ",Tf'.cui.'_" . join("", @$lor) . "_'." . join(".'_'.", @idx{@$lor}) . ".'_rtd";
			}
			for my $sor (@sor) {
				$ng .= ",\@Tf'.cui.'_" . join("", @$sor) .
					(@$sor > 1
						? "_'." . join(".'_'.", @idx{@{$sor}[0 .. $#$sor - 1]}) . ".'"
						: ""
					) .
					"_all";
			}
			# Note: We didn't need to worry about checking <typ>_enabled for
			# the lor and sor case (since this code will be inside an "if
			# <typ>_enabled" if <typ> is in either of those arrays); however,
			# the hor case pulls in a new region type, so we will need to
			# check it.
			my $unquoted = 0;
			for my $hor (@hor) {
				my $typ;
				if (($typ) = grep { $_ eq $hor->[-1] } @can_dsbl) {
					$ng .= ($unquoted ? '' : "'") . ".(${typ}_enabled ? '";
				}
				elsif ($unquoted) {
					$ng .= ".'";
				}
				$ng .= ",\@Tf'.cui.'_" . join("", @$hor) . "_'." .
					join(".'_'.", @idx{@a1n}) .
					".'_all";
				if ($typ) {
					$ng .= "' : '')";
					$unquoted = 1;
				}
				else {
					$unquoted = 0;
				}
			}
			if (@a1n == 1) {
				$ng .= ($unquoted ? ".'" : '') . ",Tf_def_tok'";
			} elsif (!$unquoted) {
				$ng .= "'";
			}
			# Use substr to strip off the leading comma at the head of $ng
			$ng = "' nextgroup=" . substr($ng, 1);

			# If nextgroup is about to be used in 2 region definitions (r1 and
			# r2), assign it to a variable for efficiency. (Many
			# concatenations are required to build the entire nextgroup
			# clause.)
			# Note: If there are no more regions to pull in, the nextgroup
			# clause will be used only once, so it's more efficient to build
			# it within the region definition itself.
			if (@a2n) {
				print "\n$il\" Cache the nextgroup clause";
				print "\n$il", "let ng = ", $ng;
				# Obviate the need for subsequent logic within this script to
				# know whether we're caching nextgroup clause or not
				$ng = 'ng';
			}

			# Define the rgn that is begun with an stok
			print "\n$il\" Define region that is begun by a start token";
			# Save the beginning of the `syn region' statement, which is
			# common to both the region begun by start tok and the region
			# begun by end tok. (Note that they diverge at the `_rtd' in the
			# latter's region name.)
			my $pre_start = "\n$il" .
				"exe 'syn region " .
				"Tf'.cui.'_" . join("", @a1n) . "_'." . join(".'_'.", @idx{@a1n});
			print "$pre_start.matchgroup_def",
				"\n$il\t\\.' start=/'.ch$idx{$a1n[-1]}.'/'",
				".r1_", join("", @a1n), ".$ng.concealends";

			;
			# Define the region introduced by 'no rgn' token (if it exists)
			if (@a2n) {
				# Ensure that we don't define the region if all of the <typ>'s
				# whose end token could begin the region are inactive. If at
				# least one of these <typ>'s is active, the region will be
				# defined, and <typ>_enabled ternaries will be used as
				# necessary to ensure that we don't consider end tokens for
				# inactive region types.
				if ($need_r2_guard) {
					print "\n$il", '" Define the following region if and only if at least one of the';
					print "\n$il", '" region types whose end token could begin this region is active';
					print "\n$il", '"============= BEGIN NON-INDENTING BLOCK =============';
					print "\n$il", "if ",
						join ' || ', map { "${_}_enabled" } @a2n
					;
				}
				print "\n$il\" Define region that is begun by an end token";
				print "\n$il\" (when permitted by a nextgroup)";
				print "$pre_start.'_rtd'.matchgroup_def\n$il\t\\.",
					"r2_", join("", @a1n), ".$ng.concealends";
				;
				if ($need_r2_guard) {
					print "\n$il", "endif \" ",
						join ' || ', map { "${_}_enabled" } @a2n;
					print "\n$il", '"=============  END NON-INDENTING BLOCK  =============';
				}
			}
			# Define the highlighting region
			print "\n$il\" Define highlighting for this region";
			print "\n$il\" Note: cterm= MUST come after ctermfg= to ensure that bold attribute is";
			print "\n$il\" handled correctly in a cterm.";
			print "\n$il\"\t:help cterm-colors";
			print "\n$il", "exe 'hi Tf'.cui.'_", join("", @a1n), "_'.",
				join(".'_'.", @idx{@a1n}),
				"\n$il\t\\.",
				join(".", map {
					"eq_$_.b:txtfmt_$rhs{$_}\{$idx{$_}\}"
					} sort { $ord{$a} <=> $ord{$b} } @a1n
				),
			;
			# Define the highlighting region for the rtd group (if it exists)
			if (@a2n) {
				# Link rtd to non-rtd group, since highlighting is identical
				print "\n$il\" Link rtd to non-rtd group";
				print "\n$il", "exe 'hi link Tf'.cui.'_", join("", @a1n), "_'.",
					join(".'_'.", @idx{@a1n}), ".'_rtd",
					" Tf'.cui.'_", join("", @a1n), "_'.",
					join(".'_'.", @idx{@a1n})
				;

			}
		}

		# RECURSE
		# Call ourself recursively to handle the next level
		do_lvl($section, \@a1n, \@a2n);

		# POST RECURSION
		if ($section == DEFS) {
		} else { # if $section == LOOPS
			# Update for next iteration
			my $idx = $idx{$a1n[-1]};
			if ($a1n[-1] eq 'fmt') {
				print "\n$il", "let $idx = $idx + 1";
			} else {
				print "\n$il", "let ${idx}p = ${idx}p + 1";
			}
			# Strip a level of indent
			chop $il;
			print "\n$il", "endwhile";
		}
		# Handle departure from blocks corresponding to <typ>'s that can be
		# disabled
		if (my ($typ) = grep { $_ eq $a1n[-1] } @can_dsbl) {
			if ($typ eq 'bgc') {
				# Revert to toplevel (no bgc) matchgroup
				# Note: Code emitted won't be reached if bgc_enabled is false
				print "\n$il", '" Revert to toplevel (no background color) matchgroup';
				print "\n$il", "let matchgroup_def = matchgroup_top_def" if $section eq LOOPS;
			}
			print "\n$il", "endif \" ${typ}_enabled";
			print "\n$il", '"=============  END NON-INDENTING BLOCK  =============';
		}
	}
}

# Top level recursion for both sections
# When the following call returns, the entire DEFS section will have been
# output
print "\t\" BEGIN AUTOGENERATED CODE BLOCK ", "<<<";
print "\n\t\" Last update: ", scalar(localtime), "\n";
do_lvl(DEFS, [], \@rgn);
# When the following call returns, the entire LOOPS section will have been
# output
do_lvl(LOOPS, [], \@rgn);
print "\n\t\" END AUTOGENERATED CODE BLOCK ", ">>>";

__END__
	" vim: sw=4 ts=4 foldmethod=marker foldmarker=<<<,>>> :
doc/txtfmt.txt	[[[1
2908
*txtfmt.txt*	Syntax/Filetype plugin for formatting plain text

Author:  Brett Pershing Stahlman  <brettstahlman@comcast.net>
Version: 2.4

==============================================================================
1. Contents					*txtfmt* *txtfmt-contents*

  1. Contents....................................: |txtfmt-contents|
  2. Motivation..................................: |txtfmt-motivation|
  3. Overview....................................: |txtfmt-overview|
  4. Installation................................: |txtfmt-installation|
     Distributed files...........................: |txtfmt-dist-files|
     Detecting/setting Txtfmt filetype...........: |txtfmt-filetype|
     Combining with other filetypes..............: |txtfmt-combining|
       Nesting Txtfmt regions....................: |txtfmt-nesting|
         Using Txtfmt within C comments..........: |txtfmt-nesting-c-example|
         Using Txtfmt within .otl (TVO) files....: |txtfmt-nesting-tvo-example|
         Using Txtfmt within 'Notes' plugin......: |txtfmt-nesting-notes-example|
     Loading.....................................: |txtfmt-loading|
  5. Configuration...............................: |txtfmt-configuration|
     Options.....................................: |txtfmt-options|
       Option types..............................: |txtfmt-opt-types|
       Option naming convention..................: |txtfmt-opt-names|
       Number format.............................: |txtfmt-opt-num-fmt|
       Txtfmt modelines..........................: |txtfmt-modeline|
	 Txtfmt modeline format..................: |txtfmt-modeline-fmt|
       Refreshing display after option changes...: |txtfmt-opt-refresh|
	 :Refresh command........................: |txtfmt-:Refresh|
       Option list...............................: |txtfmt-opt-list|
     Txtfmt "conceal" feature considerations.....: |txtfmt-conceal-notes|
     Choosing a token range......................: |txtfmt-choosing-token-range|
     Colors......................................: |txtfmt-color-config|
       Color defaults............................: |txtfmt-color-defaults|
       Colorscheme considerations................: |txtfmt-colorschemes|
         Achieving "colorscheme-independence"....: |txtfmt-hl-color-names|
     Color terminal pitfalls.....................: |txtfmt-cterm-pitfalls|
     Customizing the default maps................: |txtfmt-map-config|
       Handling conflicts and ambiguities........: |txtfmt-map-conflict|
  6. User interface..............................: |txtfmt-user-interface|
     Inserting tokens............................: |txtfmt-ins-tok|
       Fmt spec..................................: |txtfmt-fmt-spec|
       Clr spec..................................: |txtfmt-clr-spec|
       Fmt/clr spec list.........................: |txtfmt-fmt-clr-spec-list|
       Mapping overview..........................: |txtfmt-ins-tok-maps|
       Mappings..................................: |txtfmt-ins-tok-map-list|
     Jumping to tokens...........................: |txtfmt-jump-to-tok|
       Mappings..................................: |txtfmt-jump-to-tok-maps|
     Building complex mappings from primitives...: |txtfmt-user-maps|
       txtfmtUsermap{} element format............: |txtfmt-user-map-fmt|
       User-map expansion macros.................: |txtfmt-user-map-expansion|
       User-map examples.........................: |txtfmt-user-map-examples|
       Using buf-local sets......................: |txtfmt-buflocal-user-map|
     Creating token strings......................: |txtfmt-create-tok-str||
       Txtfmt_GetTokStr()........................: |txtfmt-GetTokStr()|
     Querying token type.........................: |txtfmt-query-tok-type|
       Format of token description string........: |txtfmt-tok-descriptor|
       \ga.......................................: |txtfmt-get-tok-info|
       :GetTokInfo...............................: |txtfmt-:GetTokInfo|
       Txtfmt_GetTokInfo()....!!!DEPRECATED!!!...: |txtfmt-GetTokInfo()|
     Viewing token map...........................: |txtfmt-view-tok-map|
       :ShowTokenMap.............................: |txtfmt-:ShowTokenMap|
     Testing current settings....................: |txtfmt-test-cur-settings|
       :MakeTestPage.............................: |txtfmt-:MakeTestPage|
     Moving the current token range..............: |txtfmt-move-tok-range|
       :MoveStartTok.............................: |txtfmt-:MoveStartTok|
  7. File structure..............................: |txtfmt-files|
  8. Detailed theory of operation................: |txtfmt-detailed-theory|

==============================================================================
2. Motivation						*txtfmt-motivation*

In addition to using Vim to edit C code, I sometimes use it to write notes of
various kinds. Sometimes these notes are temporary in nature, and sometimes
they are meant to be more permanent; for example, a document describing
various subsystems in a large programming project. For a task of this nature,
Vim offers many advantages over a typical word processor. Features like word
completion, multiple text registers, tags, cscope, etc.  are very useful when
documenting source code. However, there was always one advantage that a word
processor had when it came to creating non source code documents: formatted
text. The ability to set certain regions of text to an arbitrary foreground or
background color, or to make them stand out with attributes such as bold,
italic and underline can make a document much more readable, and hence, more
useful.

I realize that there are a number of very powerful formatting languages and
utilities, which may be used to create such documents. What I wanted, however,
was something very lightweight, something that depended only upon Vim. In
other words, I didn't want to create a file, which could be operated upon by a
tool, to create a file for viewing. I wanted only 1 file, the one I edited
with Vim, which could be viewed "on-the-fly," as each editing change was made.
The Txtfmt plugin is my solution for creating formatted documents with Vim,
to be viewed within Vim.

==============================================================================
3. Overview						*txtfmt-overview*

Txtfmt's formatting is accomplished through the use of single-character
"tokens" (chosen from ranges not normally used in text files), which are used
to define highlight attributes for subsequent text. The tokens themselves are
concealed by Txtfmt's syntax file, so that each appears as a single space (or
not at all if your version of Vim was compiled with "conceal" support - see
|txtfmt-'conceal'|)
Note: See section |txtfmt-cterm-ignore-issue| if you notice that tokens are
not hidden on your system.

Txtfmt requires 9 of the aforementioned tokens for foreground color regions,
and an additional 9 tokens if background colors are enabled (see
txtfmt-'tokrange' ). The |txtfmt-'tokrange'| option setting also determines
the number of tokens required for format regions. If the tokrange suffix is
'S' (short formats) or 'X' (extended), then the only formatting attributes in
use are bold, underline and italic. All possible permutations of these
attributes may be represented with only 8 tokens. If, on the other hand, the
tokrange suffix is 'L' (long formats), the set of available format attributes
expands to include standout, reverse and (for Vim versions >= 7.0) undercurl.
In this case, Txtfmt will require either 32 or 64 format tokens, depending
upon whether the version of Vim supports undercurl.

There are 3 types of Txtfmt marker token: format, foreground color and
background color. The 3 types of regions begun by these 3 types of tokens are
"orthogonal"; i.e., the presence of one has no effect upon any others that
happen to be active at that point in the buffer. For example, suppose you have
begun a green color region by inserting the appropriate token (with one of
Txtfmt's mappings, to be discussed later). You now wish to emphasize a word or
phrase by formatting it in italics, but you do not wish to change the color.
In this case, you would simply insert the format token denoting "italic", and
subsequently typed text would be green italic. If you later wished to switch
back to un-italicized (normal) green text, you would simply insert the format
token corresponding to "no format". Note that format and color tokens may be
freely interspersed with one another in any order.

The tokens described above are simply characters belonging to the character
set in use (e.g. latin1, utf-8, etc...), so it would be theoretically possible
to accomplish the highlighting with a syntax file alone, by simply inserting
the marker characters with CTRL-V or something similar. However, this would
require you to memorize the character codes corresponding to 8 colors and all
combinations of underline, bold, italic, etc... Thus, in addition to a syntax
file, Txtfmt provides a filetype plugin (ftplugin), which provides mappings
and functions to facilitate working with the format/color tokens. Inserting
tokens, finding (jumping to) tokens, and querying token type, are a few of the
operations that can be performed with mappings and/or functions defined in the
ftplugin.

==============================================================================
4. Installation					*txtfmt-installation*

DISTRIBUTED FILES				*txtfmt-dist-files*

The Txtfmt distribution comprises the following 4 files:

doc/txtfmt.txt		Txtfmt help file (this file)
ftplugin/txtfmt.vim	Txtfmt filetype plugin (contains mappings for working
			with Txtfmt tokens)
syntax/txtfmt.vim	Txtfmt syntax file (defines the Txtfmt syntax
			highlighting)
plugin/txtfmt.vim	Txtfmt common configuration code (contains
			configuration script needed by both the filetype and
			syntax plugins)
indent_patch.txt	Bram Moolenaar's patch to fix indent.vim's handling of
			dot-separated lists in 'filetype' option values
			(required only if your version of Vim is older than
			7.2 and you plan to "nest" Txtfmt within other
			filetypes)
			For details, see |txtfmt-combining|.

All of the txtfmt.vim files should be placed in their respective parent
directories, somewhere in your 'runtimepath'. If you need the patch files, you
may place them wherever you like.

IMPORTANT NOTE: To make Txtfmt help topics visible to Vim's :help command, you
must run :helptags, passing the path to the doc folder where you unpacked
txtfmt.txt as an argument.

DETECTING OR SETTING TXTFMT FILETYPE		*txtfmt-filetype*

Once you have copied the Txtfmt files to the appropriate directories in
'runtimepath', you can always use the Txtfmt syntax and mappings by manually
setting the 'filetype' option. (I am assuming, of course, that you have
enabled syntax at some point, most likely in your .vimrc. If you are not sure
about this, see |syntax-enable|.) The 'filetype' option may be set on the
command line: e.g. >
    :set ft=txtfmt

A better approach for a file designed to be viewed with Txtfmt highlighting
would be to set the filetype in a Vim modeline: e.g. >
    vim:ft=txtfmt

While the manual approach may be appropriate for some uses, if you find
yourself always using Txtfmt with certain types of files, it probably makes
sense to set up automatic detection via one of the methods discussed in the
section |new-filetype| in the Vim help. The simplest approach is to create
your own filetype.vim (assuming you haven't done so already) in a directory
that comes before $VIMRUNTIME in 'runtimepath'. Within this script, you should
define an autocommand that will :setfiletype to txtfmt for any file with an
appropriate extension.

Example: >
    " Set up detection for Txtfmt files
    au! filetypedetect BufRead,BufNewFile *.txt    setfiletype txtfmt

COMBINING TXTFMT WITH OTHER FILETYPES		*txtfmt-combining*

It is possible to use the Txtfmt plugins with the plugins of other filetypes.
This feature is useful when you wish to take advantage of Txtfmt's arbitrary
formatting capabilities in a file that would otherwise support only static
formatting. The simplest way to accomplish this is to set 'filetype' to a
dot-separated list of filetype names: e.g. "c.txtfmt". When you do this, Vim
will load the corresponding filetype and syntax files in the order in which
they appear in the list.

WARNING: Txtfmt's filetype plugin is designed to be used in this way; some of
the standard plugins, however, will skip loading if a plugin that sets
b:did_ftplugin has already been sourced. Thus, it is best to put Txtfmt last
in the list of filetypes.

The method just described is useful when you wish to use Txtfmt in conjunction
with an existing filetype. It is possible, however, that you simply wish to
extend Txtfmt by adding a few predefined formatting regions. As an example,
suppose you find yourself highlighting things like "TODO" and "IMPORTANT NOTE"
quite often in your Txtfmt files. You can always highlight them manually by
using Txtfmt markers; it would be more efficient, however, to define syntax
highlighting that handles these special cases automatically. You could do this
in a special Txtfmt syntax file, which you create in an "after" directory in
your 'runtimepath'. (See |after-directory|.)

Nesting Txtfmt regions				*txtfmt-nesting*

Whether you are combining Txtfmt with an existing filetype, or simply
extending Txtfmt's highlighting with predefined regions of your own, it is
possible that you will want to use Txtfmt's highlighting within non-txtfmt
syntax regions. If, for example, you are using Txtfmt in combination with C
syntax, you may wish to create Txtfmt regions within C comments. This is
possible, but only if you have set the |txtfmt-'nested'| option. If you are
nesting Txtfmt regions within non-Txtfmt regions, you should generally
terminate the Txtfmt regions explicitly, rather than relying upon the
containing region to terminate it. A containing region without a "keepend"
argument will not be able to terminate the Txtfmt region. A containing region
with "keepend" will terminate the Txtfmt region, but the containing region's
end marker may not be formatted correctly unless a "matchgroup" was used to
define it.

A few practical examples follow...

C source file nesting example:			*txtfmt-nesting-c-example*

Here is how you could use Txtfmt to format your C-language comments...

Put the following within your user "filetype.vim"
(e.g. $VIM/vimfiles/filetype.vim) >
    " Allow Txtfmt regions to be nested within C comments
    augroup filetypedetect
	au! BufRead,BufNewFile *.c    let b:txtfmtNested = 1
	au  BufRead,BufNewFile *.c    setf c.txtfmt
    augroup END

Now, you may use Txtfmt mappings to add color and formatting regions to your C
comments! (Technically, of course, you can format anything in the file, but
I'm assuming you want the source file to compile.)

						*indent_patch.txt*
IMPORTANT NOTE: Prior to Vim 7.2, the distributed version of "indent.vim" was
not aware of the dot-separated filetype name convention. Thus, if you're using
an older version of Vim, C-indenting will not work properly if you set
filetype to "c.txtfmt". Bram's patch for this issue is packaged along with the
Txtfmt files. If you have not yet upgraded to the latest version of Vim, and
you do not wish to apply the patch, you could work around the issue with an
alternative approach such as this: >
    " Allow Txtfmt regions to be nested within C comments without losing
    " cindent capability in pre-7.2 Vim.
    augroup filetypedetect
	" Set filetype to c
	au! BufRead,BufNewFile *.c    setf c
	" Make sure Txtfmt regions can nest within comments
	au  BufRead,BufNewFile *.c    let b:txtfmtNested = 1
	" Manually source the Txtfmt filetype and syntax plugin files...
	au  BufRead,BufNewFile *.c    runtime syntax/txtfmt.vim
	au  BufRead,BufNewFile *.c    runtime ftplugin/txtfmt.vim
    augroup END

Of course, it's probably easier just to upgrade Vim;-)

TVO nesting example:				*txtfmt-nesting-tvo-example*

Here is how you could use Txtfmt to format the ordinary text within .otl files
created with TVO (The Vim Outliner plugin written by Ned Konz)...

Put the following within the ftdetect/otl.vim file distributed with the TVO
plugin: >
	" This sets up *.otl files to be outlined
	au  BufRead,BufNewFile *.otl    setf otl.txtfmt

Important Note: Because the TVO plugin was not designed to work with the
"dot-separated" filetype syntax, it is important that your .otl files DO NOT
set 'filetype' within a Vim modeline; i.e., the set of 'filetype' to
otl.txtfmt should occur exclusively within the autocommand as shown above.

'Notes' nesting example:			*txtfmt-nesting-notes-example*

Here is how you could use Txtfmt to format the ordinary text within files
created with 'Notes' (the lightweight notes management plugin written by Hari
Krishna Dara)...

In your .vimrc, set the g:notesFileType option as follows: >
	let g:notesFileType = 'txtfmt'

This instructs the 'Notes' plugin to set 'filetype' to txtfmt for all notes
files it creates.

LOADING						*txtfmt-loading*

Note: This section is provided for informational purposes only; the average
user can safely skip.

The Txtfmt plugin is actually several plugins working in concert: a syntax
plugin implementing token based highlighting, and a filetype plugin
facilitating working with the tokens. There are a significant number of
options permitting customization of various aspects of both plugins. Due to
the tightly integrated nature of the syntax and filetype plugins, most of the
options used to customize Txtfmt's behavior have implications for both
filetype and syntax plugins. Problems can result when the filetype and syntax
plugins see different values for the shared options. Since most Txtfmt options
are used only when the plugin is sourced, option values can get out of sync if
the filetype and syntax plugins are sourced at different times with
intervening option changes. The best protection against this is to have the
plugins loaded in the standard manner, via :setfiletype or assignment to
'filetype' option, as previously described.

Just as many of the options are common to both filetype and syntax plugins, so
is much of the option processing and attendant configuration code. It would be
highly inefficient (and dangerous from a maintainability standpoint) to
maintain large blocks of identical Vim script in two different script files.
Accordingly, I have segregated the option/configuration processing, which is
common to both filetype and syntax, and located it in a separate file, which
is intended to be installed in the user's plugin directory:
($VIM/plugin/txtfmt.vim). Very little of the script in this file is actually
executed at Vim startup. Most of it is executed only upon demand by either the
filetype or syntax plugin (whichever happens to be sourced first when Txtfmt
is loaded). When the common configuration script is executed, it processes the
various options (|txtfmt-modeline|, buffer-local and global), and saves the
resulting configuration to buffer-local variables, where it may be accessed by
both the filetype and syntax plugins.

Although the details will vary according to the user's setup, it generally
works something like this...

-FileType set to txtfmt
--Txtfmt syntax file is sourced
---Txtfmt syntax file invokes common configuration code in
   $VIM/plugin/txtfmt.vim
--Txtfmt filetype plugin is sourced

==============================================================================
5. Configuration				*txtfmt-configuration*

OPTIONS						*txtfmt-options*

There are 3 ways for the Txtfmt user to set most Txtfmt options. The 3 methods
are listed below in order of highest to lowest priority.

    1. in a Txtfmt modeline
    2. with a buffer-local option variable
    3. with a global option variable

Note: Some options do not support all 3 mechanisms. The help for a specific
option indicates which mechanisms may be used to set it.

Txtfmt will attempt to determine the value of an option from the highest
priority mechanism employed by the user.
Note: If the option value obtained in this manner is invalid, Txtfmt will not
consider lower-priority mechanisms. (In other words, the decision about which
user setting to use is made before the option value is validated.)

Although different strategies may be conceived by the Txtfmt user, the
intended use of the 3 mechanisms is as follows:

Txtfmt modelines
	Used to associate options with a particular file
buffer-local
	Used to set options automatically for a particular buffer or filetype.
	Hint: Set buffer-local options in your local filetype.vim just before
	calling :setfiletype
global
	Used to set defaults for options not overridden by one of the
	preceding 2 methods

Buffer-local and global option variables are set just like any other such
variables in Vim.

Examples: >
	:let b:txtfmtEscape = 'bslash'
	:let g:txtfmtNested = 1

For details on setting options via Txtfmt modelines, see |txtfmt-modeline|.

Option naming convention			*txtfmt-opt-names*

Since the buffer-local and global Txtfmt options share a namespace with other
Vim global variables, the "txtfmt" prefix is prepended to these option names.
The option name itself is capitalized. Since a |txtfmt-modeline| is processed
only by Txtfmt, the "txtfmt" prefix is omitted from a |txtfmt-modeline| option
name. The modeline form of the option name is all lowercase, and just as with
Vim options, a short form of the option name is provided. In the option list
below, both the buflocal/global and modeline forms of each option are shown.


Option types					*txtfmt-opt-types*

Txtfmt options fall into one of three categories:

1. String options
2. Number options
3. Boolean options

In most cases, the rhs of the assignment used to set the option's value is
identical for all set mechanisms (txtfmt modelines, buffer-local and global),
except of course that string options are not quoted in a Txtfmt modeline.
Boolean options are a special case, however. Setting and clearing boolean
options in a Txtfmt modeline is accomplished in the same manner as it is for a
Vim modeline: by including the bare option name in the modeline to turn the
option on, or by prepending "no" to the bare option name to turn it off.

Examples: >
	" Txtfmt modeline that turns nesting ON
	txtfmt:nested
	" Txtfmt modeline that turns nesting OFF
	txtfmt:nonested

Number format					*txtfmt-opt-num-fmt*

Unless otherwise specified, a Txtfmt numeric option (represented with {number}
in this document) may be specified in either decimal or hexadecimal format:
e.g.
    0, 1000, 0x8f, 0x1F1F
are all valid values for numeric options.

Txtfmt modelines					*txtfmt-modeline*

Since a Txtfmt file should generally be viewed with the same set of options
that were in effect when it was created, Txtfmt provides a way to associate
certain option values with the file itself. Vim users should be familiar with
the concept of a modeline. Txtfmt extends this concept to a "Txtfmt-modeline",
which may be used to set various Txtfmt-specific options, described later. As
a general rule, an option that may be set from a Txtfmt-modeline may also be
set buffer-locally and/or globally, using the corresponding buffer-local or
global option variable.
Note: Txtfmt will search the first and last |txtfmtModelines| lines of a file
looking for a Txtfmt-modeline. All valid Txtfmt-modelines found will be used;
however, the search for valid modelines stops as soon as an invalid modeline
is encountered. (This is consistent with Vim's modeline processing.)

Format of a Txtfmt-modeline			*txtfmt-modeline-fmt*
	Txtfmt modelines are based upon the 1st Vim modeline format
	       [text]{white}txtfmt:[white]{options}

	where {options} is a comma or whitespace separated list of Txtfmt
	option settings. For a description of the various {options}, see
	|txtfmt-opt-list|.

	Note: Since Vim will not choke on a trailing ':' (probably because a
	trailing ':' may be viewed as introducing an empty option field),
	neither will I.

	Examples: >
		txtfmt:tokrange=180X:escape=bslash
		txtfmt:rng=0xE000L esc=self nested

Refreshing display after option changes		*txtfmt-opt-refresh*

As mentioned in the section on "Loading" (|txtfmt-loading|), option values are
generally taken into account only at the instant the plugin using them is
sourced. Thus, changes to one of the Txtfmt options discussed below will have
no immediate effect upon a Txtfmt buffer that has already been loaded. If you
have changed option settings and wish to have those changes applied to a
loaded Txtfmt buffer, you have a choice of three methods:

    1) :e[dit]
    This is probably the simplest method. It relies upon a buffer-local
    BufReadPre autocmd, whose job is to ensure that all options will be
    re-processed when the filetype/syntax plugins are reloaded in response to
    the BufRead event.

						*txtfmt-:Refresh*
    2) :Refresh
    :Refresh is a buffer-local command, which may be invoked from any loaded
    Txtfmt buffer. For most practical purposes, this method yields the same
    results as ":e[dit]", although the implementation is significantly
    different (and more complex). In particular, :Refresh does not actually
    re-edit the file, so the various BufRead autocommands will not be
    triggered. It works via assignments to 'filetype' and/or 'syntax', as
    appropriate.

    3) :bd[elete] (followed by re-edit of the file)
    This is arguably the safest method, since a :bdelete unlets all
    buffer-local variables, thus wiping out all "memory" of any previous
    Txtfmt plugin load for the current buffer. Of course, you shouldn't use
    this method if you don't want to lose other (non-Txtfmt) buffer-local
    variables.


Option List					*txtfmt-opt-list*

The following is a comprehensive list of Txtfmt options. In the list below,
the option name as it would appear in a |txtfmt-modeline| is given within
single quotes (''). The variable name used for global or buffer-local
assignments is listed without the leading "g:" or "b:", but is accompanied by
a string such as "global" or "global or buffer-local" to indicate how it may
be set.

						*txtfmtColor{}*
						*txtfmtBgcolor{}*
txtfmtColor{1..8}
txtfmtBgcolor{1..8}	old-style array of strings
			(default: See |txtfmt-color-defaults|)
			global or buffer-local
	These old-style Vim "arrays" allow you to override the default colors
	corresponding to the 8 foreground and 8 background color tokens. It is
	possible to override none, some, or all of the colors. The
	txtfmtBgcolor{} array may be used to configure background colors
	differently from foreground colors. The txtfmtColor{} array applies
	not only to foreground colors, but also to background colors for which
	the corresponding entry in txtfmtBgcolor{} has not been defined.
	Txtfmt considers each color index independently of all others; thus,
	it is possible to set only those elements whose default color you wish
	to override. Note that for a foreground color, "default" in this
	context refers to the default color definition provided by the Txtfmt
	plugin; for a background color, it could also refer to the default
	provided by the txtfmtColor{} array. In other words, you can provide
	overrides for both foreground and background colors in txtfmtColor{},
	then use txtfmtBgcolor{} to override only the subset of background
	colors you wish to differ from their corresponding foreground colors.
	For details on the format of the strings, see |txtfmt-color-config|.

			*txtfmt-'conceal'* *txtfmt-'cncl'* *txtfmtConceal*
'conceal' 'cncl'
txtfmtConceal		boolean (default on when has('conceal') == 1)
			global or buffer-local
			*** New in version 2.0 ***
	This option determines whether Txtfmt will attempt to use the
	concealment capability provided either by the "conceal" feature (Vim
	versions >= 7.3) or by Vince Negri's "conceal / ownsyntax" patch
	(available for older versions of Vim). Note that this option is
	ignored when has("conceal") returns 0.
	Note: You can check to see whether your version of Vim supports the
	"conceal" feature either by executing has('conceal'), or by searching
	the output of :version for the applicable feature string:
		+conceal (enabled)
		-conceal (disabled)

	The ideal Txtfmt token is zero-width, affecting the highlighting of
	subsequent text without taking up any visible space in the Txtfmt
	buffer. Such "zero-width" Txtfmt tokens are the default in versions of
	Vim >= 7.3. In older versions of Vim, zero-width tokens were possible
	only for users who built a custom version of Vim with Vince Negri's
	"conceal / ownsyntax" patch. When the "conceal" feature is enabled,
	Txtfmt will attempt to conceal completely all tokens not in the cursor
	line. (Whether or not tokens in the cursor line are concealed depends
	upon the |txtfmt-'concealcursor'| option setting.)

	When the "conceal" feature is disabled (either by this option or by
	lack of support in Vim), Txtfmt attempts to conceal the special
	formatting tokens by making each appear as a single space character,
	each of which consumes a single column of screen width. Although this
	is typically not an issue when the tokens can be placed at the end of
	a line or on a line by themselves, it can be a source of annoyance in
	certain scenarios. Consider, for example, the case in which you want
	to highlight a single word in red bold. You would need to insert both
	a red fg color and a bold format token prior to the word, and both the
	'no format' and 'no fg color' tokens immediately after the word. Since
	each token appears as a single space, the highlighted word will appear
	to be surrounded by more whitespace than usual. This becomes even more
	of an issue in the unlikely event you wish to highlight only part of a
	particular word. For this reason, Txtfmt will always use the "conceal"
	feature whenever it is available.

	*txtfmt-conceal-notes* *txtfmt-conceal-history*
	*txtfmt-conceal-backwards-compatibility*
	Prior to Vim 7.3, the default setting of the |txtfmt-'conceal'| option
	was "off", even when has("conceal") indicated that the feature was
	enabled in Vim (i.e., because the user had applied Vince Negri's
	"conceal" patch). This design choice was made, in spite of the fact
	that use of the "conceal" feature is optimal, primarily for reasons of
	backwards-compatibility. In particular, as annoying as non-zero-width
	tokens might be, many users were sure to have created files that
	relied upon the tokens' width to achieve proper indenting. A 4 space
	leading indent, for instance, might have been realized with a bold
	format token followed by 3 spaces. Suddenly concealing the bold format
	token would break the alignment.

	Although this rationale is still valid, it is no longer sufficient (in
	my judgment) to justify disabling the "conceal" feature by default,
	now that the feature has been incorporated into Vim itself. First-time
	Txtfmt users who begin using the plugin with Vim 7.3 will naturally
	expect the plugin to take advantage of the "conceal" feature without
	any explicit action on their part. Such users might not even be aware
	of the existence of this option. Presenting Txtfmt in a sub-optimal
	light (i.e., without "conceal" functionality) would increase the
	probability that such users would abandon use of the plugin before
	becoming sufficiently familiar with its documentation to learn that
	they had the power to enable the "conceal" feature with a simple
	option setting.

	*txtfmt-viewing-old-files-without-conceal*
	If you have legacy files that are best viewed without the "conceal"
	feature, but you're using a version of Vim with compiled-in support
	for "conceal", you may wish to view the old files with "noconceal",
	and view all newly-created Txtfmt files with "conceal". This is easily
	accomplished as follows...

	1. Set txtfmtConceal true globally, either by leaving the option at
	   its default, or setting it explicitly in your vimrc. E.g.,
		let g:txtfmtConceal = 1

	2. Use Txtfmt modelines in your old files to disable the "conceal"
	   feature for those files only. E.g.,
		txtfmt:noconceal

	Note: If you have many old files, you might wish to automate the
	addition of the modelines with a simple sed or awk script: E.g.,

	find . -iname '*.txtfmt' | xargs sed -i -e '$a\' -e 'txtfmt:noconceal'

	Explanation: Adds a Txtfmt-modeline disabling "conceal" on the last
	line of all .txtfmt files recursively under the current directory.
	Note: Txtfmt will process up to |txtfmtModelines| modelines at the
	beginning or end of a file; thus, the command above simply adds a new
	modeline without bothering to check for an existing one.

	Of course, the strategy outlined above is merely a suggestion. You can
	use a combination of Txtfmt modeline and buffer-local / global option
	settings to achieve whatever behavior you desire.

		*txtfmt-'concealcursor'* *txtfmt-'cocu'* *txtfmtConcealcursor*
'concealcursor' 'cocu'
txtfmtConcealcursor	string (default: "nvic")
			global or buffer-local
			*** New in version 2.4 ***
	Important Note: The default value of this option may change in a
	future version of Txtfmt. If you care about its value, you should set
	it explicitly.

	Note: This option is ignored when the "conceal" feature is disabled
	(via the |txtfmt-'conceal'| option) or is not supported by the running
	Vim instance.

	This option determines whether Txtfmt tokens in the line containing
	the cursor are concealed. Its value is a string of single character
	flags indicating the modes for which tokens in the cursor line should
	be concealed. The flags are defined as follows in the Vim help:

	  n		Normal mode
	  v		Visual mode
	  i		Insert mode
	  c		Command line editing, for 'incsearch'
		
	For detailed descriptions, see Vim help on 'concealcursor'...

	Note: Some new users might be disconcerted by the fact that with the
	default setting of this option, the tokens disappear as soon as they
	are entered. (After all, he might wish to delete them at some point.)
	This will not be a concern at all once visual maps (targeted for next
	release) have been added. These maps will automate addition/removal of
	tokens completely, such that the user needn't even be aware of the
	tokens' existence. In the meantime, however, the best way to locate
	existing tokens does not require you to see them: it involves use of
	the |txtfmt-jump-to-tok| maps, which facilitate locating Txtfmt tokens
	by their types; additionally, the |\ga| map (|txtfmt-get-tok-info|)
	may be used to learn the nature of the token under the cursor, even
	when the token is completely concealed (i.e., occupying zero width).

				*txtfmt-'escape'* *txtfmt-'esc'* *txtfmtEscape*
'escape' 'esc'
txtfmtEscape		string (default: "none")
			global or buffer-local
	This option determines how (if at all) the special format/color tokens
	may be escaped in a Txtfmt buffer. Escaping would be necessary only in
	the unlikely event that you needed to use the special tokens in a file
	for a non-Txtfmt purpose. Hopefully, you have chosen a value for
	|txtfmt-'tokrange'| that renders this unnecessary. If so, it is safe
	to leave this option at its default value: "none". The following
	values are possible:
		bslash	Escape a format/color token with backslash ('\')
		self	Escape a format/color token with itself (i.e., by
			doubling the special chars)
		none	No escaping of format/color tokens
	Note: Escaping characters themselves may be escaped, but only when
	they appear in an unbroken sequence immediately preceding a Txtfmt
	token. Examples for both the "bslash" and "self" cases are shown
	below...

	--bslash--
	\<fb>             Escaped bold format token
	\\<fb>            Backslash followed by bold format token
	\\\<fb>           Backslash followed by escaped bold format token
	--self--
	<fb><fb>          Escaped bold format token
	<fb><fb><fb>      Escaped bold format token followed by bold format token
	<fb><fb><fb><fb>  Escaped bold format token followed by escaped bold
	                  format token
	Note: When a Txtfmt token is escaped, the escaping character will be
	hidden, and the escaped character should be highlighted just like the
	surrounding text.

		    *txtfmt-'fgcolormask'* *txtfmt-'fcm'* *txtfmtFgcolormask*
		    *txtfmt-'bgcolormask'* *txtfmt-'bcm'* *txtfmtBgcolormask*
'fgcolormask' 'fcm'
txtfmtFgcolormask	string (default: "11111111")
			global or buffer-local
			*** New in version 2.0 ***
'bgcolormask' 'bcm'
txtfmtBgcolormask	string (default: "01101000")
			global or buffer-local
			*** New in version 2.0 ***

	These options permit you to deactivate colors you do not wish to view
	in your Txtfmt buffer. Typically, colors are deactivated for
	performance reasons. (See |txtfmt-performance-considerations|.) Each
	option is a string containing exactly 8 characters. Each of the 8
	characters corresponds to one of the 8 possible colors in the
	corresponding color definition array. (For information on color
	definition arrays, see help on |txtfmtColor{}|.) The first character
	in the string corresponds to the first element in the color array. The
	meaning of the mask characters is as follows:
	"1"	activates the color
	"0"	deactivates the color

	Consider the bgcolormask default as an example: 01101000
	This mask enables the colors corresponding to indices 2, 3 and 5 in
	the background color definition array. In the default color definition
	arrays, these indices correspond to blue, green and red, respectively.
	For performance reasons, I enable only these 3 most commonly used
	background colors by default. Feel free to enable an entirely
	different set of colors if you like. For backward-compatibility
	reasons, the default fgcolormask enables all foreground colors.
	However, if you notice there are foreground colors that you never use,
	you can deactivate them to speed up the syntax redrawing.

	Note: Deactivating a color does not alter a Txtfmt buffer in any way.
	The character code corresponding to the deactivated color continues to
	be reserved within the Txtfmt token range; it simply has no effect on
	highlighting.

						*txtfmtJumptoinactive*
txtfmtJumptoinactive	boolean (default off)
			global or buffer-local
	This option determines whether the |txtfmt-jump-to-tok| maps will
	treat an inactive (masked) fg or bg color token as the target of a
	jump. By default, only tokens that affect the highlighting of the
	Txtfmt buffer will be considered as potential jump targets.
	Note: Currently, this option may be set at any time; i.e., a change
	will take effect even after the plugin has loaded. This behavior is
	subject to change.

						*txtfmtMapwarn*
txtfmtMapwarn		string (default: "mMoOcC")
			global
	This option determines what the Txtfmt filetype plugin does when one
	of its default 1st level maps is either ambiguous or conflicting with
	an existing map. For an explanation of 1st and 2nd level maps, see
	|txtfmt-map-config|. For a description of the character flags
	comprising the option value, see |txtfmt-map-conflict|.

						*txtfmtModelines*
txtfmtModelines		number (default: 5)
			global or buffer-local
	This option is analogous to Vim's 'modelines' option. It determines
	how many (if any) lines at the beginning and end of a file will be
	searched for a |txtfmt-modeline|. For (hopefully) obvious reasons, it
	cannot be set from a txtfmt-modeline.

			*txtfmt-'nested'* *txtfmt-'nst'* *txtfmtNested*
'nested' 'nst'
txtfmtNested		boolean (default on)
			global or buffer-local
	This option determines whether Txtfmt regions can be nested within
	non-txtfmt regions. If you are not sure what this means, see
	|txtfmt-nesting|.

			*txtfmt-'pack'* *txtfmt-'pck'* *txtfmtPack*
'pack' 'pck'
txtfmtPack		boolean (default on)
			global or buffer-local
			*** New in version 2.0 ***
	This option determines the offset within the Txtfmt token range where
	the background color tokens are located. By default, the background
	color tokens are "packed" up against the end of the format token
	range. In other words, space within the range is not reserved for the
	inactive "long" format tokens. Currently, there is little reason to
	reserve space for inactive "long" format tokens: you cannot have both
	"long" formats and background colors in the same buffer. Moreover,
	there are backward-compatibility concerns that dictate the packing of
	background color tokens. There are, however, several reasons you might
	wish to leave space for "long" format tokens, even if you're not
	currently using them. It is recommended that you read the following
	section for details: |txtfmt-upgrading-to-extended-long-formats|

	Note: This option is meaningful only if the tokrange suffix is 'X'
	(extended).

						*txtfmt-'sync'* *txtfmtSync*
'sync'
txtfmtSync		string or number (default: 250)
			global or buffer-local
	This option determines the method used to perform syntax
	synchronization on a Txtfmt buffer. (For an overview of syntax
	synchronization, see |:syn-sync|.)

	Possible values:
	    fromstart	Syncing always starts at the beginning of the Txtfmt
			buffer. This is the most accurate, but least efficient
			method.
	    none	Syncing is not performed at all. This method is
			extremely fast, but may produce incorrect highlighting
			for Txtfmt regions that begin prior to the first
			visible screen line.
	    {number}	Works as though a "minlines={number}" argument has
			been supplied to Vim's |:syn-sync| command.
			(See |:syn-sync-minlines|for more information.)

	Set examples: >
	    let g:txtfmtSync = "fromstart"
	    let g:txtfmtSync = 500

	    " In a modeline...
	    txtfmt:sync=none
	    txtfmt:sync=100
<

			*txtfmt-'tokrange'* *txtfmt-'rng'* *txtfmtTokrange*
			*txtfmt-starttok* *txtfmt-formats*
'tokrange' 'rng'
txtfmtTokrange		string or Vim expression evaluating to string
			(default:
				1 byte encoding: "180X"
				2 byte encoding: "180X"
				unicode:         "0xE000X")
			format: {number}[{formats}]
			global or buffer-local
	This option allows the user to specify both the location of the range
	of characters dedicated to Txtfmt and the types of highlighting
	regions that may be created: {number} specifies the character code of
	the first character in the range; {formats}, if specified, is a single
	letter indicating the types of regions supported. The following values
	are supported:
	    'S' ("short" formats)
	    'L' ("long" formats)
	    'X' ("extended")
	All 3 modes suppport up to 8 foreground colors. Short format mode
	supports only the bold, underline and italic format attributes,
	whereas long formats adds to this basic set the standout and reverse
	(inverse) attributes, and if the version of Vim in use supports it,
	the undercurl attribute. Extended mode is equivalent to short formats
	with the addition of up to 8 background colors. Note that for
	performance reasons, you are currently not permitted to enable both
	long formats and background colors. If you wish to know why (and
	whether this restriction will ever be lifted), see
	|txtfmt-upgrading-to-extended-long-formats|.

	The table below provides a convenient illustration of the effect each
	{formats} value has on the set of supported highlight attributes.

                       {--{formats}--}
        +-------------------------------+          
        |              S      L      X  |  
        +-------------------------------+
        |underline     Y      Y      Y  |
        |bold          Y      Y      Y  |
        |italic        Y      Y      Y  |
        |standout      -      Y      -  |
        |reverse*      -      Y      -  |
        |undercurl     -      Y*     -  |
        +-------------------------------+
        |fg_clrs     <=8    <=8    <=8  |
        |bg_clrs       -      -    <=8* |
        +-------------------------------+

	*Note: "Reverse" is another name for "inverse".
        *Note: Versions of Vim prior to 7.0 did not support the undercurl
	attribute; thus, Txtfmt will automatically disable undercurl if it
	detects a Vim version < 7.0.
	*Note: By default, only 3 background colors are enabled. You may
	enable more with the |txtfmt-'bgcolormask'| option.

	If you omit the optional {formats} suffix, Txtfmt assumes the default
	of 'X'. The suffixes are all case-insensitive.

						*txtfmt-'tokrange'-expr*
	Note: If the option string is not a valid 'tokrange' string, Txtfmt
	will attempt to evaluate the option string as a Vim expression. If
	this evaluation produces a valid 'tokrange' value, Txtfmt will use it;
	otherwise, Txtfmt will display error and use a default setting. This
	feature permits you to defer the choice of 'tokrange' until a
	particular file is being loaded. (Alternatively, you could defer
	choosing 'tokrange' by performing buf-local sets within autocommands
	or by using a |txtfmt-modeline|.) >
	Example:
		let g:txtfmtTokrange = 'MyTokrangeChooser()'
		let g:txtfmtTokrange = '&enc == "utf-8" ? "0xE000X" : "180X"' 
<

	If you do not specify this option, either in a |txtfmt-modeline| or
	via the txtfmtTokrange option variable, Txtfmt will attempt to choose
	a suitable default. However, you should probably not let Txtfmt choose
	a default for an option as important as this one. It is recommended
	that you read |txtfmt-choosing-token-range| before setting this
	option. Moreover, it is recommended that you use the :MakeTestPage
	command to test whatever setting you ultimately choose. (See
	|txtfmt-:MakeTestPage|.)

			*txtfmt-'undercurl'* *txtfmt-'uc'* *txtfmtUndercurl*
'undercurl' 'uc'
txtfmtUndercurl		boolean (default on if running Vim supports undercurl)
			global or buffer-local
			*** New in version 2.0 ***
	Txtfmt disables use of the undercurl attribute automatically for
	versions of Vim that don't support it (i.e., Vim versions older than
	7.0). Turning this option off prevents the creation of undercurl
	regions, even when the running version of Vim does support it. You
	might wish to do this for performance reasons if you use "long"
	formats but rarely if ever use undercurl. Disabling undercurl cuts the
	number of format tokens in the Txtfmt token range in half. Of course,
	the token reduction is not as significant as the associated runtime
	performance improvement, especially if you're using Unicode, in which
	character codes are plentiful. For a more detailed look at performance
	considerations, read |txtfmt-performance-considerations|.

	As is the case with color masks, setting or clearing this option does
	not alter a Txtfmt buffer in any way; it merely alters its syntax
	highlighting. Thus, there is nothing to prevent you from disabling
	undercurl until you find you have need of it. Suppose, for example,
	you have recently upgraded to the current version of Vim from a
	pre-7.0 version (i.e., one that doesn't support undercurl). Suppose
	further that you've been managing without undercurl, and you're not
	sure you really need it. You could put a line such as... >
	let g:txtfmtUndercurl = 0
<
	...in your vimrc to disable undercurl globally until you decide you're
	ready to use it. Alternatively, you may decide you want to use
	undercurl right away, but you have a number of legacy files, created
	under the old version of Vim, which do not have undercurl regions and
	probably never will. To avoid paying a performance penalty when
	viewing these legacy files, you could add the following Txtfmt
	modeline to the legacy files: >
		txtfmt:nouc
<
	Caveat: For backward-compatibility reasons, disabled undercurl tokens
	are not considered to be part of the Txtfmt token range in the same
	way that disabled color tokens are. This fact has implications for the
	|txtfmt-:MoveStartTok| command, which will not attempt to translate
	characters corresponding to disabled undercurl tokens. Another
	implication of this fact is that you will not be warned if you choose
	a |txtfmt-'tokrange'| setting that does not leave room for undercurl
	tokens at the end of the range. Of course, this is not really an
	issue, since if you did eventually decide to enable undercurl in such
	a case, you could simply run the :MoveStartTok command to translate
	the entire token range leftward, thereby making room for the undercurl
	tokens.
	
						*txtfmtUsermap{}*
txtfmtUsermap{}		old-style array of strings
			(default: none)
			global or buffer-local
	This old-style Vim "array" allows you to build your own complex
	mappings from Txtfmt primitives, by using a powerful mechanism known
	as "Txtfmt user-maps". The user-map mechanism is described in detail
	in section |txtfmt-user-maps|.
	Note: First element of the array is at index 1.

						*txtfmtUsermaplimit*
txtfmtUsermaplimit	number (default: 25)
			global or buffer-local
	Defines the number of elements of txtfmtUsermap{} (described above)
	that will be tested for valid user-map definitions.

CHOOSING A TOKEN RANGE				*txtfmt-choosing-token-range*

						*txtfmt-encoding*
Before choosing a value for the |txtfmt-'tokrange'| option, you should
consider what character encoding you will be using. Because of the sheer
number of available character codes, utf-8 is perhaps the ideal encoding for
use with Txtfmt.

						*'short'/'long'-formats*
The number of character codes that must be dedicated to Txtfmt usage depends
upon the setting of txtfmt-'tokrange'. The number of tokens required for
format attributes is given by 2^N, where "N" is the number of format
attributes (e.g., bold, underline, etc...). As mentioned in the help for the
|txtfmt-'tokrange'| option, N will be 3 if "short" or "extended" formats are
selected and either 5 or 6 if "long" formats are used. All tokrange settings
require exactly 9 tokens to be reserved for foreground colors. If background
colors have been enabled ("extended" formats), an additional 9 tokens are
reserved. The following table illustrates the character range requirements
graphically.
Note: The undercurl column indicates whether the undercurl attribute is
active. It will be "on" if the version of the running Vim is >= 7.0 AND
undercurl has not been explicitly disabled via the |txtfmt-'undercurl'|
option.

  +--------+-----------+------------+
  | suffix | undercurl | num tokens |
  +--------+-----------+------------+
  |   S    |   NA      |    17      |
  |   X    |   NA      |    26      |
  |   L    |   off     |    41      |
  |   L    |   on      |    73      |
  +--------+-----------+------------+


When I wrote the initial version of the Txtfmt plugin, only the "short" format
attributes (bold, underline and italic) were supported. Accordingly, only 17
tokens needed to be dedicated to Txtfmt usage. At that time, I assumed that
only ASCII characters would be used for text. (The initial version of Txtfmt
was actually called "ascfmt"!) Since that time, my mindset has grown a bit
more global, and I now envision Txtfmt usage with a wide variety of character
encodings. If Txtfmt is configured for use with all possible format attributes
(bold, underline, italic, standout, reverse and undercurl), the Txtfmt token
requirement jumps to 73. Although it is possible for many English speakers
using a "latin1" encoding to forego the use of 73 character codes in the range
128-255, Europeans may find this restriction unacceptable, given the presence
of a number of accented characters in that range. If you're using a multibyte
character set such as Unicode, you should have no difficulty finding an unused
sequence of 73 characters to dedicate to Txtfmt. (Hint: see
|txtfmt-private-use-area| below.)

					*txtfmt-performance-considerations*
The number of character codes dedicated to Txtfmt usage is not the only factor
you should consider when choosing a |txtfmt-'tokrange'| setting. The tokrange
setting also determines the number of syntax regions Txtfmt must define in
order to accomplish the desired highlighting. The number of syntax regions, in
turn, directly affects the speed with which Vim can load and redraw a Txtfmt
buffer. Consider, as an example, the choice between "short" and "long"
formats. Although it supports only 3 additional format attributes, the "long"
formats configuration requires roughly 10 times as many syntax regions as
"short" formats! This increase in the number of syntax regions engenders a
significant increase in CPU overhead consumed by syntax highlighting, even
when the additional format attributes are not used, since Vim must spend time
checking the unused region definitions. On some systems, the performance
penalty is large enough to render display of "long" formats noticeably
sluggish.

With the addition of "extended" formats (i.e., background colors) in Txtfmt
version 2.0, performance considerations have become even more significant. The
addition of 8 background colors to the "short" formats baseline results in a
thirty-fold increase in the number of syntax regions! (Hint: The dramatic
increase is due to the "orthogonality" of the various types of regions.)
Fortunately, Txtfmt allows you to reduce the number of syntax regions
considerably (thereby increasing load/redraw speed) by "de-activating" unused
colors. Consider that the typical user may never use more than 3 or 4 colors
in his Txtfmt buffers. If Txtfmt knows in advance which colors are used, it
can avoid defining syntax regions for the unused ones. Note that the tokens
corresponding to these inactive colors will still be reserved by Txtfmt, since
if the token range were "collapsed" on top of unused color tokens, it would be
impossible (or at least difficult) to re-activate the colors later when, for
example, the user got a faster computer and decided he might occasionally use
the extra colors.

Txtfmt provides the following 2 "color mask" options to permit you to
enable foreground and background colors independently:
        |txtfmt-'fgcolormask'|
        |txtfmt-'bgcolormask'|
If you don't define these options, Txtfmt will enable all 8 foreground colors,
and the 3 background colors corresponding to red, green and blue in the
default color configuration.

                                                *txtfmt-syn-rgn-count-table*
The following table is intended to aid you in choosing your
|txtfmt-'tokrange'| suffix and fg/bg color masks, by showing the number of
syntax regions required for various configurations and numbers of active fg/bg
colors. The list is intended to be representative, not exhaustive.
Note: To facilitate comparison, the table rows are presented in order of
increasing syntax region counts.

  +--------+-----------+-----------+------------+
  | suffix | # fg clrs | # bg clrs | # syn rgns |
  +--------+-----------+-----------+------------+
  |   S    |     8     |     NA    |    142     |
  |   L*   |     8     |     NA    |    574     |  * no undercurl
  |   L    |     4     |     NA    |    638     |
  |   X    |     5     |     2     |    684     |
  |   X    |     4     |     4     |    990     |
  |   L    |     8     |     NA    |    1150    |
  |   X    |     8     |     3     |    1448    |
  |   X    |     8     |     4     |    1846    |
  |   X    |     6     |     6     |    2030    |
  |   X    |     8     |     8     |    3438    |
  +--------+-----------+-----------+------------+
                                               
                                                *txtfmt-upgrading-tokrange*
If you don't currently need background colors or "long" formats and thus are
considering the use of "short" formats because of the reduced token
requirement, but suspect that you may eventually want to use either "long"
format attributes or background colors, it may be reassuring to know that the
implementation has been designed to permit a seamless "upgrade" from "short"
to "long" or "extended" formats.

As an example, consider a Txtfmt file with the following |txtfmt-modeline|: >
	txtfmt:tokrange=180S

This file will use tokens in the range 180-196 to support 8 colors as well as
all combinations of bold, underline and italic attributes. If you decide at
some point that you would like to begin using standout, reverse and undercurl
attributes in this file, simply change the modeline to the following: >
	txtfmt:tokrange=180L

The original (bold, underline and italic) regions will be unaffected, but you
will now be able to create regions with all 63 combinations of format
attributes. The cost is an extra 56 character codes that will be unavailable
for normal text usage. The expanded range of characters used by Txtfmt is now
180-252.

Alternatively, if you were content with bold, underline and italic format
attributes, but wished to add background colors to your buffer, you could have
upgraded from "short" to "extended" with the following modeline: >
	txtfmt:tokrange=180X
<

                                *txtfmt-upgrading-to-extended-long-formats*
                                *txtfmtAllowxl*
It should be pointed out that the default location for background color tokens
is just past the end of the "short" format tokens. Note that this is precisely
where the "long" format tokens would be located. Ideally, since the format
token range is the only variable-length range, the background color tokens
would have been located before it. Such a strategy would have permitted the
user to switch freely back and forth between "extended" and "long" formats
without the need to move or delete any existing background color tokens.
Unfortunately, for reasons of backward-compatibility, the background color
tokens had to go after all other tokens. The reason is that earlier versions
of Txtfmt, which didn't support background colors at all, used a default for
tokrange that puts the first token at the very beginning of Unicode's Private
Use Area. Locating background color tokens at the head of the token range,
therefore, would require users to translate the tokens at least 9 characters
rightward in their existing files if they wished to use background colors.
This was out of the question, as one of my design goals for version 2.0 was to
ensure that a user who wished to add background colors to a buffer created
with an older version of Txtfmt would be able to do so simply, i.e., without
the need for special upgrade steps.

The fact that background color and "long" format tokens occupy overlapping
ranges means that, by default, you can't have both background colors and long
formats active in the same buffer. Of course, it would have been possible to
locate the background color tokens after the long token range, leaving the
long tokens reserved but unused when only "short" formats are active. Although
this strategy would support simultaneously active long formats and background
colors, it would have broken backward compatibility. The reason is that the
default tokrange for the latin1 encoding is such that there is not enough room
after the final long format token for the range of background color tokens.
Thus, users with existing files that use the default tokrange would be
required to translate their entire token range at least 9 characters leftward
prior to enabling background colors. In light of the previously stated design
goals, this was unacceptable. Thus, by default, the background color tokens
are "packed" in just after the short format tokens. It is possible, however,
to override this default behavior by clearing the |txtfmt-'pack'| option. When
this option is turned off, the background color tokens will be located after
the range reserved for long format tokens, even when the configuration is such
that long formats are disabled.

Why would you ever wish to clear the |txtfmt-'pack'| option? Well, there are
two possible motivations:
1. You're not initially sure whether you would prefer to have background
   colors or long formats.
   Example scenario: You're currently using "extended" formats, but you've
   done a lot of editing and have inserted only a handful of background
   colors. Moreover, you've found yourself wishing more than once for the
   undercurl attribute. At this point, you could simply change the tokrange
   suffix from 'X' to 'L' and begin using undercurl. If |txtfmt-'pack'| had
   been set when you added the background color tokens, those tokens would now
   be interpreted as long format tokens, thereby introducing unwanted format
   regions. Since |txtfmt-'pack'| was clear, however, they are located
   harmlessly beyond the end of the Txtfmt token range, and will therefore
   have no effect.
2. You know that one day Txtfmt will support the 'XL' (extended long) tokrange
   suffix, and you want to create files that will be able to transition
   seamlessly from 'X' or 'L' to 'XL'.
   Note: Unofficially, Txtfmt already does support the 'XL' suffix, but it is
   currently disabled for performance reasons. If you're wondering why, you
   may be interested to know that the 'XL' suffix requires 28633 syntax
   regions!!! On my machine, Vim crashes if I attempt to use 'XL' formats with
   all foreground and background colors enabled! I can get it to load without
   crashing by de-activating several colors, but even then, syntax definitions
   are sometimes silently corrupted, apparently because Vim has run out of
   memory for storing them. For this reason, I do not advertise support for
   'XL', and in fact it is disallowed by default. However, if you set the
   global |txtfmtAllowxl| option to a nonzero value before attempting to load
   Txtfmt, you will be able to set suffix to 'XL'. (If you do, you may wish to
   go make a pot of coffee while you wait for the file to load, and if Vim
   crashes while you're gone, don't say I didn't warn you...;-)

						*txtfmt-start-token*
						*txtfmt-private-use-area*
If you're using Unicode, the "Private Use Area" (a block of character codes
beginning at 0xE000) is probably the ideal location for the Txtfmt token
range. This block is reserved for "application-specific" use, and is
guaranteed never to be used for actual characters.

						*txtfmt-multibyte-syntax-bug*
Note: Several beta-release versions of Txtfmt did not work correctly with
multibyte encodings because of a Vim bug involving the treatment of offsets
used in syntax highlight matches. A patch for the Vim bug was created by
Yukihiro Nakadaira, and was included in the Txtfmt distribution. Only users
who applied the patch were able to use Txtfmt with a multibyte encoding such
as utf-8. As of Txtfmt version 1.1, however, the patch was no longer
necessary, as workaround logic had been added to Txtfmt itself. Moreover,
Yukihiro's patch has been incorporated into Vim 7.2, so Txtfmt's internal
workaround is required only for older versions of Vim. There is, however, one
_extremely_ rare scenario in which someone running a version of Vim older than
7.2 might wish to apply the patch: namely, when different characters within
tokrange are encoded with different numbers of bytes. Since the number of
bytes per character is usually constant across a large block of Unicode
characters, only users wishing to set tokrange to a very non-standard value
would be affected by this limitation. All of the default tokrange settings
work properly with no need for the patch. Thus, as of Txtfmt version 1.5, I'm
removing Yukihiro's patch from the distribution (to avoid frightening away new
users;-). If you determine that you need it, you can obtain it from a Txtfmt
version <= 1.4. Note, however, that you should never need this patch if you're
running Vim 7.2 or later.

						*txtfmt-problematic-ranges*
Not all character codes are suitable for use as Txtfmt tokens. In particular,
only tokens that are susceptible to Vim's syntax highlighting should be used.
For a color terminal, characters used in terminal control sequences are
sometimes immune to syntax highlighting. The specific character code ranges
affected will vary from terminal to terminal. For latin1 and utf-8 encodings,
characters in the range 0x80-0xA0 should generally be avoided, as they tend to
cause problems in both GUI and terminal versions of Vim. (Exception: The
Windows GUI appears to be able to handle this range.) For utf-8 encodings,
only 16-bit character codes should be used, as Vim does not display characters
above 0xFFFF correctly. Note that not all 16-bit values correspond to a valid
Unicode character. The ones that do not will be displayed as <xxxx> (where
xxxx is the hexadecimal representation of the character code). These
"characters" cannot be highlighted and should not be used.

As a general rule, modern unix-style terminals tend to work best when Unicode
is used. I have found by experimentation that some ranges of tokens work
perfectly when 'encoding' is set to utf-8, but don't work at all when it is
set to latin1. The bottom-line is, if you're using a color terminal designed
to work with Unicode, you should probably keep 'encoding' at utf-8. If for
some reason you must use a different encoding, you should experiment with the
|txtfmt-:MakeTestPage| command to find a setting for |txtfmt-'tokrange'| that
works.

						*txtfmt-default-tokrange*
If you do not explicitly set the |txtfmt-'tokrange'| option, either in a
|txtfmt-modeline| or via the |txtfmtTokrange| option variable, Txtfmt will
attempt to choose a default setting that is suitable for the current character
encoding. Success in this endeavor is not guaranteed, however, since it
involves choosing a range of characters that will not be used for any other
purpose in the file being edited. For Unicode, the task of choosing a suitable
range is simple, due to the existence of the "Private Use Area".

Backward-compatibility Note: Because versions of Vim prior to 7.2 handled
syntax highlighting match offsets incorrectly for multibyte characters,
versions of Txtfmt prior to 1.1 would not choose a tokrange default within the
"Private Use Area", even for Unicode encodings such as utf-8. Txtfmt version
1.1, however, contained a workaround that permitted multibyte tokens to be
used even in versions of Vim suffering from the aforementioned bug. Thus, in
Txtfmt version 1.1, the default start token for Unicode changed from 180 to
0xE000 (the start of the "Private Use Area").

Important Note: If you are a multibyte encoding user who created Txtfmt files
with the old start token value of 180, you should consider the following
(non-exhaustive) list of options...
	1. Continue using 180 for all Txtfmt files.
	   How: Override the new default by setting the |txtfmtTokrange|
	   option explicitly.
        2. Continue using 180 for existing files, but use 0xE000 for all
           newly-created Txtfmt files.
           How: Put a |txtfmt-modeline| containing (e.g.) "tokrange=180X" in
           your existing Txtfmt files to override the new default. 
	3. Use 0xE000 for all Txtfmt files, old and new.
	   How: Use the :MoveStartTok command to relocate the tokens in your
	   existing file(s) to a new range within the "Private Use Area".
	   e.g. >
		   :MoveStartTok 0xE000
<
	   For more information, see |txtfmt-:MoveStartTok|

For encodings other than Unicode, there is nothing analogous to the "Private
Use Area"; hence, it is not possible to choose a default tokrange that will
work for everyone. Currently, Txtfmt's default algorithm chooses '180X' for
all 1 and 2 byte encodings. This value should be suitable for most
non-European users of a single byte encoding such as latin1. European users
who use accented letters located at or above character code 180 should
probably be using a multibyte encoding such as utf-8.

Although the tokrange defaults should be suitable for the vast majority of
users, they may not be suitable for everyone, and each Txtfmt user is
encouraged to put some thought into the tokrange he will use and then test it
thoroughly with :MakeTestPage. For usage details, see |txtfmt-:MakeTestPage|.


COLORS						*txtfmt-color-config*

IMPORTANT NOTE: This section makes no attempt to distinguish between
foreground and background colors. The description of the |txtfmtColor{}| array
applies equally to the|txtfmtBgcolor{}| array, which permits background colors
to be configured independently of their foreground color counterparts.

As mentioned previously, there are 9 tokens used to begin Txtfmt color
regions: 8 corresponding to colors, and 1 indicating "default" or "no color".
By default, Txtfmt picks these colors according to RGB values: #000000
(black), #0000FF (blue), #00FF00 (green), etc... However, this choice may not
be desirable for all users; hence, Txtfmt provides a rather flexible mechanism
by which the user can configure the colors used. In fact, the user can
configure different sets of colors for different color terminals, GUI's, or
colorschemes. The configuration is accomplished via the old-style Vim array
txtfmtColor{1..8}, which may be set either buf-locally or globally. If a given
element has both a buf-local and a global setting, the buf-local setting is
given priority. This array has a static counterpart, initialized to default
values by Txtfmt, so the user can override only those elements he wishes to
change.

Each element of the txtfmtColor{} array corresponds to 1 of the 8 possible
colors. Its value is a string consisting of at least 2 comma-separated parts.
The first part is a Vim regular expression that determines how the color may
be specified in a "color spec". (See |txtfmt-clr-spec| for more information.)
Each of the subsequent parts contains a prefix indicating whether the
definition applies to cterm's or GUI's, an optional list of patterns
specifying the applicable values of 'term', and the actual color string to be
used as the rhs of a "ctermfg=" or "guifg=" in a :highlight command.

Here is the formal definition of a single string in the txtfmtColor{} array:
{namepat},{clrdef1}[,{clrdef2},...,{clrdefN}]

    {clrdef} :=
	    {c|g}[{termpatlist}]:{clrstr}

	    {termpatlist} :=
		    :{termpat1}:{termpat2}:...:{termpatN}

Here are the meanings of the fields:
{namepat}  Vim regex used to recognize the name used to specify a certain
           color; e.g., when prompted by one of the insert token maps. May not
           contain spaces or commas. (Example: 'k\\|bla\\%[ck]')
{c|g}      Determines whether {clrstr} will be the rhs of a "ctermfg=" ('c'),
           or "guifg=" ('g')
{termpat}  Pattern used to match against &term option. It is a regex pattern
           which will be applied as ^{termpat}$.
           Note: The {termpatlist} is optional. If it is omitted, the color
           definition will apply to all cterm's or gui's, as determined by
           {c|g}.
{clrstr}   rhs of a "ctermfg=" or "guifg=" assignment. For possible values,
           see |gui-colors| and |cterm-colors| in the Vim help.

Note: When multiple {clrdef}'s could apply, the rightmost one is used.
Note: {namepat}, {termpat} and {clrstr} fields will have one level of
backslashes removed during processing. Commas, colons and backslashes
appearing within those fields should be preceded with a single backslash. (See
examples below...)

Example txtfmtColor{} elements: >
    'red,c:xterm:dosterm:DarkRed,g:#FF0000,g:builtin_gui:other_gui:#FF1010'
    '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
<

Color defaults					*txtfmt-color-defaults*

The default values for the 8 colors are given below: >
	txtfmtColor{1} = '^\\%(k\\|bla\\%[ck]\\)$,c:Black,g:#000000'
	txtfmtColor{2} = '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
	txtfmtColor{3} = '^g\\%[reen]$,c:DarkGreen,g:#00FF00'
	txtfmtColor{4} = '^t\\%[urquoise]$,c:DarkCyan,g:#00FFFF'
	txtfmtColor{5} = '^r\\%[ed]$,c:DarkRed,g:#FF0000'
	txtfmtColor{6} = '^v\\%[iolet]$,c:DarkMagenta,g:#FF00FF'
	txtfmtColor{7} = '^y\\%[ellow]$,c:DarkYellow,g:#FFFF00'
	txtfmtColor{8} = '^w\\%[hite]$,c:White,g:#FFFFFF'

You may override none, some or all of the defaults. It is even permissible to
override only part of an element; you could, for example, override the
definition of "red" for a "dosterm" color terminal, but use the default red
definition for other cterm's and GUI's.

Colorscheme considerations			*txtfmt-colorschemes*

Although the simplest way to override the default colors is to set the global
version of txtfmtColor{} once and for all in your vimrc, there may be times
when this simple solution is inadequate. Consider the following scenario...
You use Txtfmt to create some blue text in a buffer with a light background.
You later decide you wish to view the Txtfmt buffer with the "blue"
colorscheme. The blue text you created is no longer visible! Of course, you
can make it visible again by redefining the "blue" element in the global
txtfmtColor{} array and re-editing or :Refresh'ing the Txtfmt buffer (see
|txtfmt-:Refresh|), but changing g:txtfmtColor{} everytime you change
colorschemes could become tedious. A better solution is to use autocommands to
change the color definitions automatically whenever the colorscheme changes.
Although you could set the global version of txtfmtColor{} in the autocommand,
setting the buf-local version instead lets you reserve the global version for
defaults that will be used with filetypes for which an autocommand has not
been defined.

For the sake of example, let us assume that you use Txtfmt to edit *.txt
files, and that you wish to vary the color definitions according to current
colorscheme for all such files. To keep the example simple, I will consider
only the following 3 cases:

	1. "default" colorscheme
		Txtfmt defaults are acceptable
	2. "blue" and "darkblue" colorscheme
		Change black to orange
		Change blue to brown
	3. all other colorschemes
		Change black to orange
		Leave blue at the Txtfmt default

The following sample implementation shows one possible strategy for
configuring the Txtfmt colors as described above...
>
	" --INSIDE YOUR USER FILETYPE.VIM--
	augroup filetypedetect
		au! ColorScheme        *.txt    call Define_colors(1)
		au! BufRead,BufNewFile *.txt    call Define_colors(0)
		au  BufRead,BufNewFile *.txt    setfiletype txtfmt
	augroup END
<
-------------------------------
Explanation of the autocommands
-------------------------------
All assignments to the buf-local txtfmtColor{} array occur within the
Define_colors function (shown below). A call to Define_colors has been placed
in a BufRead,BufNewFile autocommand to ensure that colors can be set
appropriately even when :colorscheme has never been called. The call from
within the ColorScheme autocommand ensures that the colors are recomputed
whenever the colorscheme is changed. >
Note: It is not necessary that the ColorScheme autocommand be placed within
the filetypedetect group.
>
	" IN A FILE SOURCED AT STARTUP (E.G., VIMRC)
	" Configure colors in response to colorscheme change or Txtfmt buffer load
	" Note: 'refresh' input will be true if and only if the function is
	" called in response to colorscheme change.
	fu! Define_colors(refresh)
		if !exists('g:colors_name') || g:colors_name == 'default'
			" Use defaults
			let b:txtfmtColor{1} = '^\\%(k\\|bla\\%[ck]\\)$,c:Black,g:#000000'
			let b:txtfmtColor{2} = '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
		elseif g:colors_name == 'blue' || g:colors_name == 'darkblue'
			" Replace black with orange
			let b:txtfmtColor{1} = '^o\\%[range]$,c:Yellow,g:#FF8040'
			" Replace blue with brown
			let b:txtfmtColor{2} = '^b\\%[rown]$,c:Brown,g:#804000'
		else
			" Replace black with orange, but leave blue at Txtfmt
			" default
			let b:txtfmtColor{1} = '^o\\%[range]$,c:Yellow,g:#FF8040'
			let b:txtfmtColor{2} = '^b\\%[lue]$,c:DarkBlue,g:#0000FF'
		endif
		" We shouldn't get here if this isn't a Txtfmt buffer, but check to be
		" safe since :Refresh is defined only for Txtfmt buffers
		if a:refresh && b:current_syntax =~ '\<txtfmt\>'
			" Important: We must reload the Txtfmt plugin because
			" :colorscheme clears the old highlight groups
			:Refresh
		endif
	endfu

------------------------------
Explanation of Define_colors()
------------------------------
In the example, I use g:colors_name (which, if it exists, holds the name of
the currently active colorscheme) to decide which elements of the buf-local
txtfmtColor{} array need to be overridden, and what color values should be
used. It would also be possible to take 'background' into account, but be
aware that not all colorschemes set this option. You can make the color
configuration logic as simple or as complex as you like.
Note: Because Txtfmt processes each element of the txtfmtColor{} array as a
separate entity, it is necessary to set only the elements you wish to change
from the Txtfmt defaults. Of course, if one of the if/else blocks sets a
particular element, the others should set it as well, even if they do not need
to override the default. Alternatively, a block that wishes to use the default
could simply unlet! the corresponding element to ensure that the Txtfmt
default is used.

It is important to note that simply changing the buf-local version of
txtfmtColor{} has no effect on an existing Txtfmt buffer; the Txtfmt plugin
must be reloaded (i.e., "refreshed") before the color changes can take effect.
When Define_colors() is called in response to a BufRead or BufNewFile event,
the required reload happens automatically because of the subsequent
"setfiletype txtfmt". In the case of the ColorScheme event, however, there is
no such automatic reload. To ensure that the user will not need to do anything
special to see the results of changing the colorscheme, I have added the
conditional :Refresh to Define_colors(). The test of the boolean "refresh"
argument ensures that the |txtfmt-:Refresh| command will be invoked only when
the colorscheme is changing and we are within a Txtfmt buffer.

Achieving colorscheme independence		*txtfmt-hl-color-names*

Although the default txtfmtColor{} array uses hard-coded color names, this is
by no means required. An intriguing possibility, which I have implemented on
my own system, is to use color name patterns corresponding to the default Vim
highlighting groups. Under this strategy, instead of naming a particular color
"red", you might instead name it "error". Within the Define_colors() routine
outlined above, you would define the error color according to the
colorscheme-specific guibg/ctermbg definitions used for the Error highlight
group. The advantage of this strategy is that it guarantees that your
Txtfmt files will look good in any colorscheme (assuming they looked good in
the original colorscheme ;-). To facilitate creation of the required color
definitions, I created a Vim script that parses the colorscheme files in
$VIMRUNTIME/colors and extracts the desired definitions for each colorscheme
automatically. I can send a copy of this script, along with instructions for
using it, to anyone who is interested...

COLOR TERMINAL PITFALLS				*txtfmt-cterm-pitfalls*

Cterm default background 		*txtfmt-cterm-default-background*

When you define a highlighting region for a cterm without specifying the
background color with ctermbg, Vim assumes the "default" background color is
desired. The "default" background for a cterm is the default background color
of the terminal itself, unless ctermbg has been overridden in a highlight
statement for the "Normal" group: e.g., >
	:hi Normal ctermbg=15
<
In such cases, the Normal background color replaces the cterm's default
background for all subsequent highlighting. Certain colorschemes (e.g., blue,
darkblue and evening) explicitly set the Normal background color in a cterm.
Others leave it at the default for the color terminal. Ordinarily, Txtfmt can
handle either case, but the following paragraph describes an issue I have
encountered with one particular terminal, seen only when 'term' is set
incorrectly...

Incorrect 'term' setting for gnome-terminal	*txtfmt-cterm-term-issue*
						*txtfmt-gnome-terminal-issue*
The default version of gnome-terminal leaves the TERM environment variable
set to xterm, although the proper setting appears to be gnome-256color.
Unfortunately, the package containing the gnome-256color terminfo description
is not installed by default on some gnome systems. Strangely, even when the
gnome-256color terminfo description is installed, gnome-terminal won't set
TERM to use it. When Vim is started in a gnome-terminal for which TERM=xterm,
the 't_Co' termcap entry is incorrectly set to 8 instead of 256. One of the
effects of this is that outputting certain foreground colors to the cterm will
cause the default background color to revert from the value defined for the
Normal group to the terminal's default. The problem appears to be limited to
the "dark" foreground colors (0-7), which are precisely the colors used in
Txtfmt's default color map. Thus, this issue has the potential to cause
serious display problems for Txtfmt.

				*txtfmt-gnome-terminal-issue-workaround*
There are several ways to resolve this issue. The simplest is to set t_Co=256:
e.g., >
	:set t_Co=256
<
The set of t_Co could go in your vimrc, or anyplace that causes it to be
executed before Txtfmt is loaded. A better solution, in my opinion, is to
ensure that Vim's 'term' option is set to its proper value (i.e.,
gnome-256color), but this is possible only if the corresponding terminfo
description is installed on your system. If the following command... >
	:set term=gnome-256color
<
...generates an error in Vim, you must first install the terminfo description.
On Fedora Linux, the package is named "ncurses-term". (It may have a different
name in other distributions.) Once you have installed the terminfo package,
you should ensure that Vim's 'term' option is set properly. There are at least
2 possible approaches:

1. Set TERM environment variable
   Put the following in one of your shell startup scripts (e.g., .bashrc): >
   export TERM=gnome-256color
<
2. Set 'term' option in your vimrc
   e.g., >
   set term=gnome-256color
<

When "hidden" tokens are not hidden		*txtfmt-cterm-ignore-issue*

Originally, Txtfmt relied exclusively upon the "Ignore" preferred highlighting
group to hide the special formatting tokens. The Ignore group was added in Vim
5.2 to permit markup characters such as the `*' and `|' ("stars and bars")
surrounding tags in a Vim help file to be hidden. It has since come to my
attention, however, that roughly half of the colorschemes distributed with Vim
do not hide text in the Ignore group. In some cases, the contrast between
foreground and background color is minimized; in other cases, there appears to
have been no attempt at all to obscure the text.
Note: It is easy to see how your particular colorscheme treats text in the
Ignore group: simply execute... >
	:hi Ignore
If the Ignore group is defined properly, the "xxx" test pattern should be
invisible.

In some cases, the Txtfmt plugin can take the Ignore group completely out of
the equation, by defining a Txtfmt-specific concealment region that sets the
foreground color equal to the background color. This strategy always works for
the GUI. It works in a cterm if and only if the terminal background color is
known to Vim; i.e., it works when the Normal group's background color has been
set (as described in section |txtfmt-cterm-default-background|). If the Normal
group background is not set, any attempt to use "bg" as a color name in a
highlight command will generate an error: e.g., >
	:hi Tf_conceal ctermfg=bg  " ERROR if Normal ctermbg not set
<
If you are seeing the formatting tokens in your Txtfmt buffer, the plugin was
unable to set ctermfg=bg. In that case, you have several options, as described
below...

					*txtfmt-cterm-ignore-workaround*
1. Redefine the Ignore group:
   First of all, determine the foreground color that most closely matches the
   default background color of your terminal. You can do this by
   experimentation, or by looking at the Ignore group definition of a
   colorscheme that does a better job of hiding Ignore'd text. (The default
   colorscheme would be a good one to check first.) Once you have determined
   the proper color, put it into a :highlight command as follows: >
	:hi Ignore ctermfg=<bg_color>
<
   Of course, you need to ensure that the :highlight command is executed after
   the colorscheme has been sourced. There are several ways this can be
   accomplished... If your colorscheme is sourced in your vimrc, and you never
   change it after that, you could put the :highlight command in your vimrc,
   just after the :colorscheme command. If, however, you sometimes change
   colorschemes after starting Vim, you should avoid this method. Instead, you
   might try one of the following:
 
	1. Put the :highlight command into an autocommand defined for the
	   ColorScheme event: e.g., >
	   :au ColorScheme * hi Ignore ctermfg=<bg_color>
<
	   The autocommand itself could be defined in your vimrc. Note that
	   the ColorScheme event is triggered only after the colorscheme has
	   been loaded. (See |ColorScheme| in the Vim help for more
	   information.)

	2. Create an override of your colorscheme file containing the
	   following two lines: >
	   :source <your_colorscheme_file>
	   :hi Ignore ctermfg=<bg_color>
<
	   The file you create should be placed in a folder that appears
	   earlier in your 'runtimepath' than the folder containing the
	   colorscheme you are overriding.

2. Define a background color for the Normal group:
   This method ensures that Vim knows the terminal background color, which
   enables Txtfmt to define its own highlight group with ctermfg=bg. You can
   set the default background color like so... >
   :hi Normal ctermbg=<desired_color>
<
   Note: Be sure to put the :highlight command in a place where it will be
   executed before Txtfmt is loaded. Any of the methods described above for
   redefining the Ignore group could be used here as well.
   Note: The Normal background color is used for all buffers, not just the
   Txtfmt ones, so you will probably want to choose a color that is close to
   your default background color.
   Note: If you are using a gnome-terminal, read section
   |txtfmt-gnome-terminal-issue| before using this method.

3. Choose a colorscheme that does a better job of hiding the text in the
   Ignore group.
   Note: Because it is not always possible to specify a foreground text color
   that _exactly_ matches a color terminal's default background, only
   colorschemes that explicitly set the Normal background color can guarantee
   that text in the Ignore group will be hidden. However, even when the
   Normal group's background color is not defined, it should usually be
   possible to find a foreground color that comes reasonably close to matching
   the default background.


CUSTOMIZING MAPPINGS				*txtfmt-map-config*

The Txtfmt filetype plugin defines a number of mappings for various modes. By
default, Txtfmt picks consistent and intuitive key sequences for the lhs of
these mappings. It may be, however, that you already use one or more of those
key sequences for an existing map in the same mode. Even if there is no direct
conflict, it is possible that Txtfmt's default mapping would create an
ambiguity with respect to an existing mapping. (For details, see
|map-ambiguous| in the Vim help.) Finally, it may be that you simply do not
like the key sequences chosen by the plugin author. Whatever the case, Txtfmt
provides several ways to customize the map lhs. You can even specify that a
conflicting or ambiguous map should not be defined at all. All of these
customization mechanisms are discussed below...

All but one of the maps defined by the Txtfmt filetype plugin begin with
<LocalLeader>; hence, you may achieve a small amount of customization by
setting the special Vim global variable |maplocalleader| to a non-default
value.

Example: >
	let g:maplocalleader = '_'

Now, when a Txtfmt map such as <LocalLeader>I is defined, the actual {lhs}
will be _I instead of the default \I. Of course, if the conflicting map was
also defined with <LocalLeader>, then this approach will not resolve the
conflict.

A more flexible mechanism for customizing maps involves the <Plug> construct.
If you are unfamiliar with this construct, you may wish to see |using-<Plug>|
in the Vim documentation. All of the mappings provided by the Txtfmt filetype
plugin are defined in a 2 stage process, which permits the default {lhs} to be
completely redefined. To the 2 "stages" in the map definition process
correspond 2 map "levels", henceforth referred to as the 1st and 2nd levels.

The 2nd level map is the one whose {rhs} actually implements the Txtfmt
functionality. The {lhs} of the 2nd level map is a key sequence beginning with
<Plug>, which can never be produced by the keyboard alone. Thus, if the Txtfmt
map functionality is to be usable, there must be a 1st level mapping capable
of producing this untypable key sequence. If Txtfmt sees that the user has
already defined such a map, it will define only the 2nd level map, effectively
allowing the user-defined 1st level map to override the default map sequence.
If, on the other hand, the user has not defined a 1st level map for a
particular map functionality, Txtfmt will define a 1st level map with the
default key sequence listed in this help document.

Some examples using one of the "Jump to token" mappings will be used to
illustrate the concepts presented above...

From the section defining the insert token maps (|txtfmt-ins-tok-map-list|),
we see the following map definition:

    <LocalLeader>i     <Plug>TxtfmtInsertTok_i

The <LocalLeader>i represents the default 1st level map {lhs}, while
<Plug>TxtfmtInsertTok_i is the 2nd level map {lhs}. The following 4 examples
show the 1st level map that results for 4 distinct customization scenarios.

	Scenario: Neither maplocalleader nor 1st level map redefined
	Result: \i  ==> insert token functionality

	Scenario: maplocalleader redefined as follows: >
	let maplocalleader = '_'
<	Result: _i  ==> insert token functionality

	Scenario: 1st level map redefined as follows in user's vimrc (or
	something sourced prior to Txtfmt load): >
	nmap _it <Plug>TxtfmtInsertTok_i
<	Result: _it ==> insert token functionality
	                (\i map not created)

	Scenario: Both maplocalleader and 1st level map redefined: >
	let maplocalleader = '_'
	nmap <LocalLeader>it <Plug>TxtfmtInsertTok_i
<	Result: _it ==> insert token functionality
	                (\i map not created)


Handling map conflicts and ambiguities		*txtfmt-map-conflict*

The mechanisms described above permit the Txtfmt user to eliminate map
conflicts and ambiguities once they become known. Of course, when you first
begin using the Txtfmt plugin, you will probably not be aware of the
conflicts. By default, Txtfmt will overwrite any existing mappings with its
own 1st level maps; moreover, to ensure that you have the opportunity to
resolve the conflict, Txtfmt gives one warning per Vim session for each
conflict or ambiguity it detects. The default behavior just described may be
tailored with global option |txtfmtMapwarn|. With this option, you can specify
any or all of the following:

	-whether echomsg or echoerr is used for warnings
	-whether the same map conflict/ambiguity will produce a warning every
	 time the plugin is sourced, or only once per Vim session
	-whether a Txtfmt map will be created when a conflicting/ambiguous map
	 exists

The |txtfmtMapwarn| option may be set to a string of the following character
flags: "mMeEoOcC". The flags may appear in any combination and in any order.
Lowercase flags affect the handling of map ambiguities, while uppercase flags
pertain to map conflicts. The meaning of the flags is as follows:

	m	Use :echomsg to warn about map ambiguities
	M	Use :echomsg to warn about map conflicts
	e	Use :echoerr to warn about map ambiguities
	E	Use :echoerr to warn about map conflicts
	o	Warn of a particular map ambiguity only once per Vim session 
	O	Warn of a particular map conflict only once per Vim session 
	c	Create the Txtfmt map in case of map ambiguity
	C	Create the Txtfmt map in case of map conflict

The "once-only" flag: The intent of the o and O flags is to prevent the user
from being bombarded with the same conflict warning every time he loads a
Txtfmt buffer. To determine whether a map conflict or ambiguity is identical
to one for which the user has already been warned, Txtfmt employs the concept
of a "conflict instance". A conflict instance is defined by a unique
combination of the following:

	-map mode
	-{lhs} of the Txtfmt map
	-{rhs} of the existing map

Note: If mutually exclusive flags are used, Txtfmt will give precedence to the
flag appearing later in the string. If a flag is used without another flag
required to give it meaning, the useless flag is simply ignored. Txtfmt will
not generate an error unless invalid flags are used.

==============================================================================
6. User interface				*txtfmt-user-interface*

INSERTING TOKENS				*txtfmt-ins-tok*

Whenever you wish to alter the formatting or coloring of text in a Txtfmt
buffer, you must insert the appropriate Txtfmt token or tokens. A single
format token is sufficient to determine any combination of format attributes,
just as a single color token is sufficient to determine any of the 8 possible
foreground or background colors. Thus, as a general rule, a Txtfmt buffer will
not contain sequences of more than 3 consecutive Txtfmt tokens. There are,
however, times when it makes sense to insert more than 3 Txtfmt tokens at
once; when you know, for example, that the region you are creating will be
terminated by an explicit "no format" and/or "no color" token, you may wish to
insert both the region opening and closing tokens with a single insert
mapping, which leaves the cursor positioned just after the opening tokens
where the region text will go. Details on the various mappings are provided
below in the section on |txtfmt-ins-tok-map-list|. Before you attempt to use
those mappings, however, you should be familiar with the concept of
format/color specifications. Each of the token insertion mappings prompts you
to enter a list of such specifications, which it then translates into a
sequence of tokens to be inserted into the buffer. The following sections
describe these specifications and the lists comprising them in detail.

Fmt spec					*txtfmt-fmt-spec*

A format specification specifies a unique combination of valid format
attributes. The set of "valid" format attributes is determined by the
|txtfmt-'tokrange'| option (in particular, by the tokrange suffix) as well as
by the version of Vim you are using.

The format of a single format specification is given as follows:

    f{fmts}

where {fmts} is a string consisting of either a single dash ('-') indicating
"no format attributes", or a sequence of letters from the set "ubisrc", in
which each letter represents a format attribute that should be applied to the
region. The letter/attribute correspondences are shown in the table below.
Also shown are the |txtfmt-'tokrange'| suffix and version of Vim required to
enable the format attribute.

    ====================================================
    | ltr | attribute         |  tokrange  | v:version |
    |     |                   |   suffix   |           |
    ====================================================
    |  u  | underline         |   S or X   |    any    |
    |  b  | bold              |   S or X   |    any    |
    |  i  | italic            |   S or X   |    any    |
    |  s  | standout          |     L      |    any    |
    |  r  | reverse (inverse) |     L      |    any    |
    |  c  | undercurl         |     L      |   >= 700  |
    ====================================================

    Note: {fmts} may contain any combination of valid format specification
    letters in any order.

Clr spec					*txtfmt-clr-spec*

A color specification specifies a single color from among up to 8
possibilities in the active color definition.

The format of a single color specification is given as follows:

    {typ}{clr}

{typ} is either
	'c' => foreground color
	'k' => background color
{clr} is either a single dash ('-') indicating "no color" (i.e., default
color), or a string matching the {namepat} corresponding to one of the 8
possible colors. As discussed in the section |txtfmt-color-config|, {namepat}
is simply a Vim regular expression used to recognize a (possibly abbreviated)
color name. The default color definitions use Vim's \%[] contruct with
intuitive color names (e.g.  "red", "green", "blue") so that you can usually
specify a color by the first letter of its name.

Example: >
	{namepat}     valid {clr} values
	===================================
	b\%[lue]$     "b" "bl" "blu" "blue"
	r\%[ed]$      "r" "re" "red"

Of course, if you override the default color definition array, you are free to
define whatever colors and corresponding {namepat}'s you like. See
|txtfmt-color-config| for details.


Fmt/clr spec list				*txtfmt-fmt-clr-spec-list*

Since most mappings and functions for working with fmt/clr tokens permit
multiple tokens to be inserted simultaneously, Txtfmt permits the format/color
specifications described in the preceding two sections to be concatenated into
comma or dot-separated lists. The resulting "format/color specification lists"
are the topic of this section.

Format/color specification lists may contain any number of fmt-spec and
clr-spec "atoms", freely intermixed and in any order. Internally, Txtfmt will
translate the list of fmt/clr atoms into a sequence of character codes
representing the corresponding fmt/clr tokens. By default, Txtfmt's token
insertion mappings leave the cursor after the final token inserted; you can
alter this behavior, however, by replacing one of the commas separating the
individual fmt/clr specs with a dot ('.') to indicate the desired cursor
position.
Note: Although commas are used only to separate items in the list, a dot may
be placed at the beginning of the list to indicate that the cursor should end
up before any of the inserted tokens.

Here are a few example fmt/clr spec lists:
	Note: The following examples assume the default color definitions
        listed in |txtfmt-color-defaults|.

	kb
	Result: Blue background region is begun (but not terminated). Cursor
	is positioned after the inserted token.

	fu,cr
	Result: Red underline region is begun (but not terminated). Cursor is
	positioned after the inserted tokens.

	fbi,cg,kr.k-,c-,f-	       
	Result: Green bold,italic on red background region is begun (and
	simultaneously terminated). Cursor is left just inside the region.

	.f-,c-
	Result: Inserts the "no format" and "no color" tokens, but leaves
	cursor positioned within the combined fmt/clr region being terminated.

	fubisrc
	Result: Underline,bold,italic,standout,reverse,undercurl region is
	begun. Cursor is positioned after the inserted token.

Mapping overview				*txtfmt-ins-tok-maps*

The Txtfmt filetype plugin provides a number of mappings that may be used to
insert the special tokens used to delineate the Txtfmt format/color regions.
All of the token insertion mappings prompt the user to enter a special comma
or dot-separated list, known as a fmt/clr spec list, which completely
describes the sequence of tokens that should be inserted. Details on the
format of this list may be found in section |txtfmt-fmt-clr-spec-list|.

There are actually 15 separate mappings that may be used to insert Txtfmt
tokens: 1 may be used only in insert mode; the other 14 are used only in
normal mode. The main reason there are so many normal mode mappings is that
Vim provides many ways to go from normal mode to insert mode, each of which
may be more suitable than the others in a given context. Suppose, for example,
that you are in normal mode and you wish to insert the "no format" token at
the end of the current line. You might consider jumping to the end of the line
with $, then invoking a Txtfmt normal mode mapping to insert the token. If,
for the sake of example, Txtfmt provided only one normal mode mapping, which
inserted tokens before the cursor position, you would have a problem. The
token would be inserted prior to the last character on the line, when in fact,
it needed to go after the last character on the line. In this case, you could
circumvent the difficulty by hitting A in normal mode (instead of $) and using
the Txtfmt insert mode mapping to insert the desired token, but this would
require separate operations for entering and exiting insert mode. What would
be preferable here is a Txtfmt normal mode mapping that functions in a manner
analogous to Vim's normal mode 'A' command for entering insert mode.

Of course, we could construct other examples, which call for mappings that
insert tokens at the beginning of a line (analogous to Vim's normal mode 'I'
command), or mappings that replace the N characters under the cursor with the
tokens inserted (analogous to Vim's normal mode 's' command), and so on... By
the same token, there may be times when you wish to remain in insert mode
after the tokens have been inserted, and times when you wish simply to insert
the tokens and return to normal mode. The Txtfmt insert-token mappings listed
below provide you with all of those capabilities and more.

Although the number of normal mode mappings may appear large at first glance,
their default key sequences are intuitive, once you understand that they all
are constructed according to the following pattern:

	<LocalLeader>[{end-in-normal}]{vim-enterinsert-char}

where {vim-enterinsert-char} is one of Vim's single-letter normal mode
commands for entering insert mode: >
	i, I, a, A, o, O, s
and the optional {end-in-normal} is the letter 'v', which is simply a flag
indicating that you wish to return to normal mode after the insertion.

There is only one insert mode mapping. Its default map sequence was selected
because it is (in the author's opinion, at least) fairly easy to type, and not
something you are otherwise likely to type in insert mode.

All 15 of the insert-token mappings are listed below, with similar ones
grouped together to avoid repetition. For each mapping, 2 forms are shown:
	1. The default map sequence
	2. The <Plug> form, used only for customization
For details on customizing maps, refer to section |txtfmt-map-config|.

Mapping list					*txtfmt-ins-tok-map-list*

<LocalLeader>i	   <Plug>TxtfmtInsertTok_i	*\i* *txtfmt-ins-tok-i*
<LocalLeader>I	   <Plug>TxtfmtInsertTok_I	*\I* *txtfmt-ins-tok-I*
<LocalLeader>a	   <Plug>TxtfmtInsertTok_a	*\a* *txtfmt-ins-tok-a*
<LocalLeader>A	   <Plug>TxtfmtInsertTok_A	*\A* *txtfmt-ins-tok-A*
<LocalLeader>o	   <Plug>TxtfmtInsertTok_o	*\o* *txtfmt-ins-tok-o*
<LocalLeader>O	   <Plug>TxtfmtInsertTok_O	*\O* *txtfmt-ins-tok-O*
<LocalLeader>s	   <Plug>TxtfmtInsertTok_s	*\s* *txtfmt-ins-tok-s*

Available in normal mode only. Insert a sequence of Txtfmt tokens in the
current buffer and remain in insert mode. The various mappings differ only in
how they enter insert mode. Conceptually, they all do the following:

	-Prompt user to enter a |txtfmt-fmt-clr-spec-list| at the command line
	-Translate the entered text into a Txtfmt token sequence
	-Enter insert mode via the {vim-enterinsert-char} specified in the
	 default map sequence.
	-Insert the token sequence (with <C-R><C-R>=)
	-Perform any cursor adjustment requested by the presence of a dot
	 ('.') in the |txtfmt-fmt-clr-spec-list|.
	-Remain in insert mode.

<LocalLeader>vi    <Plug>TxtfmtInsertTok_vi	*\vi* *txtfmt-ins-tok-vi*
<LocalLeader>vI    <Plug>TxtfmtInsertTok_vI	*\vI* *txtfmt-ins-tok-vI*
<LocalLeader>va    <Plug>TxtfmtInsertTok_va	*\va* *txtfmt-ins-tok-va*
<LocalLeader>vA    <Plug>TxtfmtInsertTok_vA	*\vA* *txtfmt-ins-tok-vA*
<LocalLeader>vo    <Plug>TxtfmtInsertTok_vo	*\vo* *txtfmt-ins-tok-vo*
<LocalLeader>vO    <Plug>TxtfmtInsertTok_vO	*\vO* *txtfmt-ins-tok-vO*
<LocalLeader>vs    <Plug>TxtfmtInsertTok_vs	*\vs* *txtfmt-ins-tok-vs*

Available in normal mode only. Insert a sequence of Txtfmt tokens in the
current buffer and return to normal mode. The various mappings differ only in
how they enter insert mode. Conceptually, they all do the following:

	-Prompt user to enter a |txtfmt-fmt-clr-spec-list| at the command line
	-Translate the entered text into a Txtfmt token sequence
	-Enter insert mode via the {vim-enterinsert-char} specified in the
	 default map sequence.
	-Insert the token sequence (with <C-R><C-R>=)
	-Perform any cursor adjustment requested by the presence of a dot
	 ('.') in the |txtfmt-fmt-clr-spec-list|.
	-Exit insert mode.

						*<C-\><C-\>*
<C-\><C-\>	<Plug>TxtfmtInsertTok_i		*txtfmt-ins-tok-CTRL-\_CTRL-\*

Available in insert mode only. Insert a sequence of Txtfmt tokens in the
current buffer and remain in insert mode. The mapping works like this:

	-Prompt user to enter a |txtfmt-fmt-clr-spec-list| at the command line
	-Translate the entered text into a Txtfmt token sequence
	-Insert the token sequence (with <C-R><C-R>=)
	-Perform any cursor adjustment requested by the presence of a dot
	('.') in the |txtfmt-fmt-clr-spec-list|.
	-Remain in insert mode.

IMPORTANT NOTE: Txtfmt will generate an error if |txtfmt-fmt-clr-spec-list|
specifies any colors that are inactive under the effective color masks. See
|txtfmtFgcolormask| or |txtfmtBgcolormask| for details on configuring color
masks.

JUMPING TO TOKENS				*txtfmt-jump-to-tok*

The Txtfmt syntax plugin conceals the special tokens delineating the
format/color regions. Normally, you will see such tokens only in 3 cases:
	1. when a region containing them is visually selected
	2. when the token is serving no purpose in the buffer
	   Rationale: When a default ("no format" or "no color") token,
	   normally used to terminate a region, appears where there is no
	   region to terminate, Txtfmt intentionally leaves the token visible
	   so that you might notice and remove it.
	3. when a fg or bg color token is disabled by |txtfmtFgcolormask| or
	  |txtfmtBgcolormask|

Although this behavior is generally what you want, it can make it difficult to
locate tokens after you have inserted them. There are many reasons why you
might wish to locate a concealed token: to remove it, to change it to a
different token, to insert another token immediately before or after it,
etc... To simplify the task of locating such tokens, Txtfmt provides various
mappings for jumping to them. These "jump to token" commands are analogous to
various Vim motion commands: e.g., [{, ]}, f, F, t, T, etc...

There are exactly 48 such mappings, but their default map sequences are
constructed according to a pattern, which renders memorization of the
individual mappings unnecessary. (The desired mapping can be easily deduced
according to the pattern.)

	{direction}[{till-flag}][{target-modifier}]{target}

The definitions of the fields in the pattern given above are as follows:
	{direction}
		[ (search backwards)
		] (search forwards)
	{till-flag}
		Optional flag consisting of the letter 't'. If present,
		indicates that the sought position is 1 character position
		closer to the starting point of the jump than it would have
		been without the {till-flag}. Behavior is analogous to that of
		Vim's normal mode T operator; i.e., jump is "till" the target
		location.
	{target-modifier}
		b (begin region tokens)
		e (end region tokens)
		Note: While there are a number of tokens that can begin a
		format or color region, each of the 3 orthogonal region types
		has only one "end region" token: the one specified by a dash
		(`-') in the |txtfmt-fmt-spec| or |txtfmt-clr-spec|.
	{target}
		f (format tokens)
		c (fg color tokens)
		k (bg color tokens)
		a (any format or fg/bg color token)

	Examples: >
		]f      Jump forward to next token that begins or ends a
		        format region
		]ef     Jump forward to next "end format region" token
		[tbc    Jump backward "till" previous "begin fg color region"
		        token


All of the jump-to-token mappings are defined for normal, visual, and
operator-pending modes, and all can take a count, which causes them to jump to
the [count] token of the specified type in the specified direction. Whether
the search for tokens wraps around the start or end of the buffer is
determined by the 'wrapscan' option.

SPECIAL NOTE ON VISUAL MODE
    The visual-mode maps correctly extend the visual selection for linewise,
    characterwise and blockwise selections.

SPECIAL NOTE ON OPERATOR-PENDING MODE
    By default, when used with an operator such as 'd', 'c' or 'y', a
    jump-to-token map behaves in an "exclusive" manner; i.e., the character
    landed upon is not deleted, changed or yanked. If you wish to make these
    motions work more like the builtin 'f', 't', 'F' and 'T' commands, simply
    hit 'v' between the operator and the jump-to-token map. (For details, see
    |o_v| in the Vim help.)

All 48 of the jump-to-token mappings are listed below. For each mapping, 2
forms are shown:
	1. The default map sequence
	2. The <Plug> form, used only for customization
For details on customizing maps, refer to section |txtfmt-map-config|.

Mappings					*txtfmt-jump-to-tok-maps*

[f	<Plug>TxtfmtBckToFmtTok			*[f*	*txtfmt-bck-to-fmt-tok*
	Jump to [count] previous format begin/end region token
]f	<Plug>TxtfmtFwdToFmtTok			*]f*	*txtfmt-fwd-to-fmt-tok*
	Jump to [count] next format begin/end region token
[c	<Plug>TxtfmtBckToClrTok			*[c*	*txtfmt-bck-to-clr-tok*
	Jump to [count] previous fg color begin/end region token
]c	<Plug>TxtfmtFwdToClrTok			*]c*	*txtfmt-fwd-to-clr-tok*
	Jump to [count] next fg color begin/end region token
[k	<Plug>TxtfmtBckToBgcTok			*[k*	*txtfmt-bck-to-bgc-tok*
	Jump to [count] previous bg color begin/end region token
]k	<Plug>TxtfmtFwdToBgcTok			*]k*	*txtfmt-fwd-to-bgc-tok*
	Jump to [count] next bg color begin/end region token
[a	<Plug>TxtfmtBckToAnyTok			*[a*	*txtfmt-bck-to-any-tok*
	Jump to [count] previous format/color begin/end region token
]a	<Plug>TxtfmtFwdToAnyTok			*]a*	*txtfmt-fwd-to-any-tok*
	Jump to [count] next format/color begin/end region token

[bf	<Plug>TxtfmtBckToFmtBegTok		*[bf*	*txtfmt-bck-to-fmt-beg-tok*
	Jump to [count] previous format begin region token
]bf	<Plug>TxtfmtFwdToFmtBegTok		*]bf*	*txtfmt-fwd-to-fmt-beg-tok*
	Jump to [count] next format begin region token
[bc	<Plug>TxtfmtBckToClrBegTok		*[bc*	*txtfmt-bck-to-clr-beg-tok*
	Jump to [count] previous fg color begin region token
]bc	<Plug>TxtfmtFwdToClrBegTok		*]bc*	*txtfmt-fwd-to-clr-beg-tok*
	Jump to [count] next fg color begin region token
[bk	<Plug>TxtfmtBckToBgcBegTok		*[bk*	*txtfmt-bck-to-bgc-beg-tok*
	Jump to [count] previous bg color begin region token
]bk	<Plug>TxtfmtFwdToBgcBegTok		*]bk*	*txtfmt-fwd-to-bgc-beg-tok*
	Jump to [count] next bg color begin region token
[ba	<Plug>TxtfmtBckToAnyBegTok		*[ba*	*txtfmt-bck-to-any-beg-tok*
	Jump to [count] previous format/color begin region token
]ba	<Plug>TxtfmtFwdToAnyBegTok		*]ba*	*txtfmt-fwd-to-any-beg-tok*
	Jump to [count] next format/color begin region token

[ef	<Plug>TxtfmtBckToFmtEndTok		*[ef*	*txtfmt-bck-to-fmt-end-tok*
	Jump to [count] previous format end region token
]ef	<Plug>TxtfmtFwdToFmtEndTok		*]ef*	*txtfmt-fwd-to-fmt-end-tok*
	Jump to [count] next format end region token
[ec	<Plug>TxtfmtBckToClrEndTok		*[ec*	*txtfmt-bck-to-clr-end-tok*
	Jump to [count] previous fg color end region token
]ec	<Plug>TxtfmtFwdToClrEndTok		*]ec*	*txtfmt-fwd-to-clr-end-tok*
	Jump to [count] next fg color end region token
[ek	<Plug>TxtfmtBckToBgcEndTok		*[ek*	*txtfmt-bck-to-bgc-end-tok*
	Jump to [count] previous bg color end region token
]ek	<Plug>TxtfmtFwdToBgcEndTok		*]ek*	*txtfmt-fwd-to-bgc-end-tok*
	Jump to [count] next bg color end region token
[ea	<Plug>TxtfmtBckToAnyEndTok		*[ea*	*txtfmt-bck-to-any-end-tok*
	Jump to [count] previous format/color end region token
]ea	<Plug>TxtfmtFwdToAnyEndTok		*]ea*	*txtfmt-fwd-to-any-end-tok*
	Jump to [count] next format/color end region token

[tf	<Plug>TxtfmtBckTillFmtTok		*[tf*	*txtfmt-bck-till-fmt-tok*
	Jump "till" [count] previous format begin/end region token
]tf	<Plug>TxtfmtFwdTillFmtTok		*]tf*	*txtfmt-fwd-till-fmt-tok*
	Jump "till" [count] next format begin/end region token
[tc	<Plug>TxtfmtBckTillClrTok		*[tc*	*txtfmt-bck-till-clr-tok*
	Jump "till" [count] previous fg color begin/end region token
]tc	<Plug>TxtfmtFwdTillClrTok		*]tc*	*txtfmt-fwd-till-clr-tok*
	Jump "till" [count] next fg color begin/end region token
[tk	<Plug>TxtfmtBckTillBgcTok		*[tk*	*txtfmt-bck-till-bgc-tok*
	Jump "till" [count] previous bg color begin/end region token
]tk	<Plug>TxtfmtFwdTillBgcTok		*]tk*	*txtfmt-fwd-till-bgc-tok*
	Jump "till" [count] next bg color begin/end region token
[ta	<Plug>TxtfmtBckTillAnyTok		*[ta*	*txtfmt-bck-till-any-tok*
	Jump "till" [count] previous format/color begin/end region token
]ta	<Plug>TxtfmtFwdTillAnyTok		*]ta*	*txtfmt-fwd-till-any-tok*
	Jump "till" [count] next format/color begin/end region token

[tbf	<Plug>TxtfmtBckTillFmtBegTok		*[tbf*	*txtfmt-bck-till-fmt-beg-tok*
	Jump "till" [count] previous format begin region token
]tbf	<Plug>TxtfmtFwdTillFmtBegTok		*]tbf*	*txtfmt-fwd-till-fmt-beg-tok*
	Jump "till" [count] next format begin region token
[tbc	<Plug>TxtfmtBckTillClrBegTok		*[tbc*	*txtfmt-bck-till-clr-beg-tok*
	Jump "till" [count] previous fg color begin region token
]tbc	<Plug>TxtfmtFwdTillClrBegTok		*]tbc*	*txtfmt-fwd-till-clr-beg-tok*
	Jump "till" [count] next fg color begin region token
[tbk	<Plug>TxtfmtBckTillBgcBegTok		*[tbk*	*txtfmt-bck-till-bgc-beg-tok*
	Jump "till" [count] previous bg color begin region token
]tbk	<Plug>TxtfmtFwdTillBgcBegTok		*]tbk*	*txtfmt-fwd-till-bgc-beg-tok*
	Jump "till" [count] next bg color begin region token
[tba	<Plug>TxtfmtBckTillAnyBegTok		*[tba*	*txtfmt-bck-till-any-beg-tok*
	Jump "till" [count] previous format/color begin region token
]tba	<Plug>TxtfmtFwdTillAnyBegTok		*]tba*	*txtfmt-fwd-till-any-beg-tok*
	Jump "till" [count] next format/color begin region token

[tef	<Plug>TxtfmtBckTillFmtEndTok		*[tef*	*txtfmt-bck-till-fmt-end-tok*
	Jump "till" [count] previous format end region token
]tef	<Plug>TxtfmtFwdTillFmtEndTok		*]tef*	*txtfmt-fwd-till-fmt-end-tok*
	Jump "till" [count] next format end region token
[tec	<Plug>TxtfmtBckTillClrEndTok		*[tec*	*txtfmt-bck-till-clr-end-tok*
	Jump "till" [count] previous fg color end region token
]tec	<Plug>TxtfmtFwdTillClrEndTok		*]tec*	*txtfmt-fwd-till-clr-end-tok*
	Jump "till" [count] next fg color end region token
[tek	<Plug>TxtfmtBckTillBgcEndTok		*[tek*	*txtfmt-bck-till-bgc-end-tok*
	Jump "till" [count] previous bg color end region token
]tek	<Plug>TxtfmtFwdTillBgcEndTok		*]tek*	*txtfmt-fwd-till-bgc-end-tok*
	Jump "till" [count] next bg color end region token
[tea	<Plug>TxtfmtBckTillAnyEndTok		*[tea*	*txtfmt-bck-till-any-end-tok*
	Jump "till" [count] previous format/color end region token
]tea	<Plug>TxtfmtFwdTillAnyEndTok		*]tea*	*txtfmt-fwd-till-any-end-tok*
	Jump "till" [count] next format/color end region token


BUILDING COMPLEX MAPPINGS FROM PRIMITIVES	*txtfmt-user-maps*

The insert-token maps discussed in a preceding section permit the insertion of
a single sequence of fmt/clr tokens at a fixed location relative to the cursor
position. A common scenario, however, is one in which you wish to perform
multiple insertions, possibly interspersed with cursor movements and other Vim
commands. Suppose, for example, that you often find yourself highlighting an
entire line in bold,italic, and then using :ce to center the text on the line.
You could accomplish this using only Vim commands and insert-token maps as
follows: >

	Hit \vI and enter fmt spec "fbi" at the prompt
	Hit \vA and enter fmt spec "f-" at the prompt
	Execute :ce[nter] at the command-line

While this approach works, it could become tedious if you do it often. A
better approach would be to create a single mapping that executes the entire
sequence of steps shown above. To facilitate creation of such maps, Txtfmt
provides a mechanism known as "user-maps". User-map creation is requested
through the "old-style" Vim array |txtfmtUsermap{}|. The first element of the
array is txtfmtUsermap{1} and the last element is txtfmtUsermap{N}, where N is
determined from option variable |txtfmtUsermaplimit|. It is not necessary to
set every element between indices 1 and N. You may define as many or as few
maps within that range as you like. Only the elements that have been set will
cause a map to be created. Moreover, both |txtfmtUsermap{}| and
|txtfmtUsermaplimit| may be set either globally or buffer-locally. As a
general rule, the global elements define mappings that should be available in
any type of file, whereas buffer-local elements would define more specialized
maps: e.g. maps that are used only when using Txtfmt within C comments in
buffers whose filetype is set to "c.txtfmt". For a more detailed look at
possible usage scenarios involving buf-local assignment to |txtfmtUsermap{}|
elements, see |txtfmt-buflocal-user-map|.

txtfmtUsermap{} element format			*txtfmt-user-map-fmt*

Each element of the |txtfmtUsermap{}| array is a string, which specifies a
single normal or insert mode map to be created in the Txtfmt buffer. The
format of the string is as follows:

	"{map-cmd} {map-lhs} {map-rhs}"

The descriptions of the fields in braces are as follows:

    {map-cmd}
	The map creation command used by Txtfmt to create the mapping.
	Currently, the following commands are supported:
	    imap, inoremap, nmap, nnoremap
    {map-lhs}
	Everything following {map-cmd} up to the first whitespace character
	that is not preceded by a literal CTRL-V represents the {lhs} of the
	mapping to be created.
    {map-rhs}
	The remainder of the string represents the {rhs} of the mapping to be
	created. May contain special user-map expansion macros within <<...>>
	requesting Txtfmt "insert-token" or "jump-to-token" functionality.
	(See section |txtfmt-user-map-expansion| below.)

MAP-LHS DETAILS
Note that {map-lhs} should appear exactly as it would if the mapping were
being created without the aid of Txtfmt; i.e., just as it would if you were
creating the map with an :exe[cute] on the |txtfmtUsermap{}| string. This
means, for example, that whitespace may be included in the {lhs} if it is
escaped by a literal CTRL-V, and that the special key notation sequences (e.g.
<Up>, <Down>, <Bslash>, etc...) may be used in place of the corresponding key
codes. For more details, read the following sections in the Vim documentation:
	|:map-special-keys|
	|:map-special-chars|

MAP-RHS DETAILS
Vim's normal map processing rules apply to {map-rhs} as well; however, Txtfmt
performs a special pre-processing step on {map-rhs} before it is used to
define the map; in particular, it scans for and processes the special Txtfmt
expansion macros (enclosed in <<...>>), which are the subject of the following
section. To include a literal `<' in {map-rhs}, use the special <lt> notation
discussed in the Vim help for commands and mappings and documented in the
|key-notation| table.

Example: >
	<lt><lt>EOF
	produces a mapping that looks like
	<<EOF

Note: If necessary, you may use the special symbol <rt> to get a literal `>'
into {map-rhs}. The <rt> symbol is special only within a Txtfmt user-map
expansion macro. (Although it is unlikely you would ever need to include a
literal `>>' within an expansion macro, use of non-alphanumeric characters as
part of a color name is currently not prohibited.)

Example: >
	<<n\i:cstrange<rt><rt>color<rt><rt>name>>
	inserts token for fg color whose user-defined pattern matches
	"strange>>color>>name"

User-map expansion macros			*txtfmt-user-map-expansion*

When Txtfmt encounters `<<' in {map-rhs}, it attempts to process a user-map
expansion macro. To facilitate the addition of user-map macros in future
versions of txtfmt, the following template has been devised:

	<<{mode}{cmd}[{cmd-modifiers}][:{cmd-parameters}]>>

The descriptions of the fields in braces are as follows:

	{mode}			Single character representing the expected
				mode at the instant the `<<' is encountered.
				    i = insert
				    n = normal
				    o = operator-pending
				    v = visual
				Note: The mode flag may specify a mode
				different from the mode indicated by {map-cmd}
				(discussed in the previous section). Consider
				that a single normal or insert mode mapping
				may cause multiple modes to be entered and
				exited as the rhs of the mapping is traversed.
				This flag specifies the "instantaneous" mode.
	[{count}]		Optional count to be applied to {cmd}.
				Note: Not all expansion macros accept a count.
				See command-specific documentation below to
				determine which ones do.
	{cmd}			A character or characters indicating the
				Txtfmt functionality that is required.
				Currently, all {cmd}'s are indicated by a
				special character, which, in most cases,
				corresponds to the first character of the
				associated default map:
				\		Insert-token
				`[' or `]'	Jump-to-token
	[{cmd-modifiers}]	Optional data modifying the behavior of the
				{cmd} in some way. (See command-specific
				documentation below.)
	[{cmd-parameters}]	Permits data that would normally be entered at
				a prompt at the time of map execution to be
				specified in advance (i.e. at the time of map
				creation).

The specific forms of user-map macro are shown below, grouped according to the
Txtfmt functionality involved.

INSERT TOKEN MACROS
    <<i\:{fmt-clr-spec-list}>>
    <<n[{count}]\[{end-in-normal}]{vim-enterinsert-char}:{fmt-clr-spec-list}>>

Both forms of "insert-token" macro contain a |fmt-clr-spec-list|, describing
the sequence of fmt/clr tokens to be inserted and optionally specifying a
cursor offset with a single dot somewhere in the otherwise comma-separated
list. The first form is used when the instantaneous mode within {map-rhs} is
"insert", whereas the more complicated second form is needed when the
instantaneous mode is "normal". (See earlier description of {mode} flag.)

There are 3 additional parameters that apply only to the normal mode form of
the insert-token expansion sequence:

    {count} is an optional value, specifying the count to be applied to the
    enter-insert command. Specifying a count in this manner is analogous to
    typing a count prior to executing the corresponding insert-token map in
    normal mode.

    {vim-enterinsert-char} is one of Vim's single-letter normal mode commands
    for entering insert mode: >
	i, I, a, A, o, O, s
<   Proper choice of enter-insert command can simplify the mapping by
    minimizing the number of movement commands required to position the cursor
    prior to token insertion.

    {end-in-normal} is the letter 'v', which, when present, serves as a flag
    indicating that you wish to return to normal mode after the insertion. The
    flag is provided as a convenience to minimize the number of "<Esc>"
    characters that need to be embedded in {map-rhs}.

Examples: >
	<<i\:c->>	Starting in insert mode, insert "no fg color" token at
			cursor location.
	<<n\I:fbi>>	Starting in normal mode, insert "bold,italic" token at
			beginning of line. Ends in insert mode.
	<<n5\vs:fu>>	Starting in normal mode, 'substitute' the next 5
			characters with a single "underline" token. Ends in
			normal mode.

JUMP TO TOKEN MACROS

    <<{mode}[{count}]{default-jump-to-tok-map}>>

A jump-to-token macro is created simply by prepending the {mode} flag and the
optional {count} to the default mapping representing the desired jump, and
enclosing the whole string within `<<' and `>>'. For a detailed discussion of
the various forms of jump-to-token mappings and a listing of the default
mappings, see |txtfmt-jump-to-tok| and |txtfmt-jump-to-tok-maps|.

Examples: >
	<<n]k>>		Jump forward to next bg color region token
	<<n[ec>>	Jump backward to previous "end fg color region" token
	<<n3]tbf>>	Jump forward "till" 3rd "begin format region" token

User-map examples				*txtfmt-user-map-examples*

The following concrete examples should help to clarify the use of the various
forms of user-map expansion sequence. You should be able to copy any that
appear useful to your .vimrc.


	" Map CTRL-B in insert mode to start and terminate a 'bold' region,
	" leaving the cursor positioned within the region, ready to type bold
	" text.
	" Hint: Similar maps might be created for underline and italic >
	let g:txtfmtUsermap1 = 'inoremap <C-B> <<i\:fb.f->>'
<
	" Map CTRL-\f in insert mode to end current format region. >
	let g:txtfmtUsermap2 = 'inoremap <C-\>f <<i\:f->>'
<
	" Map CTRL-\k in insert mode to end current bg color region. >
	let g:txtfmtUsermap3 = 'inoremap <C-\>k <<i\:k->>'
<
	" Map \t in normal mode to embolden, underline and center (i.e.
	" 'title-ize') the current line >
	let g:txtfmtUsermap4 =
	    \'nnoremap <Bslash>t <<n\vI:fbu>><<n\vA:f->>:ce<CR>'
<
	" Map \cf in normal mode to change all text within the current format
	" region (without deleting the tokens that begin and end the region).
	" Note: Since the default jump-to-token mappings are used in the rhs
	" (rather than the special expansion macros), nmap must be used (rather
	" than nnoremap).
	" Note: The reason the ]f does not cause the format 'end region' token to
	" be deleted is that the operator-pending jump-to-token maps work
	" 'exclusive-ly' when there is no 'v' between operator and motion.
	"     :help exclusive >
	let g:txtfmtUsermap5 = 'nmap <Bslash>cf [tbfc]f'
<
	" Same as preceding map but for current fg color region.
	" Note: This one demonstrates the use of the 'jump-to-token' expansion
	" macros. >
	let g:txtfmtUsermap6 = 'nnoremap <Bslash>cc <<n[tbc>>c<<o]c>>'
<
	" Map <LocalLeader>bw in normal mode to embolden the word under the
	" cursor. (The extra complexity is needed to ensure that you can invoke
	" with cursor anywhere on the word.) >
	let g:txtfmtUsermap7 =
	    \'nnoremap <LocalLeader>bw :if col(".")!=1 && '
	    \.'getline(".")[col(".")-2]=~"\\w"<Bar>exe "norm!  b"<Bar>'
	    \.'endif<CR><<n\vi:fb>>e<<n\va:f->>b'
<
	" Map \vf in normal mode to select all of the current format region
	" visually.
	" Note: Unlike the earlier one for changing the text in the current
	" format region, this one doesn't constrain the backwards jump to a
	" 'begin region' token; hence, it will also highlight the text between
	" regions if the cursor lies between regions at the time the map is
	" invoked. >
	let g:txtfmtUsermap8 = 'nnoremap <LocalLeader>vf <<n[tf>>v<<v]tf>>'
<
	" Map <C-\>vf in insert mode to do the same in insert mode >
	let g:txtfmtUsermap9 = 'inoremap <C-\>vf <<i[tf>><Esc>lv<<v]tf>>'
<
	" Map <LocalLeader><Space> in normal mode to jump forward to the 3rd
	" 'begin format region' token. (Not overly practical, but demonstrates the
	" use of whitespace in the lhs, as well as the use of the optional count
	" with the jump-to-token expansion macros.) >
	let g:txtfmtUsermap10 = 'nnoremap <LocalLeader><Space> <<n3]bf>>'
<
	" Map <LocalLeader>_ in normal mode to substitute the next 4 characters
	" with a bold format token followed by a 'no format' token, leaving the
	" cursor positioned between the two.
	" (This map is not intended to be useful, but merely to demonstrate the
	" specification of a count with an insert-token expansion macro.) >
	let g:txtfmtUsermap11 = 'nnoremap <LocalLeader>_ <<n4\s:fb.f->>'
<
	" Map <LocalLeader>rb in normal mode to make the current line bold with a
	" red background. >
	let g:txtfmtUsermap12 =
	    \'nnoremap <LocalLeader>rb <<n\vI:kr,fb>><<n\vA:f-,k->>'
<

Using buf-local sets				*txtfmt-buflocal-user-map*

As mentioned in an earlier section, both txtfmtUsermap{} and
txtfmtUsermaplimit may be set either globally or buf-locally. Here's how it
works... When Txtfmt loads, it determines the effective value of
txtfmtUsermaplimit according to the following logic: >
	if exists('b:txtfmtUsermaplimit')
		let txtfmtUsermaplimit = b:txtfmtUsermaplimit
	elseif exists('g:txtfmtUsermaplimit')
		let txtfmtUsermaplimit = g:txtfmtUsermaplimit
	else
		let txtfmtUsermaplimit = 25 "use default
	endif

Txtfmt then executes the following (pseudo-code) loop: >
	for i = 1, txtfmtUsermaplimit
		if exists('b:txtfmtUsermap{i}')
			Define user-map b:txtfmtUsermap{i}
		elseif exists('g:txtfmtUsermap{i}')
			Define user-map g:txtfmtUsermap{i}
		endif
	endloop

Several points to note:
    -Leaving elements of txtfmtUsermap{} undefined is harmless.
    -Setting b:txtfmtUsermaplimit effectively overrides any existing setting
     of g:txtfmtUsermaplimit.
    -Setting an element of b:txtfmtUsermap{} effectively hides the
     corresponding element of g:txtfmtUsermap{}.

You may be wondering why you would ever need to use the buffer-local versions
of txtfmtUsermap{} and txtfmtUsermaplimit. If you edit only one type of file
with Txtfmt, then the simplest approach would be to use only the global
versions. It is possible, however, that while you have some user-maps that are
generally useful, you also have some special-purpose user-maps, which are
useful only in a certain type of file. Defining such user-maps globally would
render the corresponding {map-lhs} unusable in files in which you would never
need the special-purpose user-map. I will now describe a strategy that uses
the buf-local user-map option variables to circumvent the problem just
described...

STEP #1
=======
In your .vimrc, define user-maps 1..N using g:txtfmtUsermap{} and set the
global version of txtfmtUsermaplimit to N.
Note: All of the maps defined in this manner should be general purpose maps,
which you might need in any Txtfmt buffer.

Example: >
	let g:txtfmtUsermap1 = '<generally useful map #1>'
	let g:txtfmtUsermap2 = '<generally useful map #2>'
	.
	.
	let g:txtfmtUsermapN = '<generally useful map #N>'
	let g:txtfmtUsermaplimit = N

STEP #2
=======
Create global functions that define special-purpose user maps N+1..M using the
buffer-local versions of txtfmtUsermap{} and set the buffer-local version of
txtfmtUsermaplimit to N+M.
Note: Since these functions do not overwrite previously set elements of the
g:txtfmtUsermap{}, the general-purpose user-maps will be left intact.

Example: >
	" This function defines special-purpose Txtfmt user-maps, useful only
	" for *.abc files.
	fu! Define_txtfmt_abc_usermaps()
		let N = g:txtfmtUsermaplimit
		let b:txtfmtUsermap{N+1} = '<special-purpose map #1>'
		let b:txtfmtUsermap{N+2} = '<special-purpose map #2>'
		.
		.
		let b:txtfmtUsermap{N+M} = '<special-purpose map #M>'
		" Ensure that both the general-purpose and special-purpose
		" user-maps are defined.
		let b:txtfmtUsermaplimit = N+M
	endfu

STEP #3
=======
Ensure that each special-purpose map function is called from an autocommand
specific to the filetype that will need the user-maps it defines.

Note: It is necessary to define these autocommands prior to the ones that set
filetype to txtfmt, so that the changes to txtfmtUsermap{} occur before Txtfmt
is loaded. An easy way to ensure the proper sequence is to place the
autocommands that call the map definition functions within the same
autocommand group as the setfiletype autocommand (see example below).

Example: >
	" Inside ~/.vim/filetype.vim
	augroup filetypedetect
	    au! BufRead,BufNewFile *.abc    call Define_txtfmt_abc_usermaps()
	    au! BufRead,BufNewFile *.xyz    call Define_txtfmt_xyz_usermaps()
	    .
	    .
	    " Set up detection for Txtfmt files
	    au! BufRead,BufNewFile *.abc    setfiletype txtfmt
	    au! BufRead,BufNewFile *.xyz    setfiletype txtfmt
	    au! BufRead,BufNewFile *.txt    setfiletype txtfmt
	augroup END

It should be noted that the strategy outlined above is simply one of many
possibilities. A slight variation would be to replace the general-purpose
user-maps altogether with special-purpose ones for one or more filetypes.
Suppose, for example, that we knew we would use only special-purpose maps when
editing a '*.abc' file. In that case, we would simply omit all occurrences of
"N+" in Define_txtfmt_abc_usermaps() to ensure that the general-purpose maps
were overridden.

CREATING TOKEN STRINGS				*txtfmt-create-tok-str*
Txtfmt_GetTokStr({fmt-clr-spec-list})		*txtfmt-GetTokStr()*
	This function accepts a |txtfmt-fmt-clr-spec-list| as input and
	returns the corresponding sequence of Txtfmt tokens as a string.
	Note: May be called only from a Txtfmt buffer.

QUERYING TOKEN TYPE				*txtfmt-query-tok-type*

In most cases, the role played by a Txtfmt token will be evident from the
highlighting of the text that follows it. There are at least two scenarios,
however, in which the role played by a particular format or color token may
not be evident: 1) there is no text following the token; 2) adjacent format
and color tokens make it difficult to tell which is which, since the
formatting of the subsequent text does not depend upon the order of the
tokens. Although you can always look up the character code (obtained from
Vim's ga command) in the output of the |txtfmt-:ShowTokenMap| command, this
section presents some more convenient methods of determining a token's type...

Token-descriptors 				*txtfmt-tok-descriptor*

A {token-descriptor} is returned or displayed by all of the mappings, commands
and functions discussed in this section. A {token-descriptor} is simply a
string providing information about a particular character or token in a Txtfmt
buffer. Its format depends upon how the character is used in the buffer. The
possibilities are described below...

    format token
	A |txtfmt-fmt-spec| in fiducial form (e.g. "fubi")
    color token
	A string of the form {type}{colornum}[ (inactive)], where {type}
	indicates the type of color token ('c' => fg, 'k' => bg), {colornum}
	is a value between 1 and 8 indicating the color's index, and the
	optional " (inactive)" label, if present, indicates that the color is
	disabled by the current color mask. (For details on color masks, see
	|txtfmtFgcolormask| or |txtfmtBgcolormask|.)
    non-Txtfmt char
	A character code value in decimal format (e.g. 'a' => 97)
    invalid char position
	"NUL" (just like Vim's ga command)

						*\ga* 	*txtfmt-get-tok-info*
<LocalLeader>ga    <Plug>TxtfmtGetTokInfo
	This mapping echoes the {token-descriptor} (discussed above) of the
	character under the cursor. Analogous to Vim's builtin ga command, it
	provides the most convenient way to obtain information about the token
	under the cursor. The primary difference between it and the builtin
	version is that the Txtfmt version is aware of the special role played
	by Txtfmt formatting tokens.
	
	Note: The <Plug> form of the mapping may be used for customization.
	For details on customizing maps, refer to section |txtfmt-map-config|.

						*txtfmt-:GetTokInfo*
:GetTokInfo [ {line} {col} ]
	This buffer-local command echoes the {token-descriptor} corresponding
	to the character/token at the requested {line} and {col} in the
	current buffer. If {line} and {col} are not supplied, the cursor
	location is assumed; i.e., calling :GetTokInfo without args is
	equivalent to executing the \ga mapping.
	Note: If either {line} or {col} is specified, both must be specified.
	Note: {col} is a 1-based byte index, such as would be returned by
	Vim's col() function. Note that this index may differ from both the
	virtual column index and the character index.

						*txtfmt-GetTokInfo()*
Txtfmt_GetTokInfo([{line}, {char}])
	!!!!!!!!!!!!!!!!!!
	<<< DEPRECATED >>>
	!!!!!!!!!!!!!!!!!!

	IMPORTANT NOTE: I have marked this function as deprecated because both
	the mapping and command (discussed above) provide similar
	functionality and are easier to use; however, on the off-chance that
	someone created a mapping to this function in one of the initial
	versions of Txtfmt, I have not yet removed it. Note that the 2nd
	argument to this function is a character index, which is fundamentally
	different from the byte index provided to the :GetTokInfo command. As
	a general rule, supplying byte indices, (which may be obtained with
	Vim's col() function), is easier for the plugin user.

	This function returns a string describing the token specified by
	{line} and {char}. Note that both {line} and {char} are optional.
	Either both or neither should be specified. If neither is specified,
	the returned information will apply to the character under the cursor.
	Otherwise, {char} is the 1-based index of a token on the line
	specified by {line}.
	Important Note: Because {char} is a character index, its value may
	differ from the values returned by virtcol() (screen column index) and
	col() (byte index).
	The format of the return string depends upon the type of token
	being queried, and is described above under |txtfmt-tok-descriptor|.


VIEWING TOKEN MAP				*txtfmt-view-tok-map*
						*txtfmt-:ShowTokenMap*
:ShowTokenMap
	This buffer-local command echoes a table displaying the current
	format/color token map in an intuitive and informative manner.
	Note: Since a Txtfmt token map is specific to a buffer, the command
	may be used only from a Txtfmt buffer. The table columns are slightly
	different for formats and colors. Here is some sample output text,
	which corresponds to the default |txtfmt-'tokrange'| setting...

	 === FG COLORS ===
	 char-nr  description            clr-pattern          clr-def  
	 0xE000   no color               -                    N.A.     
	 0xE001   Color1                 ^\%(k\|bla\%[ck]\)$  #000000  
	 0xE002   Color2                 ^b\%[lue]$           #0000FF  
	 .
	 .
	 0xE008   Color8                 ^w\%[hite]$          #FFFFFF  
	 === FORMAT ===
	 char-nr  description            fmt-spec             
	 0xE009   no format              -                    
	 0xE00A   underline              u                    
	 .
	 .
	 0xE010   underline,bold,italic  ibu                  
	 === BG COLORS ===
	 char-nr  description            clr-pattern          clr-def  
	 0xE011   no color               -                    N.A.     
	*0xE012   Color1 (inactive)      ^\%(k\|bla\%[ck]\)$  #000000  
	 0xE013   Color2                 ^b\%[lue]$           #0000FF  
	 .
	 .
	*0xE019   Color8 (inactive)      ^w\%[hite]$          #FFFFFF  

	Several points to note:

	The fmt-spec column gives the set of characters (in fiducial form)
	that you would put after the 'f' in a |txtfmt-fmt-spec| to insert the
	corresponding format token.
	Note: The order of the characters in the set is not significant; i.e.,
	"ubi" is equivalent to "ibu" and "bui".

	The clr-pattern column represents the Vim regular expression that is
	used to recognize a color name in a |txtfmt-clr-spec|.

	The clr-def column under the "COLORS" section represents the actual
	color definitions supplied to Vim via the :highlight command: e.g.
		hi guifg={clr-def}
		hi ctermfg={clr-def}
	For GUI'S, the {clr-def} is either a symbolic color name (e.g.,
	DarkBlue) or a literal RGB value (e.g., #FF0000). For cterm's, it
	could be a color number or a symbolic color name.
	Note: All of the values in the final 2 columns of the "FG/BG COLORS"
	sections may be overridden by the user. For details, see
	|txtfmt-color-config|.

	The presence of an asterisk before the char-nr and the string
	"(inactive)" following the color description indicates that a color
	has been rendered inactive by the fg or bg colormask currently in
	effect. For details, see |txtfmtFgcolormask|.

	The char-nr column displays the character code value in the number
	format used to set |txtfmt-'tokrange'|.


TESTING CURRENT SETTINGS			*txtfmt-test-cur-settings*
						*txtfmt-:MakeTestPage*
:MakeTestPage [{modeline}]
	This buffer-local command creates a scratch buffer containing a
	Txtfmt "test page". The Txtfmt options used to create the test page
	take into account any global option settings, as well as any
	|txtfmt-modeline| settings specified on the command line as arguments
	to the command. Example: >

		:MakeTestPage tokrange=180S escape=bslash nested
<
	This creates a test page with the |txtfmt-'tokrange'| option set to
	"180S", the |txtfmt-'escape'| option set to "bslash" and the
	|txtfmt-'nested'| option turned on. All other Txtfmt options will have
	the values set globally, or default values if the global option has
	not been set.
	Note: Since the test page is created in a new scratch buffer,
	buffer-local option settings are not considered.

	This command provides a quick and easy way to visualize the effects of
	a particular combination of option values. Suppose, for example, that
	the default 'tokrange' option setting yields Txtfmt tokens that cannot
	be concealed by Vim, due to their use as control sequences by a
	particular terminal. In this case, you might wish to run :MakeTestPage
	iteratively, each time supplying a different value for 'tokrange',
	until you find one that appears to work.

	In addition to displaying all available formats and colors (both
	foreground and background if applicable), the test page attempts to
	show how things like token escaping and nesting of Txtfmt regions
	within non-Txtfmt regions will (or won't) work, given the applicable
	option settings. The text in the test page buffer is rather verbose,
	and is intended as an aid to the new user. Although the primary
	purpose of the test page is to provide information, the buffer created
	is a fully valid Txtfmt buffer; hence, you are free to make changes in
	it, using it as a scratchpad for testing the various Txtfmt mappings.

	Note: If the text in the buffer does not appear to be highlighted at
	all, it may be that you have not installed Txtfmt properly. (See
	section |txtfmt-installation|.) Currently, the :MakeTestPage command
	loads the Txtfmt plugin files by executing the following command in
	the scratch buffer: >

		:set filetype=txtfmt

<	On a typical system (one on which filetype and syntax are both
	enabled), this results in a :runtime sourcing of both
	ftplugin/txtfmt.vim and syntax/txtfmt.vim. Of course, if you have
	syntax and/or filetype plugins disabled, you will not be able to view
	the test page as it was meant to be viewed...

TRANSLATING TOKEN RANGE				*txtfmt-move-tok-range*
						*txtfmt-:MoveStartTok*
:MoveStartTok {new-starttok} [{old-vim-ver}]
	NOTE: This command changes the current buffer!

	This buffer-local command relocates the Txtfmt token range in use in
	the current buffer from its current location to {new-starttok}. Its
	purpose is to provide an easy way to change the |txtfmt-'tokrange'|
	option value in a file that already contains a large number of Txtfmt
	tokens.

	The {new-starttok} argument specifies the character code to be used as
	the start of the new token range. It should be a decimal or
	hexadecimal value, which is valid for the 'encoding' in effect.
	Note: You should NOT append the {formats} specifier to the numeric
	starttok value; the current value will be used. (See
	|txtfmt-'tokrange'| for a description of the {formats} specifier.)

	The optional {old-vim-ver} argument allows you to specify the version
	of Vim that was used to create the file being changed. This could be
	important if the following conditions are met:
		-"Long" formats are in effect.
		-The version of Vim used to create the file differs from the
		 current version.
		-Only one of these versions supports the undercurl attribute.

	Txtfmt will not attempt to move characters in the undercurl range if
	the version of Vim used to create the file does not support undercurl.
	Txtfmt will, on the other hand, move such tokens if the version used
	to create the file supports undercurl, and undercurl has not been
	explicitly disabled with the |txtfmt-'undercurl'| option. Thus, it is
	possible to translate undercurl tokens even with a version of Vim that
	doesn't support undercurl. In other words, Txtfmt uses the
	{old-vim-ver} argument to determine the "shape" of the Txtfmt token
	range that needs to be translated.
	Note: If the optional {old-vim-ver} argument is omitted, Txtfmt
	assumes the buffer was created with the current version of Vim.
	
	Since Txtfmt was first released after Vim began supporting undercurl
	(in version 7.0), the {old-vim-ver} argument can generally be omitted,
	and is included only for the sake of completeness. Note: The format of
	{old-vim-ver} is identical to the format of v:version; i.e., Vim major
	version number times 100 plus Vim minor version number. e.g.,
	    Vim 7.1 ==> "701"

	If the |txtfmt-'escape'| option is set to something other than "none",
	:MoveStartTok takes the current escape method into account, and
	attempts to do whatever makes sense with regard to escaped and
	escaping characters. Consider that escaping is used to prevent special
	interpretation of characters. When the Txtfmt token range moves, some
	of the characters that would have been interpreted specially under the
	old token range are not special at all under the new range, and hence,
	no longer require escaping. Similarly, characters that were not
	special at all under the old token range lie squarely within the new
	token range, and hence require escaping to prevent their being
	interpreted specially.

	Here's how Txtfmt handles token translation when escaping is in
	effect... Characters that are not currently special, but will be after
	the move, are escaped. Tokens that are currently escaped are not
	translated. Characters that are currently escaped to prevent special
	interpretation, but will not need to be escaped after the translation,
	have their escaping characters removed.

	Note: In the context of the preceding paragraph, a character is
	considered to be "special" if it could be interpreted as either a
	Txtfmt token or an escaping character. For details on what constitutes
	an escaping character, see |txtfmt-'escape'|.
	
	If there is a |txtfmt-modeline| containing a tokrange option setting
	in the current buffer, it will be altered to reflect the new token
	range. After the changes have been made to the buffer, the filetype
	and syntax plugins are automatically reloaded to cause the new
	tokrange setting to take effect. As a result, there should generally
	be no visible change to the buffer as a result of executing the
	:MoveStartTok command.

	Note: As previously mentioned, :MoveStartTok alters the current
	buffer. Txtfmt will save the buffer after performing the token
	translation unless there were unsaved changes when the command was
	invoked. In that case, Txtfmt assumes that the user was not yet ready
	to save the existing changes and leaves the buffer modified. Of
	course, if you don't like the changes made by the :MoveStartTok
	command, you can always undo them, regardless of whether or not the
	changes have been saved.

	Examples of use:
		Move current tokrange to start of "Private Use Area" >
		:MoveStartTok 0xE000
<
		Move current tokrange to 190 (in file created with Vim 6.3) >
		:MoveStartTok 190 603
<

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
indent_patch.txt	[[[1
50
*** ../vim-7.1.262/runtime/indent.vim   Mon Mar 28 22:56:55 2005
--- runtime/indent.vim  Fri Feb 22 20:54:41 2008
***************
*** 1,7 ****
  " Vim support file to switch on loading indent files for file types
  "
  " Maintainer: Bram Moolenaar <Bram@vim.org>
! " Last Change:        2005 Mar 28
  
  if exists("did_indent_on")
    finish
--- 1,7 ----
  " Vim support file to switch on loading indent files for file types
  "
  " Maintainer: Bram Moolenaar <Bram@vim.org>
! " Last Change:        2008 Feb 22
  
  if exists("did_indent_on")
    finish
***************
*** 15,25 ****
        exe b:undo_indent
        unlet! b:undo_indent b:did_indent
      endif
!     if expand("<amatch>") != ""
        if exists("b:did_indent")
        unlet b:did_indent
        endif
!       runtime! indent/<amatch>.vim
      endif
    endfunc
  augroup END
--- 15,31 ----
        exe b:undo_indent
        unlet! b:undo_indent b:did_indent
      endif
!     let s = expand("<amatch>")
!     if s != ""
        if exists("b:did_indent")
        unlet b:did_indent
        endif
!
!       " When there is a dot it is used to separate filetype names.  Thus for
!       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
!       for name in split(s, '\.')
!       exe 'runtime! indent/' . name . '.vim'
!       endfor
      endif
    endfunc
  augroup END
